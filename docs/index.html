<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>CAC Utili-Track</title>

<!-- Firebase Scripts -->
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

<script>
// Firebase configuration
const firebaseConfig = {
    apiKey: "AIzaSyAa5gWHbC_9t_DaW0-ZfN9uG6mxkJj5u9w",
    authDomain: "cac-utilitrack.firebaseapp.com",
    projectId: "cac-utilitrack",
    storageBucket: "cac-utilitrack.firebasestorage.app",
    messagingSenderId: "1070773430788",
    appId: "1:1070773430788:web:a02272d5037e4ced9fa351"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
</script>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
<!-- Font Awesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
<!-- Google Fonts -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Space+Grotesk:wght@300;400;500;600;700&display=swap">

<style>
    :root {
        /* Premium Color Palette */
        --bg-primary: #0a0a0f;
        --bg-secondary: #12121a;
        --bg-tertiary: #1a1a25;
        --bg-glass: rgba(18, 18, 26, 0.85);
        --bg-glass-light: rgba(255, 255, 255, 0.05);
        
        --text-primary: #ffffff;
        --text-secondary: #a0a0b8;
        --text-tertiary: #6b6b80;
        
        --border-color: rgba(255, 255, 255, 0.1);
        --border-active: rgba(255, 255, 255, 0.2);
        
        /* Premium Shadows */
        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
        --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);
        --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
        --shadow-xl: 0 12px 48px rgba(0, 0, 0, 0.6);
        --shadow-glow: 0 0 40px rgba(102, 126, 234, 0.5);
        
        /* Utility Colors - Premium Vibrant */
        --water-color: #00b4d8;
        --gas-color: #ffd60a;
        --electric-color: #ff006e;
        --sewer-color: #a8763e;
        --telecom-color: #b565d8;
        
        /* UI Accent Colors */
        --danger-color: #ff0054;
        --success-color: #00f5a0;
        --warning-color: #ffd60a;
        --info-color: #00b4d8;
        
        /* Premium Gradients */
        --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        --gradient-danger: linear-gradient(135deg, #ff0054 0%, #ff006e 100%);
        --gradient-success: linear-gradient(135deg, #00f5a0 0%, #00d084 100%);
        --gradient-premium: linear-gradient(180deg, #0a0a0f 0%, #1a1a25 100%);
        --gradient-glass: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
        --gradient-gold: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
        
        /* Spacing */
        --spacing-xs: 4px;
        --spacing-sm: 8px;
        --spacing-md: 16px;
        --spacing-lg: 24px;
        --spacing-xl: 32px;
        --spacing-2xl: 48px;
        
        /* Border Radius */
        --radius-sm: 8px;
        --radius-md: 12px;
        --radius-lg: 16px;
        --radius-xl: 24px;
        --radius-2xl: 32px;
        --radius-full: 9999px;
        
        /* Transitions */
        --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
        --transition-normal: 300ms cubic-bezier(0.4, 0, 0.2, 1);
        --transition-slow: 500ms cubic-bezier(0.4, 0, 0.2, 1);
        --transition-spring: 500ms cubic-bezier(0.34, 1.56, 0.64, 1);
        --transition-bounce: 600ms cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    /* Light Mode */
    [data-theme="light"] {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-tertiary: #e9ecef;
        --bg-glass: rgba(255, 255, 255, 0.85);
        --bg-glass-light: rgba(0, 0, 0, 0.05);
        --text-primary: #1a1d21;
        --text-secondary: #6c757d;
        --text-tertiary: #adb5bd;
        --border-color: rgba(0, 0, 0, 0.1);
        --border-active: rgba(0, 0, 0, 0.2);
        --gradient-premium: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
    }
    
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    
    html, body {
        height: 100%;
        width: 100%;
        overflow: hidden;
        font-family: 'Inter', -apple-system, sans-serif;
        background-color: var(--bg-primary);
        color: var(--text-primary);
        touch-action: manipulation;
        -webkit-text-size-adjust: 100%;
        overscroll-behavior: none;
    }
    
    /* Prevent all zooming */
    input, select, textarea {
        font-size: 16px !important;
        touch-action: manipulation;
    }
    
    /* App Container */
    .app-container {
        position: relative;
        width: 100%;
        height: 100vh;
        height: 100dvh;
        overflow: hidden;
        background: var(--bg-primary);
    }
    
    /* Map Container */
    #map {
        width: 100%;
        height: 100%;
        z-index: 1;
        background: var(--bg-primary);
    }
    
    /* ========== TRIPLE AAA QUALITY SPLASH SCREEN ========== */
    .splash-screen {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #0a0a0f 0%, #1a1a25 50%, #0f0c1a 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        opacity: 1;
        transition: all 2s cubic-bezier(0.23, 1, 0.32, 1);
        overflow: hidden;
    }
    
    .splash-screen.hide {
        opacity: 0;
        transform: scale(1.1);
        filter: blur(20px);
        pointer-events: none;
    }
    
    /* Dynamic Geometric Background */
    .splash-background {
        position: absolute;
        inset: 0;
        overflow: hidden;
    }
    
    .geometric-layer {
        position: absolute;
        inset: 0;
        opacity: 0.8;
    }
    
    .geo-shape {
        position: absolute;
        background: linear-gradient(45deg, transparent, rgba(102, 126, 234, 0.1));
        border: 1px solid rgba(102, 126, 234, 0.2);
        border-radius: 20% 80% 60% 40% / 40% 60% 80% 20%;
        animation: morphShape 8s ease-in-out infinite;
        filter: blur(1px);
    }
    
    .geo-shape:nth-child(1) {
        width: 300px;
        height: 300px;
        top: 10%;
        left: -10%;
        animation-delay: 0s;
        background: linear-gradient(45deg, transparent, rgba(255, 0, 110, 0.08));
        border-color: rgba(255, 0, 110, 0.15);
    }
    
    .geo-shape:nth-child(2) {
        width: 400px;
        height: 400px;
        top: 30%;
        right: -15%;
        animation-delay: 2s;
        background: linear-gradient(45deg, transparent, rgba(0, 245, 160, 0.06));
        border-color: rgba(0, 245, 160, 0.12);
    }
    
    .geo-shape:nth-child(3) {
        width: 250px;
        height: 250px;
        bottom: 20%;
        left: 20%;
        animation-delay: 4s;
        background: linear-gradient(45deg, transparent, rgba(255, 214, 10, 0.07));
        border-color: rgba(255, 214, 10, 0.14);
    }
    
    .geo-shape:nth-child(4) {
        width: 350px;
        height: 350px;
        bottom: 10%;
        right: 10%;
        animation-delay: 6s;
        background: linear-gradient(45deg, transparent, rgba(181, 101, 216, 0.05));
        border-color: rgba(181, 101, 216, 0.1);
    }
    
    @keyframes morphShape {
        0%, 100% {
            transform: rotate(0deg) scale(1);
            border-radius: 20% 80% 60% 40% / 40% 60% 80% 20%;
            opacity: 0.6;
        }
        25% {
            transform: rotate(90deg) scale(1.1);
            border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%;
            opacity: 0.8;
        }
        50% {
            transform: rotate(180deg) scale(0.9);
            border-radius: 80% 20% 50% 50% / 50% 80% 20% 50%;
            opacity: 0.4;
        }
        75% {
            transform: rotate(270deg) scale(1.05);
            border-radius: 40% 60% 70% 30% / 70% 40% 60% 30%;
            opacity: 0.7;
        }
    }
    
    /* Advanced Particle System */
    .splash-particles {
        position: absolute;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
    }
    
    .neural-particle {
        position: absolute;
        width: 2px;
        height: 2px;
        background: #ffffff;
        border-radius: 50%;
        opacity: 0;
        box-shadow: 0 0 10px currentColor;
        animation: neuralFlow 12s linear infinite;
    }
    
    .neural-particle:nth-child(1) { 
        color: #667eea; 
        animation-delay: 0s; 
        left: 0%; 
        animation-duration: 15s;
    }
    .neural-particle:nth-child(2) { 
        color: #ff006e; 
        animation-delay: 2s; 
        left: 10%; 
        animation-duration: 18s;
    }
    .neural-particle:nth-child(3) { 
        color: #00f5a0; 
        animation-delay: 4s; 
        left: 20%; 
        animation-duration: 12s;
    }
    .neural-particle:nth-child(4) { 
        color: #ffd60a; 
        animation-delay: 6s; 
        left: 30%; 
        animation-duration: 20s;
    }
    .neural-particle:nth-child(5) { 
        color: #b565d8; 
        animation-delay: 8s; 
        left: 40%; 
        animation-duration: 14s;
    }
    .neural-particle:nth-child(6) { 
        color: #00b4d8; 
        animation-delay: 1s; 
        left: 50%; 
        animation-duration: 16s;
    }
    .neural-particle:nth-child(7) { 
        color: #ff6b35; 
        animation-delay: 3s; 
        left: 60%; 
        animation-duration: 13s;
    }
    .neural-particle:nth-child(8) { 
        color: #4ecdc4; 
        animation-delay: 5s; 
        left: 70%; 
        animation-duration: 17s;
    }
    .neural-particle:nth-child(9) { 
        color: #ffe66d; 
        animation-delay: 7s; 
        left: 80%; 
        animation-duration: 19s;
    }
    .neural-particle:nth-child(10) { 
        color: #a8e6cf; 
        animation-delay: 9s; 
        left: 90%; 
        animation-duration: 11s;
    }
    
    @keyframes neuralFlow {
        0% {
            transform: translateY(100vh) translateX(0) scale(0);
            opacity: 0;
        }
        5% {
            opacity: 1;
            transform: translateY(95vh) translateX(0) scale(1);
        }
        50% {
            transform: translateY(50vh) translateX(100px) scale(1.5);
            opacity: 0.8;
        }
        95% {
            opacity: 1;
            transform: translateY(5vh) translateX(-50px) scale(1);
        }
        100% {
            transform: translateY(-5vh) translateX(0) scale(0);
            opacity: 0;
        }
    }
    
    /* Ultra Modern Logo System */
    .splash-logo-container {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        animation: logoMasterEntrance 3s cubic-bezier(0.23, 1, 0.32, 1);
        margin-bottom: 60px;
    }
    
    @keyframes logoMasterEntrance {
        0% {
            transform: scale(0.3) rotateY(180deg);
            opacity: 0;
            filter: blur(20px);
        }
        60% {
            transform: scale(1.1) rotateY(-10deg);
            opacity: 1;
            filter: blur(0px);
        }
        100% {
            transform: scale(1) rotateY(0deg);
            opacity: 1;
            filter: blur(0px);
        }
    }
    
    /* Hexagonal Tech Symbol */
    .logo-hexagon {
        position: relative;
        width: 160px;
        height: 160px;
        margin-bottom: 40px;
        animation: hexRotate 20s linear infinite;
    }
    
    @keyframes hexRotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    .hex-core {
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, 
            rgba(102, 126, 234, 0.1) 0%, 
            rgba(255, 0, 110, 0.15) 50%, 
            rgba(0, 245, 160, 0.1) 100%);
        clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
        border: 2px solid rgba(102, 126, 234, 0.3);
        animation: hexPulse 4s ease-in-out infinite;
        backdrop-filter: blur(10px);
    }
    
    @keyframes hexPulse {
        0%, 100% {
            transform: scale(1);
            border-color: rgba(102, 126, 234, 0.3);
            background: linear-gradient(135deg, 
                rgba(102, 126, 234, 0.1) 0%, 
                rgba(255, 0, 110, 0.15) 50%, 
                rgba(0, 245, 160, 0.1) 100%);
        }
        50% {
            transform: scale(1.05);
            border-color: rgba(0, 245, 160, 0.5);
            background: linear-gradient(135deg, 
                rgba(0, 245, 160, 0.15) 0%, 
                rgba(102, 126, 234, 0.2) 50%, 
                rgba(255, 0, 110, 0.1) 100%);
        }
    }
    
    .hex-inner {
        position: absolute;
        inset: 12px;
        clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
        background: rgba(10, 10, 15, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        animation: hexInnerFloat 6s ease-in-out infinite;
    }
    
    @keyframes hexInnerFloat {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-8px); }
    }
    
    .hex-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 8px;
        width: 80px;
        height: 80px;
    }
    
    .hex-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea, #764ba2);
        animation: dotSequence 3s ease-in-out infinite;
        opacity: 0.3;
        box-shadow: 0 0 15px currentColor;
    }
    
    .hex-dot:nth-child(1) { animation-delay: 0s; color: #00b4d8; }
    .hex-dot:nth-child(2) { animation-delay: 0.1s; color: #ffd60a; }
    .hex-dot:nth-child(3) { animation-delay: 0.2s; color: #ff006e; }
    .hex-dot:nth-child(4) { animation-delay: 0.3s; color: #a8763e; }
    .hex-dot:nth-child(5) { animation-delay: 0.4s; color: #667eea; }
    .hex-dot:nth-child(6) { animation-delay: 0.5s; color: #b565d8; }
    .hex-dot:nth-child(7) { animation-delay: 0.6s; color: #00f5a0; }
    .hex-dot:nth-child(8) { animation-delay: 0.7s; color: #ff6b35; }
    .hex-dot:nth-child(9) { animation-delay: 0.8s; color: #4ecdc4; }
    
    @keyframes dotSequence {
        0%, 80% { 
            opacity: 0.3; 
            transform: scale(1); 
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        10%, 30% { 
            opacity: 1; 
            transform: scale(1.4); 
            background: linear-gradient(135deg, currentColor, #ffffff);
            box-shadow: 0 0 25px currentColor;
        }
    }
    
    /* Premium Typography System */
    .splash-title {
        font-family: 'Space Grotesk', sans-serif;
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(135deg, 
            #ffffff 0%, 
            #667eea 20%, 
            #ff006e 40%, 
            #00f5a0 60%, 
            #ffd60a 80%, 
            #ffffff 100%);
        background-size: 400% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: -1px;
        margin-bottom: 16px;
        animation: titleFlow 6s ease-in-out infinite;
        text-align: center;
        position: relative;
        opacity: 0;
        transform: translateY(30px);
        animation: titleEntrance 2s ease-out 1s forwards, titleFlow 6s ease-in-out 3s infinite;
    }
    
    @keyframes titleEntrance {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    @keyframes titleFlow {
        0%, 100% { background-position: 0% center; }
        50% { background-position: 100% center; }
    }
    
    .splash-subtitle {
        font-family: 'Inter', sans-serif;
        font-size: 14px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.6);
        letter-spacing: 3px;
        text-transform: uppercase;
        text-align: center;
        opacity: 0;
        transform: translateY(20px);
        animation: subtitleEntrance 1.5s ease-out 2s forwards;
        position: relative;
    }
    
    @keyframes subtitleEntrance {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* Advanced Loading System */
    .splash-loading {
        position: absolute;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
    }
    
    .loading-bar-container {
        width: 300px;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
        position: relative;
        border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .loading-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, 
            #667eea 0%, 
            #ff006e 25%, 
            #00f5a0 50%, 
            #ffd60a 75%, 
            #b565d8 100%);
        transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        border-radius: 2px;
        box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
    }
    
    .loading-bar::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(255, 255, 255, 0.4) 50%, 
            transparent 100%);
        animation: loadingShine 2s ease-in-out infinite;
    }
    
    @keyframes loadingShine {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }
    
         .loading-text {
         font-family: 'Inter', sans-serif;
         font-size: 12px;
         font-weight: 500;
         color: rgba(255, 255, 255, 0.7);
         letter-spacing: 1px;
         text-align: center;
         transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
         opacity: 1;
     }
     
     .loading-percentage {
         font-family: 'Space Grotesk', sans-serif;
         font-size: 16px;
         font-weight: 700;
         color: #ffffff;
         margin-top: 12px;
         letter-spacing: 2px;
         transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
         transform: scale(1);
     }
    
    /* Premium Top Bar */
    .top-bar {
        position: absolute;
        top: env(safe-area-inset-top, 0);
        left: 0;
        right: 0;
        padding: var(--spacing-md);
        z-index: 100;
        pointer-events: none;
    }
    
    .top-bar > * {
        pointer-events: auto;
    }
    
    /* Utility Selector - Premium Glass Design */
    .utility-selector {
        display: flex;
        gap: 2px;
        justify-content: center;
        margin: 0 auto;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-2xl);
        padding: 6px;
        box-shadow: var(--shadow-lg), inset 0 1px 0 var(--border-color);
        max-width: fit-content;
        border: 1px solid var(--border-color);
        position: relative;
    }
    
    .utility-selector::before {
        content: '';
        position: absolute;
        inset: -1px;
        background: var(--gradient-primary);
        border-radius: inherit;
        opacity: 0;
        filter: blur(20px);
        transition: opacity var(--transition-normal);
        z-index: -1;
    }
    
    .utility-selector:hover::before {
        opacity: 0.3;
    }
    
    .utility-btn {
        width: 48px;
        height: 48px;
        border: none;
        background: transparent;
        border-radius: var(--radius-xl);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
        position: relative;
        overflow: hidden;
    }
    
    .utility-btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at center, currentColor, transparent);
        opacity: 0;
        transition: opacity var(--transition-fast);
    }
    
    .utility-btn.active::before {
        opacity: 0.2;
    }
    
    .utility-btn::after {
        content: '';
        position: absolute;
        inset: -50%;
        background: radial-gradient(circle at center, currentColor, transparent);
        opacity: 0;
        transform: scale(0);
        transition: all var(--transition-spring);
    }
    
    .utility-btn.active::after {
        opacity: 0.1;
        transform: scale(1);
    }
    
    .utility-btn:active {
        transform: scale(0.92);
    }
    
    .utility-btn i {
        font-size: 22px;
        color: var(--text-tertiary);
        position: relative;
        z-index: 1;
        transition: all var(--transition-normal);
    }
    
    .utility-btn.active i {
        color: currentColor;
        transform: scale(1.15);
        filter: drop-shadow(0 0 8px currentColor);
    }
    
    .utility-btn.water { color: var(--water-color); }
    .utility-btn.gas { color: var(--gas-color); }
    .utility-btn.electric { color: var(--electric-color); }
    .utility-btn.sewer { color: var(--sewer-color); }
    .utility-btn.telecom { color: var(--telecom-color); }
    
    /* Premium Bottom Controls */
    .bottom-controls {
        position: absolute;
        bottom: calc(env(safe-area-inset-bottom, 0) + var(--spacing-md));
        left: var(--spacing-md);
        right: var(--spacing-md);
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        z-index: 100;
        pointer-events: none;
        gap: var(--spacing-md);
    }
    
    .bottom-controls > * {
        pointer-events: auto;
    }
    
    /* Control Groups */
    .control-group {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
    }
    
    .control-group.center {
        position: relative;
    }
    
    /* Premium Control Buttons */
    .control-btn {
        width: 56px;
        height: 56px;
        border: none;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-lg);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-lg);
        transition: all var(--transition-normal);
        position: relative;
        overflow: hidden;
        border: 1px solid var(--border-color);
    }
    
    .control-btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: var(--gradient-glass);
        opacity: 0;
        transition: opacity var(--transition-normal);
    }
    
    .control-btn:hover::before {
        opacity: 1;
    }
    
    .control-btn:active {
        transform: scale(0.92);
        box-shadow: var(--shadow-md);
    }
    
    .control-btn:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-xl);
    }
    
    .control-btn::after {
        content: '';
        position: absolute;
        inset: -2px;
        background: inherit;
        border-radius: inherit;
        opacity: 0;
        filter: blur(10px);
        transition: opacity var(--transition-normal);
        z-index: -1;
    }
    
    .control-btn.active::after {
        opacity: 0.3;
    }
    
    .control-btn.active {
        background: var(--gradient-primary);
        border-color: transparent;
    }
    
    .control-btn i {
        font-size: 24px;
        color: var(--text-primary);
        transition: all var(--transition-normal);
        z-index: 1;
    }
    
    .control-btn.active i {
        color: white;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }
    
    /* Main Action Button Group */
    .main-action-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-sm);
        position: relative;
    }
    
    /* Line Type Toggle - Premium Floating Design */
    .line-type-toggle {
        display: flex;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-full);
        padding: 4px;
        box-shadow: var(--shadow-lg);
        border: 1px solid var(--border-color);
        order: 2;
        margin-top: var(--spacing-xs);
    }
    
    .line-type-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        border: none;
        background: transparent;
        border-radius: var(--radius-full);
        font-size: 13px;
        font-weight: 600;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all var(--transition-normal);
        white-space: nowrap;
        position: relative;
    }
    
    .line-type-btn.active {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    /* Main Draw Button - Premium Animated */
    .main-action-btn {
        width: 72px;
        height: 72px;
        border: none;
        background: var(--gradient-primary);
        border-radius: var(--radius-2xl);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-xl), 0 0 40px rgba(102, 126, 234, 0.3);
        transition: all var(--transition-spring);
        position: relative;
        overflow: hidden;
        order: 1;
    }
    
    .main-action-btn::before {
        content: '';
        position: absolute;
        inset: -2px;
        background: var(--gradient-primary);
        border-radius: inherit;
        opacity: 0;
        filter: blur(15px);
        transition: opacity var(--transition-normal);
    }
    
    .main-action-btn:hover::before {
        opacity: 0.5;
    }
    
    .main-action-btn:active {
        transform: scale(0.92);
        box-shadow: var(--shadow-lg);
    }
    
    .main-action-btn.active {
        animation: drawPulse 2s ease-in-out infinite;
    }
    
    @keyframes drawPulse {
        0%, 100% { 
            box-shadow: var(--shadow-xl), 0 0 40px rgba(102, 126, 234, 0.3);
        }
        50% { 
            box-shadow: var(--shadow-xl), 0 0 60px rgba(102, 126, 234, 0.6);
        }
    }
    
    .main-action-btn i {
        font-size: 32px;
        color: white;
        z-index: 1;
    }
    
    /* Excavation Button - Premium Danger Style */
    .excavation-btn {
        background: var(--gradient-danger) !important;
        position: relative;
        overflow: visible !important;
    }
    
    .excavation-btn::after {
        content: '';
        position: absolute;
        inset: -20px;
        background: var(--gradient-danger);
        border-radius: 50%;
        opacity: 0;
        filter: blur(20px);
        animation: none;
        transition: all var(--transition-normal);
        z-index: -1;
    }
    
    .excavation-btn.active::after {
        animation: excavationPulse 2s ease-in-out infinite;
    }
    
    @keyframes excavationPulse {
        0%, 100% { 
            opacity: 0;
            transform: scale(0.8);
        }
        50% { 
            opacity: 0.5;
            transform: scale(1.2);
        }
    }
    
    .excavation-btn i {
        color: white !important;
    }
    
    /* Right Side Controls */
    .right-controls {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
        position: absolute;
        right: var(--spacing-md);
        top: 50%;
        transform: translateY(-50%);
        z-index: 100;
    }
    
    /* Measurement Tools */
    .measurement-tools {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
        position: absolute;
        left: var(--spacing-md);
        top: 50%;
        transform: translateY(-50%);
        z-index: 100;
    }
    
    .measurement-btn {
        width: 52px;
        height: 52px;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-md);
        transition: all var(--transition-normal);
    }
    
    .measurement-btn.active {
        background: var(--gradient-primary);
        border-color: transparent;
    }
    
    .measurement-btn i {
        font-size: 22px;
        color: var(--text-primary);
    }
    
    .measurement-btn.active i {
        color: white;
    }
    
    /* Ultra Premium GPS Location System */
    .user-location-marker {
        pointer-events: none;
        z-index: 1000;
        transform-origin: center center;
        will-change: transform;
    }
    
    .location-container {
        position: relative;
        width: 56px;
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    /* Multi-Layer Accuracy System */
    .location-accuracy {
        position: absolute;
        inset: -20px;
        border-radius: 50%;
        background: radial-gradient(circle at center, 
            rgba(0, 245, 160, 0.12) 0%, 
            rgba(0, 245, 160, 0.06) 40%,
            rgba(0, 245, 160, 0.02) 70%,
            transparent 100%);
        border: 2px solid rgba(0, 245, 160, 0.3);
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        animation: accuracyPulse 6s ease-in-out infinite;
    }
    
    .location-accuracy::before {
        content: '';
        position: absolute;
        inset: 8px;
        border-radius: 50%;
        border: 1px solid rgba(0, 245, 160, 0.15);
        animation: accuracyPulseInner 4s ease-in-out infinite;
    }
    
    @keyframes accuracyPulse {
        0%, 100% { 
            transform: scale(0.85); 
            opacity: 0.7; 
        }
        50% { 
            transform: scale(1.15); 
            opacity: 0.4; 
        }
    }
    
    @keyframes accuracyPulseInner {
        0%, 100% { 
            transform: scale(1.2); 
            opacity: 0.3; 
        }
        50% { 
            transform: scale(0.8); 
            opacity: 0.8; 
        }
    }
    
    /* Premium GPS Signal Indicator */
    .location-signal {
        position: absolute;
        inset: -30px;
        border-radius: 50%;
        border: 1px solid rgba(0, 245, 160, 0.2);
        animation: signalWave 3s ease-out infinite;
        opacity: 0;
    }
    
    .location-signal:nth-child(2) { animation-delay: 0.8s; }
    .location-signal:nth-child(3) { animation-delay: 1.6s; }
    
    @keyframes signalWave {
        0% {
            transform: scale(0.3);
            opacity: 0.8;
        }
        70% {
            opacity: 0.2;
        }
        100% {
            transform: scale(1.8);
            opacity: 0;
        }
    }
    
    /* Ultra Smooth Direction Arrow */
    .location-arrow {
        position: relative;
        width: 36px;
        height: 36px;
        transform-origin: center center;
        transition: transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        z-index: 3;
        filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.3));
    }
    
    .location-arrow::before {
        content: '';
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 14px solid transparent;
        border-right: 14px solid transparent;
        border-bottom: 32px solid #ffffff;
        filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.2));
    }
    
    .location-arrow::after {
        content: '';
        position: absolute;
        top: 3px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 11px solid transparent;
        border-right: 11px solid transparent;
        border-bottom: 26px solid rgba(0, 245, 160, 1);
    }
    
    /* Premium Center Dot with Status */
    .location-center {
        position: absolute;
        bottom: 6px;
        left: 50%;
        transform: translateX(-50%);
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ffffff 0%, #f0fff0 100%);
        border: 3px solid rgba(0, 245, 160, 1);
        box-shadow: 
            0 0 16px rgba(0, 245, 160, 0.6),
            inset 0 1px 2px rgba(255, 255, 255, 0.8);
        z-index: 4;
        transition: all 0.3s ease;
    }
    
    /* GPS Quality States */
    .location-container[data-gps-quality="excellent"] .location-accuracy {
        border-color: rgba(0, 245, 160, 0.5);
        background: radial-gradient(circle at center, 
            rgba(0, 245, 160, 0.15) 0%, 
            rgba(0, 245, 160, 0.08) 40%,
            transparent 70%);
    }
    
    .location-container[data-gps-quality="good"] .location-accuracy {
        border-color: rgba(154, 245, 0, 0.4);
        background: radial-gradient(circle at center, 
            rgba(154, 245, 0, 0.12) 0%, 
            rgba(154, 245, 0, 0.06) 40%,
            transparent 70%);
    }
    
    .location-container[data-gps-quality="fair"] .location-accuracy {
        border-color: rgba(255, 214, 10, 0.4);
        background: radial-gradient(circle at center, 
            rgba(255, 214, 10, 0.12) 0%, 
            rgba(255, 214, 10, 0.06) 40%,
            transparent 70%);
    }
    
    .location-container[data-gps-quality="poor"] .location-accuracy {
        border-color: rgba(255, 69, 0, 0.4);
        background: radial-gradient(circle at center, 
            rgba(255, 69, 0, 0.12) 0%, 
            rgba(255, 69, 0, 0.06) 40%,
            transparent 70%);
    }
    
    /* Smooth Movement States */
    .location-container[data-moving="true"] .location-center {
        animation: movingPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes movingPulse {
        0%, 100% { 
            transform: translateX(-50%) scale(1);
            box-shadow: 0 0 16px rgba(0, 245, 160, 0.6);
        }
        50% { 
            transform: translateX(-50%) scale(1.2);
            box-shadow: 0 0 24px rgba(0, 245, 160, 0.8);
        }
    }
    
    /* Drawing UI - Premium Floating */
    .drawing-ui {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + 80px);
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-lg);
        box-shadow: var(--shadow-xl);
        z-index: 200;
        display: none;
        text-align: center;
        min-width: 280px;
        border: 1px solid var(--border-color);
    }
    
    .drawing-ui.active {
        display: block;
        animation: slideInDown var(--transition-bounce) ease-out;
    }
    
    @keyframes slideInDown {
        from {
            opacity: 0;
            transform: translate(-50%, -30px);
        }
        to {
            opacity: 1;
            transform: translate(-50%, 0);
        }
    }
    
    .drawing-ui h3 {
        font-size: 18px;
        font-weight: 700;
        margin-bottom: var(--spacing-sm);
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .drawing-ui p {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        font-weight: 500;
    }
    
    .drawing-actions {
        display: flex;
        gap: var(--spacing-sm);
        justify-content: center;
    }
    
    .drawing-btn {
        padding: var(--spacing-sm) var(--spacing-lg);
        border: none;
        border-radius: var(--radius-md);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
    }
    
    .drawing-btn.primary {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    .drawing-btn.secondary {
        background: var(--bg-glass-light);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
    }
    
    .drawing-btn:active {
        transform: scale(0.95);
    }
    
    /* Refine Mode Overlay */
    .refine-overlay {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + 80px);
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-md) var(--spacing-lg);
        box-shadow: var(--shadow-xl);
        z-index: 250;
        display: none;
        text-align: center;
        border: 1px solid var(--border-color);
    }
    
    .refine-overlay.active {
        display: block;
        animation: slideInDown var(--transition-bounce) ease-out;
    }
    
    .refine-overlay span {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
        margin-right: var(--spacing-md);
    }
    
    /* Utility Info Modal - Premium Glass */
    .info-modal {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
        box-shadow: var(--shadow-xl);
        z-index: 300;
        transform: translateY(100%);
        transition: transform var(--transition-spring);
        max-height: 85vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        border: 1px solid var(--border-color);
    }
    
    .info-modal.active {
        transform: translateY(0);
    }
    
    .modal-handle {
        width: 48px;
        height: 5px;
        background: var(--text-tertiary);
        border-radius: var(--radius-full);
        margin: var(--spacing-sm) auto;
        opacity: 0.5;
    }
    
    .modal-header {
        padding: 0 var(--spacing-lg) var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .modal-title {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        font-size: 20px;
        font-weight: 700;
    }
    
    .modal-title i {
        font-size: 24px;
        filter: drop-shadow(0 0 8px currentColor);
    }
    
    .modal-close {
        width: 40px;
        height: 40px;
        border: none;
        background: var(--bg-glass-light);
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
    }
    
    .modal-close:active {
        transform: scale(0.9);
    }
    
    .modal-body {
        padding: var(--spacing-lg);
        overflow-y: auto;
        flex: 1;
    }
    
    .info-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-lg);
        margin-bottom: var(--spacing-lg);
    }
    
    .info-item {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
    }
    
    .info-label {
        font-size: 12px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .info-value {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
    }
    
    .modal-actions {
        display: flex;
        gap: var(--spacing-sm);
        padding-top: var(--spacing-lg);
        border-top: 1px solid var(--border-color);
    }
    
    .modal-btn {
        flex: 1;
        padding: var(--spacing-md);
        border: none;
        border-radius: var(--radius-md);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
    }
    
    .modal-btn.primary {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    .modal-btn.danger {
        background: var(--gradient-danger);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    .modal-btn:active {
        transform: scale(0.95);
    }
    
    /* Edit Form */
    .edit-form {
        display: none;
    }
    
    .edit-form.active {
        display: block;
    }
    
    .form-group {
        margin-bottom: var(--spacing-lg);
    }
    
    .form-label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-sm);
    }
    
    .form-input {
        width: 100%;
        padding: var(--spacing-md);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-glass-light);
        color: var(--text-primary);
        font-size: 16px;
        font-weight: 500;
        transition: all var(--transition-normal);
    }
    
    .form-input:focus {
        outline: none;
        border-color: #667eea;
        background: var(--bg-secondary);
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }
    
    .form-select {
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236c757d' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 16px center;
        padding-right: 40px;
    }
    
    /* Enhanced Semi-Transparent Excavation Mode */
    .excavation-overlay {
        position: fixed;
        inset: 0;
        background: linear-gradient(
            135deg,
            rgba(255, 0, 84, 0.15) 0%,
            rgba(139, 0, 0, 0.20) 50%,
            rgba(0, 0, 0, 0.25) 100%
        );
        backdrop-filter: blur(1px) saturate(1.2) contrast(1.1);
        -webkit-backdrop-filter: blur(1px) saturate(1.2) contrast(1.1);
        z-index: 400;
        opacity: 0;
        pointer-events: none;
        transition: all var(--transition-slow);
    }
    
    .excavation-overlay.active {
        opacity: 1;
        pointer-events: auto;
    }
    
    /* Enhanced Radar Effect - More Subtle */
    .excavation-radar {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 400px;
        height: 400px;
        pointer-events: none;
        opacity: 0.6;
    }
    
    .radar-ring {
        position: absolute;
        inset: 0;
        border: 1px solid rgba(255, 0, 84, 0.8);
        border-radius: 50%;
        opacity: 0;
        animation: radarPing 4s ease-out infinite;
        box-shadow: 
            0 0 20px rgba(255, 0, 84, 0.3),
            inset 0 0 20px rgba(255, 0, 84, 0.1);
    }
    
    .radar-ring:nth-child(2) {
        animation-delay: 1.33s;
        border-color: rgba(255, 69, 0, 0.7);
        box-shadow: 
            0 0 20px rgba(255, 69, 0, 0.3),
            inset 0 0 20px rgba(255, 69, 0, 0.1);
    }
    
    .radar-ring:nth-child(3) {
        animation-delay: 2.66s;
        border-color: rgba(255, 140, 0, 0.6);
        box-shadow: 
            0 0 20px rgba(255, 140, 0, 0.3),
            inset 0 0 20px rgba(255, 140, 0, 0.1);
    }
    
    @keyframes radarPing {
        0% {
            transform: scale(0.3);
            opacity: 0;
        }
        30% {
            opacity: 0.8;
        }
        70% {
            opacity: 0.4;
        }
        100% {
            transform: scale(2.5);
            opacity: 0;
        }
    }
    
    /* Compact Header with Glass Effect */
    .excavation-header {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + var(--spacing-md));
        left: var(--spacing-md);
        right: var(--spacing-md);
        padding: var(--spacing-md) var(--spacing-lg);
        background: rgba(255, 0, 84, 0.1);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-xl);
        border: 1px solid rgba(255, 0, 84, 0.3);
        box-shadow: 
            0 8px 32px rgba(255, 0, 84, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        color: white;
        text-align: center;
        z-index: 401;
        animation: excavationHeaderPulse 3s ease-in-out infinite;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .excavation-info {
        flex: 1;
        text-align: center;
    }
    
    .excavation-toggle {
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: var(--radius-full);
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all var(--transition-normal);
        font-size: 16px;
        flex-shrink: 0;
    }
    
    .excavation-toggle:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: scale(1.05);
    }
    
    .excavation-toggle:active {
        transform: scale(0.95);
    }
    
    .excavation-toggle.alerts-hidden {
        background: rgba(255, 69, 0, 0.3);
        border-color: rgba(255, 69, 0, 0.5);
    }
    
    .excavation-toggle.alerts-hidden:hover {
        background: rgba(255, 69, 0, 0.4);
    }
    
    @keyframes excavationHeaderPulse {
        0%, 100% {
            box-shadow: 
                0 8px 32px rgba(255, 0, 84, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        50% {
            box-shadow: 
                0 12px 48px rgba(255, 0, 84, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
    }
    
    .excavation-header h2 {
        font-size: 18px;
        font-weight: 800;
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 1px;
        text-shadow: 0 0 15px rgba(255, 0, 84, 0.8);
        background: linear-gradient(135deg, #ffffff 0%, #ff0054 50%, #ffffff 100%);
        background-size: 200% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: headerShimmer 3s ease-in-out infinite;
    }
    
    @keyframes headerShimmer {
        0%, 100% { background-position: 200% center; }
        50% { background-position: 0% center; }
    }
    
    .excavation-header p {
        font-size: 12px;
        opacity: 0.9;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.8);
    }
    
    /* Enhanced Utility Visibility During Excavation */
    .utility-line.excavation-enhanced {
        filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 3px 16px rgba(0, 0, 0, 0.8)) !important;
        animation: excavationUtilityPulse 2.5s ease-in-out infinite;
    }
    
    .excavation-overlay.active ~ .app-container .structure-marker {
        filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.6));
        transform: scale(1.2);
        animation: excavationStructurePulse 1.5s ease-in-out infinite;
    }
    
    @keyframes excavationUtilityPulse {
        0%, 100% {
            filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 3px 16px rgba(0, 0, 0, 0.8));
        }
        50% {
            filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 5px 24px rgba(0, 0, 0, 0.9));
        }
    }
    
    @keyframes excavationStructurePulse {
        0%, 100% {
            filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.6));
            transform: scale(1.2);
        }
        50% {
            filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 6px 24px rgba(0, 0, 0, 0.8));
            transform: scale(1.3);
        }
    }
    
    /* Premium Grid-Based Proximity Alerts for Excavation Mode */
    .proximity-alerts {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + 100px);
        left: var(--spacing-md);
        right: var(--spacing-md);
        bottom: calc(env(safe-area-inset-bottom, 0) + 120px);
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: var(--spacing-sm);
        z-index: 402;
        overflow-y: auto;
        pointer-events: none;
        transition: all var(--transition-normal);
        padding: var(--spacing-sm);
    }
    
    .proximity-alerts.hidden {
        opacity: 0;
        transform: translateY(-20px);
        pointer-events: none;
    }
    
    .proximity-alerts > * {
        pointer-events: auto;
    }
    
    .proximity-alert {
        background: rgba(255, 255, 255, 1.0);
        border-radius: var(--radius-lg);
        box-shadow: 
            0 8px 32px rgba(0, 0, 0, 0.2),
            0 4px 16px rgba(0, 0, 0, 0.1),
            0 2px 8px rgba(0, 0, 0, 0.05);
        overflow: hidden;
        animation: alertSlideIn var(--transition-bounce) ease-out;
        position: relative;
        border: 2px solid transparent;
        transform-origin: top center;
        transition: all var(--transition-normal);
        min-height: 140px;
        max-height: 180px;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
    }
    
    .proximity-alert.water { 
        border-color: var(--water-color);
    }
    .proximity-alert.gas { 
        border-color: var(--gas-color);
    }
    .proximity-alert.electric { 
        border-color: var(--electric-color);
    }
    .proximity-alert.sewer { 
        border-color: var(--sewer-color);
    }
    .proximity-alert.telecom { 
        border-color: var(--telecom-color);
    }
    
    @keyframes alertSlideIn {
        from {
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }
    
    .alert-content {
        padding: var(--spacing-md);
        position: relative;
        height: 100%;
        display: flex;
        flex-direction: column;
    }
    
    .alert-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--spacing-sm);
    }
    
    .alert-icon-container {
        width: 36px;
        height: 36px;
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }
    
    .alert-icon-container.water { 
        background: rgba(0, 180, 216, 0.1);
        color: var(--water-color);
    }
    .alert-icon-container.gas { 
        background: rgba(255, 214, 10, 0.1);
        color: var(--gas-color);
    }
    .alert-icon-container.electric { 
        background: rgba(255, 0, 110, 0.1);
        color: var(--electric-color);
    }
    .alert-icon-container.sewer { 
        background: rgba(168, 118, 62, 0.1);
        color: var(--sewer-color);
    }
    .alert-icon-container.telecom { 
        background: rgba(181, 101, 216, 0.1);
        color: var(--telecom-color);
    }
    
    .alert-icon-container i {
        font-size: 18px;
    }
    
    .alert-close {
        width: 24px;
        height: 24px;
        border: none;
        background: rgba(0, 0, 0, 0.05);
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
        color: #666;
        font-size: 12px;
    }
    
    .alert-close:hover {
        background: rgba(0, 0, 0, 0.1);
        color: #333;
        transform: scale(1.1);
    }
    
    .alert-close:active {
        transform: scale(0.9);
    }
    
    .alert-utility-info {
        text-align: center;
        margin-bottom: var(--spacing-sm);
    }
    
    .alert-utility-type {
        font-size: 16px;
        font-weight: 800;
        color: #1a1a1a;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin: 0 0 2px 0;
        line-height: 1;
    }
    
    .alert-line-type {
        font-size: 11px;
        color: #666;
        font-weight: 600;
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .alert-distance-banner {
        text-align: center;
        margin-bottom: var(--spacing-sm);
        padding: var(--spacing-sm);
        border-radius: var(--radius-md);
        background: rgba(0, 0, 0, 0.03);
    }
    
    .distance-value {
        display: block;
        font-size: 20px;
        font-weight: 900;
        line-height: 1;
        color: #d32f2f;
        margin-bottom: 2px;
    }
    
    .distance-unit {
        font-size: 10px;
        font-weight: 700;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #666;
    }
    
    .alert-details {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
    }
    
    .detail-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 0;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }
    
    .detail-item:last-child {
        border-bottom: none;
    }
    
    .detail-label {
        font-size: 10px;
        font-weight: 600;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .detail-value {
        font-size: 11px;
        font-weight: 700;
        color: #1a1a1a;
        text-align: right;
    }
    
    /* Exit Excavation Button */
    .exit-excavation {
        position: absolute;
        bottom: calc(env(safe-area-inset-bottom, 0) + var(--spacing-xl));
        left: 50%;
        transform: translateX(-50%);
        padding: var(--spacing-md) var(--spacing-xl);
        background: white;
        color: var(--danger-color);
        border: none;
        border-radius: var(--radius-full);
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: var(--shadow-xl);
        transition: all var(--transition-spring);
        z-index: 403;
    }
    
    .exit-excavation:active {
        transform: translateX(-50%) scale(0.95);
    }
    
    /* Settings Panel - Premium Slide */
    .settings-panel {
        position: fixed;
        top: 0;
        right: -100%;
        bottom: 0;
        width: 85%;
        max-width: 380px;
        background: var(--bg-primary);
        box-shadow: -8px 0 32px var(--shadow-xl);
        z-index: 500;
        transition: right var(--transition-spring);
        overflow-y: auto;
        padding-top: env(safe-area-inset-top, 0);
    }
    
    .settings-panel.active {
        right: 0;
    }
    
    .settings-header {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .settings-header h2 {
        font-size: 24px;
        font-weight: 800;
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .settings-section {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
    }
    
    .settings-section h3 {
        font-size: 12px;
        font-weight: 700;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    /* Premium Toggle Switch */
    .toggle-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--spacing-md);
    }
    
    .toggle-label {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        font-size: 14px;
        font-weight: 600;
    }
    
    .toggle-switch {
        position: relative;
        width: 56px;
        height: 32px;
        border: none;
        background: var(--bg-tertiary);
        border-radius: var(--radius-full);
        cursor: pointer;
        transition: all var(--transition-normal);
    }
    
    .toggle-switch.active {
        background: var(--gradient-success);
    }
    
    .toggle-switch::after {
        content: '';
        position: absolute;
        top: 4px;
        left: 4px;
        width: 24px;
        height: 24px;
        background: white;
        border-radius: var(--radius-full);
        transition: all var(--transition-spring);
        box-shadow: var(--shadow-sm);
    }
    
    .toggle-switch.active::after {
        transform: translateX(24px);
    }
    
    /* Map Style Selector */
    .map-styles {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-sm);
    }
    
    .map-style-btn {
        padding: var(--spacing-md);
        border: 2px solid var(--border-color);
        background: var(--bg-secondary);
        border-radius: var(--radius-md);
        cursor: pointer;
        transition: all var(--transition-normal);
        text-align: center;
        font-size: 14px;
        font-weight: 600;
    }
    
    .map-style-btn.active {
        border-color: transparent;
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    /* Utility Line Styles */
    .utility-line {
        stroke-width: 6;
        stroke-linecap: round;
        stroke-linejoin: round;
        fill: none;
        cursor: pointer;
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
        transition: all var(--transition-normal), opacity 0.3s ease-in-out;
        touch-action: manipulation;
        -webkit-touch-callout: default;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    
    .utility-line:hover {
        filter: drop-shadow(0 4px 16px rgba(0, 0, 0, 0.4)) drop-shadow(0 0 12px currentColor);
        stroke-width: 8 !important;
    }
    
    .utility-line.main {
        stroke-width: 8;
        filter: drop-shadow(0 3px 12px rgba(0, 0, 0, 0.4));
    }
    
    .utility-line.main:hover {
        stroke-width: 10 !important;
    }
    
    .utility-line.service {
        stroke-width: 6;
        stroke-dasharray: 15, 5;
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
    }
    
    .utility-line.water { 
        stroke: var(--water-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(0, 180, 216, 0.3));
    }
    .utility-line.gas { 
        stroke: var(--gas-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(255, 214, 10, 0.3));
    }
    .utility-line.electric { 
        stroke: var(--electric-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(255, 0, 110, 0.3));
    }
    .utility-line.sewer { 
        stroke: var(--sewer-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(168, 118, 62, 0.3));
    }
    .utility-line.telecom { 
        stroke: var(--telecom-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(181, 101, 216, 0.3));
    }
    
    .utility-line.drawing {
        opacity: 0.7;
        animation: drawingPulse 1.5s ease-in-out infinite;
    }
    
    .utility-line.highlighted {
        filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.5));
        stroke-width: 12 !important;
        opacity: 1 !important;
        animation: highlightGlow 2s ease-in-out infinite;
    }
    
    @keyframes drawingPulse {
        0%, 100% { 
            opacity: 0.5; 
            stroke-width: 6;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
        }
        50% { 
            opacity: 1; 
            stroke-width: 8;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.4)) drop-shadow(0 0 12px currentColor);
        }
    }
    
    @keyframes highlightGlow {
        0%, 100% { 
            filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.5));
        }
        50% { 
            filter: drop-shadow(0 0 30px currentColor) drop-shadow(0 6px 20px rgba(0, 0, 0, 0.6));
        }
    }
    
    /* Connection Markers */
    .connection-marker {
        fill: white;
        stroke-width: 3;
        cursor: pointer;
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.4));
        transition: opacity 0.3s ease-in-out;
    }
    
    .connection-marker.t-junction {
        r: 10;
    }
    
    .connection-marker.endpoint {
        r: 8;
    }
    
    .connection-marker.structure {
        r: 12;
    }
    
    .connection-marker.water { stroke: var(--water-color); }
    .connection-marker.gas { stroke: var(--gas-color); }
    .connection-marker.electric { stroke: var(--electric-color); }
    .connection-marker.sewer { stroke: var(--sewer-color); }
    .connection-marker.telecom { stroke: var(--telecom-color); }
    
    /* Refine Points - Enhanced for Leaflet CircleMarkers */
    .leaflet-interactive {
        cursor: pointer;
    }
    
    .leaflet-interactive[style*="cursor: move"] {
        cursor: move !important;
    }
    
    /* Ensure refine markers are always visible and interactive */
    .leaflet-zoom-animated .leaflet-interactive {
        pointer-events: auto !important;
    }
    
    /* Legacy CSS for any SVG-based refine points */
    /* Premium Refine Mode Styles - Completely Redesigned */
    .refine-marker {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
    }
    
    .refine-point {
        width: 40px;
        height: 40px;
        background: linear-gradient(135deg, #ffffff 0%, #f0f8ff 100%);
        border: 4px solid #667eea;
        border-radius: 50%;
        cursor: move !important;
        box-shadow: 
            0 8px 32px rgba(102, 126, 234, 0.4), 
            0 0 0 2px rgba(255, 255, 255, 0.9),
            inset 0 2px 4px rgba(255, 255, 255, 0.5);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        z-index: 10000 !important;
        display: flex !important;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: #667eea;
        font-size: 16px;
        pointer-events: auto !important;
        user-select: none;
        animation: refinePointPulse 3s ease-in-out infinite;
    }
    
    .refine-point:before {
        content: '';
        position: absolute;
        inset: -6px;
        border-radius: 50%;
        background: conic-gradient(from 0deg, transparent, rgba(102, 126, 234, 0.3), transparent);
        animation: refinePointSpin 4s linear infinite;
        z-index: -1;
    }
    
    .refine-point.dragging {
        transform: scale(1.3) !important;
        border-color: #00f5a0;
        background: linear-gradient(135deg, #f0fff0 0%, #e6ffe6 100%);
        color: #00f5a0;
        box-shadow: 
            0 12px 48px rgba(0, 245, 160, 0.6), 
            0 0 0 3px rgba(255, 255, 255, 1),
            inset 0 2px 4px rgba(255, 255, 255, 0.7);
    }
    
    .refine-point.intermediate {
        animation: intermediateGlow 2s ease-in-out infinite;
        opacity: 0.8;
        border-width: 3px;
    }
    
    .refine-point.intermediate:hover {
        transform: scale(1.2) !important;
        opacity: 1;
        box-shadow: 
            0 6px 24px rgba(77, 148, 255, 0.6), 
            0 0 0 2px rgba(255, 255, 255, 1),
            inset 0 2px 4px rgba(255, 255, 255, 0.6);
    }
    
    @keyframes intermediateGlow {
        0%, 100% {
            box-shadow: 
                0 4px 16px rgba(77, 148, 255, 0.3), 
                0 0 0 1px rgba(255, 255, 255, 0.8),
                inset 0 2px 4px rgba(255, 255, 255, 0.4);
        }
        50% {
            box-shadow: 
                0 6px 20px rgba(77, 148, 255, 0.5), 
                0 0 0 2px rgba(255, 255, 255, 0.9),
                inset 0 2px 4px rgba(255, 255, 255, 0.5);
        }
    }
    
    @keyframes refinePointPulse {
        0%, 100% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.05);
            opacity: 0.95;
        }
    }
    
    @keyframes refinePointSpin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    /* Connection Dialog - Premium */
    .connection-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.9);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-xl);
        box-shadow: var(--shadow-xl);
        z-index: 600;
        min-width: 320px;
        opacity: 0;
        pointer-events: none;
        transition: all var(--transition-spring);
        border: 1px solid var(--border-color);
    }
    
    .connection-dialog.active {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        pointer-events: auto;
    }
    
    .connection-dialog h3 {
        font-size: 20px;
        font-weight: 700;
        margin-bottom: var(--spacing-md);
        text-align: center;
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .connection-dialog p {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        text-align: center;
        line-height: 1.5;
    }
    
    .connection-actions {
        display: flex;
        gap: var(--spacing-sm);
        justify-content: center;
    }
    
    /* Structure Markers - Premium Icons */
    .structure-marker {
        width: 48px;
        height: 48px;
        background: var(--bg-glass);
        backdrop-filter: blur(20px);
        border: 3px solid;
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        box-shadow: var(--shadow-lg);
        cursor: pointer;
        transition: all var(--transition-spring), opacity 0.3s ease-in-out;
    }
    
    .structure-marker.water { 
        border-color: var(--water-color); 
        color: var(--water-color); 
    }
    .structure-marker.gas { 
        border-color: var(--gas-color); 
        color: var(--gas-color); 
    }
    .structure-marker.electric { 
        border-color: var(--electric-color); 
        color: var(--electric-color); 
    }
    .structure-marker.sewer { 
        border-color: var(--sewer-color); 
        color: var(--sewer-color); 
    }
    .structure-marker.telecom { 
        border-color: var(--telecom-color); 
        color: var(--telecom-color); 
    }
    
    .structure-marker:hover {
        transform: scale(1.1);
        box-shadow: var(--shadow-xl), 0 0 20px currentColor;
    }
    
    /* Structure Container */
    .structure-container {
        position: absolute;
        right: var(--spacing-md);
        bottom: calc(env(safe-area-inset-bottom, 0) + 160px);
        z-index: 95;
    }
    
    /* Add Structure Button - Compact Premium Design */
    .add-structure-btn {
        position: relative;
        width: 48px;
        height: 48px;
        background: var(--gradient-success);
        border: none;
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--shadow-lg), 0 0 20px rgba(0, 245, 160, 0.4);
        cursor: pointer;
        transition: all var(--transition-spring);
    }
    
    .add-structure-btn:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: var(--shadow-xl), 0 0 25px rgba(0, 245, 160, 0.5);
    }
    
    .add-structure-btn:active {
        transform: scale(0.9);
    }
    
    .add-structure-btn i {
        font-size: 20px;
        color: white;
    }
    
    .add-structure-btn.active {
        background: var(--gradient-warning);
        animation: structurePlacementPulse 2s ease-in-out infinite;
    }
    
    @keyframes structurePlacementPulse {
        0%, 100% { 
            box-shadow: var(--shadow-lg), 0 0 20px rgba(255, 214, 10, 0.4);
        }
        50% { 
            box-shadow: var(--shadow-xl), 0 0 30px rgba(255, 214, 10, 0.7);
        }
    }
    
    /* Structure Menu - Compact Premium Grid */
    .structure-menu {
        position: absolute;
        bottom: 60px;
        right: 0;
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-xl);
        padding: var(--spacing-md);
        display: none;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-sm);
        width: 280px;
        border: 1px solid var(--border-color);
        z-index: 1000;
        max-height: 350px;
        overflow-y: auto;
    }
    
    .structure-menu.active {
        display: grid !important;
        animation: menuPopIn var(--transition-bounce) ease-out;
    }
    
    @keyframes menuPopIn {
        from {
            opacity: 0;
            transform: scale(0.8) translateY(20px);
        }
        to {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
    }
    
    .structure-type-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-xs);
        padding: var(--spacing-sm);
        background: var(--bg-glass-light);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        cursor: pointer;
        transition: all var(--transition-normal);
        min-height: 60px;
    }
    
    .structure-type-btn:hover {
        background: var(--bg-tertiary);
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
    }
    
    .structure-type-btn:active {
        transform: scale(0.95);
    }
    
    .structure-type-btn i {
        font-size: 22px;
    }
    
    .structure-type-btn span {
        font-size: 10px;
        font-weight: 600;
        text-align: center;
        line-height: 1.2;
    }
    
    /* Toast Notifications - Premium */
    .toast-container {
        position: fixed;
        top: calc(env(safe-area-inset-top, 0) + var(--spacing-md));
        left: var(--spacing-md);
        right: var(--spacing-md);
        z-index: 1000;
        pointer-events: none;
    }
    
    .toast {
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-md);
        padding: var(--spacing-md) var(--spacing-lg);
        box-shadow: var(--shadow-xl);
        margin-bottom: var(--spacing-sm);
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
        opacity: 0;
        transform: translateY(-20px) scale(0.9);
        transition: all var(--transition-spring);
        pointer-events: auto;
        border: 1px solid var(--border-color);
    }
    
    .toast.show {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    
    .toast i {
        font-size: 24px;
        filter: drop-shadow(0 0 8px currentColor);
    }
    
    .toast span {
        font-weight: 600;
        font-size: 14px;
    }
    
    .toast.success i { color: var(--success-color); }
    .toast.error i { color: var(--danger-color); }
    .toast.warning i { color: var(--warning-color); }
    .toast.info i { color: var(--info-color); }
    
    /* Measurement Display */
    .measurement-display {
        position: absolute;
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-md);
        padding: var(--spacing-sm) var(--spacing-md);
        box-shadow: var(--shadow-lg);
        font-size: 14px;
        font-weight: 700;
        pointer-events: none;
        z-index: 200;
        border: 1px solid var(--border-color);
        color: var(--text-primary);
    }
    
    /* Notes Section */
    .notes-section {
        margin-top: var(--spacing-lg);
        padding-top: var(--spacing-lg);
        border-top: 1px solid var(--border-color);
    }
    
    .notes-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--spacing-md);
    }
    
    .notes-title {
        font-size: 16px;
        font-weight: 600;
    }
    
    .add-note-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        background: var(--bg-glass-light);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
        transition: all var(--transition-normal);
    }
    
    .add-note-btn:active {
        transform: scale(0.95);
    }
    
    .notes-list {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
    }
    
    .note-item {
        background: var(--bg-glass-light);
        padding: var(--spacing-md);
        border-radius: var(--radius-md);
        position: relative;
        border: 1px solid var(--border-color);
    }
    
    .note-text {
        font-size: 14px;
        line-height: 1.5;
        margin-bottom: var(--spacing-xs);
    }
    
    .note-date {
        font-size: 12px;
        color: var(--text-tertiary);
    }
    
    .note-delete {
        position: absolute;
        top: var(--spacing-sm);
        right: var(--spacing-sm);
        width: 24px;
        height: 24px;
        background: transparent;
        border: none;
        cursor: pointer;
        color: var(--text-tertiary);
        transition: all var(--transition-normal);
    }
    
    .note-delete:hover {
        color: var(--danger-color);
    }
    
    /* Cloud Sync Status */
    .sync-status {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0) + var(--spacing-md));
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-full);
        padding: var(--spacing-sm) var(--spacing-lg);
        box-shadow: var(--shadow-md);
        font-size: 12px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        opacity: 0;
        pointer-events: none;
        transition: all var(--transition-normal);
        border: 1px solid var(--border-color);
    }
    
    .sync-status.show {
        opacity: 1;
    }
    
    .sync-status i {
        font-size: 14px;
        color: var(--info-color);
        animation: syncSpin 2s linear infinite;
    }
    
    @keyframes syncSpin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    /* Note Input Modal */
    .note-input-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 650;
        opacity: 0;
        pointer-events: none;
        transition: opacity var(--transition-normal);
        padding: var(--spacing-lg);
    }
    
    .note-input-modal.active {
        opacity: 1;
        pointer-events: auto;
    }
    
    .note-input-content {
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-xl);
        box-shadow: var(--shadow-xl);
        width: 100%;
        max-width: 400px;
        border: 1px solid var(--border-color);
    }
    
    .note-input-header {
        font-size: 18px;
        font-weight: 700;
        margin-bottom: var(--spacing-lg);
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .note-textarea {
        width: 100%;
        min-height: 120px;
        padding: var(--spacing-md);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-glass-light);
        color: var(--text-primary);
        font-size: 14px;
        font-family: inherit;
        resize: vertical;
        transition: all var(--transition-normal);
    }
    
    .note-textarea:focus {
        outline: none;
        border-color: #667eea;
        background: var(--bg-secondary);
    }
    
    .note-input-actions {
        display: flex;
        gap: var(--spacing-sm);
        margin-top: var(--spacing-lg);
    }
    
    /* Responsive adjustments */
    @media (min-width: 768px) {
        .bottom-controls {
            max-width: 640px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .proximity-alerts {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        }
        
        .structure-menu {
            width: 360px;
        }
    }
    
    @media (min-width: 1024px) {
        .proximity-alerts {
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
    }
    
    @media (max-width: 480px) {
        .proximity-alerts {
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
        
        .proximity-alert {
            min-height: 120px;
            max-height: 160px;
        }
        
        .alert-content {
            padding: 10px;
        }
        
        .alert-utility-type {
            font-size: 14px;
        }
        
        .distance-value {
            font-size: 18px;
        }
    }
    
    /* Prevent selection and zoom */
    * {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }
    
    input, textarea {
        -webkit-user-select: text;
        -khtml-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
    }
    
    /* Enhanced touch interactions */
    button, .control-btn, .utility-btn {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    }
    
    /* Focus management for accessibility */
    button:focus-visible,
    .control-btn:focus-visible,
    .utility-btn:focus-visible {
        outline: 3px solid var(--info-color);
        outline-offset: 2px;
    }
    
    .form-input:focus-visible {
        outline: 3px solid var(--info-color);
        outline-offset: 2px;
    }
    
    /* Improve accessibility */
    @media (prefers-reduced-motion: reduce) {
        *, *::before, *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }
    
    /* High contrast mode support */
    @media (prefers-contrast: high) {
        :root {
            --border-color: rgba(255, 255, 255, 0.3);
            --text-secondary: #cccccc;
        }
    }
    
    /* Premium glassmorphism enhancement */
    @supports (backdrop-filter: blur(20px)) {
        .utility-selector,
        .control-btn,
        .info-modal,
        .settings-panel,
        .drawing-ui,
        .refine-overlay {
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
        }
    }

    /* ========== LOGIN & ADMIN SYSTEM STYLES ========== */
    
    /* Login Screen */
    .login-screen {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #0a0a0f 0%, #1a1a25 50%, #0f0c1a 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 30000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease;
    }

    .login-screen.active {
        opacity: 1;
        pointer-events: auto;
    }

    .login-container {
        width: 90%;
        max-width: 400px;
        padding: var(--spacing-2xl);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-xl);
        text-align: center;
        border: 1px solid var(--border-color);
    }

    .login-logo {
        width: 80px;
        height: 80px;
        background: var(--gradient-primary);
        border-radius: var(--radius-xl);
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto var(--spacing-lg);
        box-shadow: var(--shadow-lg);
    }

    .login-logo i {
        font-size: 32px;
        color: white;
    }

    .login-title {
        font-family: 'Space Grotesk', sans-serif;
        font-size: 28px;
        font-weight: 900;
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: var(--spacing-sm);
    }

    .login-subtitle {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-2xl);
        font-weight: 500;
    }

    .login-form {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-lg);
    }

    .login-input {
        padding: var(--spacing-md) var(--spacing-lg);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-glass-light);
        color: var(--text-primary);
        font-size: 16px;
        font-weight: 500;
        transition: all var(--transition-normal);
    }

    .login-input:focus {
        outline: none;
        border-color: #667eea;
        background: var(--bg-secondary);
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }

    .login-btn {
        padding: var(--spacing-md) var(--spacing-lg);
        border: none;
        border-radius: var(--radius-md);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
    }

    .login-btn.primary {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }

    .login-btn.secondary {
        background: var(--bg-glass-light);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
    }

    .login-btn.google {
        background: #4285f4;
        color: white;
        box-shadow: var(--shadow-md);
    }

    .login-btn:active {
        transform: scale(0.95);
    }

    .login-divider {
        display: flex;
        align-items: center;
        text-align: center;
        color: var(--text-tertiary);
        font-size: 12px;
        font-weight: 600;
        margin: var(--spacing-md) 0;
    }

    .login-divider::before,
    .login-divider::after {
        content: '';
        flex: 1;
        height: 1px;
        background: var(--border-color);
    }

    .login-divider::before {
        margin-right: var(--spacing-md);
    }

    .login-divider::after {
        margin-left: var(--spacing-md);
    }

    .login-error {
        color: var(--danger-color);
        font-size: 14px;
        font-weight: 500;
        margin-top: var(--spacing-md);
        padding: var(--spacing-sm);
        background: rgba(255, 0, 84, 0.1);
        border-radius: var(--radius-sm);
        border: 1px solid rgba(255, 0, 84, 0.2);
        display: none;
    }

    .login-error.show {
        display: block;
    }

    .login-info {
        margin-top: var(--spacing-lg);
        font-size: 12px;
        color: var(--text-tertiary);
        padding: var(--spacing-sm);
        background: var(--bg-glass-light);
        border-radius: var(--radius-sm);
        border: 1px solid var(--border-color);
    }

    /* Admin Button */
    .admin-btn {
        position: fixed;
        top: calc(env(safe-area-inset-top, 0) + var(--spacing-md));
        right: calc(var(--spacing-md) + 60px);
        width: 48px;
        height: 48px;
        background: var(--gradient-success);
        border: none;
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--shadow-lg), 0 0 20px rgba(0, 245, 160, 0.4);
        cursor: pointer;
        z-index: 999;
        transition: all var(--transition-spring);
    }

    .admin-btn:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: var(--shadow-xl), 0 0 30px rgba(0, 245, 160, 0.6);
    }

    .admin-btn i {
        font-size: 20px;
        color: white;
    }

    /* Role Badge */
    .role-badge {
        position: fixed;
        top: calc(env(safe-area-inset-top, 0) + var(--spacing-md));
        right: var(--spacing-md);
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        padding: var(--spacing-sm) var(--spacing-md);
        border-radius: var(--radius-full);
        font-size: 12px;
        font-weight: 600;
        z-index: 1000;
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
        box-shadow: var(--shadow-md);
        transition: all var(--transition-normal);
    }

    .role-badge.admin {
        border: 2px solid var(--success-color);
        color: var(--success-color);
        background: rgba(0, 245, 160, 0.1);
    }

    .role-badge.user {
        border: 2px solid var(--info-color);
        color: var(--info-color);
        background: rgba(0, 180, 216, 0.1);
    }

    .role-badge.pending {
        border: 2px solid var(--warning-color);
        color: var(--warning-color);
        background: rgba(255, 214, 10, 0.1);
    }

    /* Admin Panel */
    .admin-panel {
        position: fixed;
        top: 0;
        right: -100%;
        bottom: 0;
        width: 90%;
        max-width: 500px;
        background: var(--bg-primary);
        box-shadow: -8px 0 32px rgba(0, 0, 0, 0.4);
        z-index: 700;
        transition: right var(--transition-spring);
        overflow-y: auto;
        padding-top: env(safe-area-inset-top, 0);
        border-left: 1px solid var(--border-color);
    }

    .admin-panel.active {
        right: 0;
    }

    .admin-header {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
    }

    .admin-header h2 {
        font-size: 24px;
        font-weight: 800;
        background: var(--gradient-success);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    .admin-close {
        width: 40px;
        height: 40px;
        border: none;
        background: var(--bg-glass-light);
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
        color: var(--text-primary);
    }

    .admin-close:hover {
        background: var(--bg-tertiary);
        transform: scale(1.1);
    }

    .admin-section {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
    }

    .admin-section h3 {
        font-size: 14px;
        font-weight: 700;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    /* Pending Changes */
    .pending-list {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
    }

    .pending-item {
        background: var(--bg-glass-light);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        padding: var(--spacing-lg);
        transition: all var(--transition-normal);
        position: relative;
        overflow: hidden;
    }

    .pending-item::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: var(--gradient-primary);
        opacity: 0.7;
    }

    .pending-item:hover {
        background: var(--bg-tertiary);
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
    }

    .pending-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: var(--spacing-sm);
        gap: var(--spacing-md);
    }

    .pending-type {
        font-weight: 700;
        color: var(--text-primary);
        font-size: 16px;
        line-height: 1.2;
    }

    .pending-user {
        font-size: 12px;
        color: var(--text-secondary);
        background: var(--bg-glass);
        padding: 4px 8px;
        border-radius: var(--radius-sm);
        white-space: nowrap;
    }

    .pending-details {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        line-height: 1.4;
    }

    .pending-timestamp {
        font-size: 11px;
        color: var(--text-tertiary);
        margin-bottom: var(--spacing-sm);
        font-style: italic;
    }

    .pending-actions {
        display: flex;
        gap: var(--spacing-sm);
    }

    .approve-btn, .reject-btn {
        flex: 1;
        padding: var(--spacing-sm) var(--spacing-md);
        border: none;
        border-radius: var(--radius-md);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-xs);
    }

    .approve-btn {
        background: var(--gradient-success);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .approve-btn:hover {
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
    }

    .reject-btn {
        background: var(--gradient-danger);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .reject-btn:hover {
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
    }

    /* User Management */
    .users-list {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
    }

    .user-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--spacing-md);
        background: var(--bg-glass-light);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        transition: all var(--transition-normal);
    }

    .user-item:hover {
        background: var(--bg-tertiary);
    }

    .user-info {
        flex: 1;
    }

    .user-email {
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 2px;
    }

    .user-role {
        font-size: 12px;
        font-weight: 600;
        padding: 4px 8px;
        border-radius: var(--radius-sm);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .user-role.admin {
        background: rgba(0, 245, 160, 0.2);
        color: var(--success-color);
    }

    .user-role.user {
        background: rgba(0, 180, 216, 0.2);
        color: var(--info-color);
    }

    .user-role.pending {
        background: rgba(255, 214, 10, 0.2);
        color: var(--warning-color);
    }

    .approve-user-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        background: var(--gradient-success);
        color: white;
        border: none;
        border-radius: var(--radius-sm);
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
    }

    .approve-user-btn:hover {
        transform: scale(1.05);
    }

    /* Pending utility lines on map */
    .utility-line.pending {
        opacity: 0.6 !important;
        stroke-dasharray: 10, 5 !important;
        filter: drop-shadow(0 0 8px rgba(255, 214, 10, 0.5)) !important;
    }

    .structure-marker.pending {
        opacity: 0.6 !important;
        border-style: dashed !important;
        filter: drop-shadow(0 0 8px rgba(255, 214, 10, 0.5)) !important;
    }

    /* Sign out button in settings */
    .signout-btn {
        width: 100%;
        padding: var(--spacing-md);
        background: var(--gradient-danger);
        color: white;
        border: none;
        border-radius: var(--radius-md);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        margin-top: var(--spacing-lg);
        transition: all var(--transition-normal);
    }

    .signout-btn:active {
        transform: scale(0.95);
    }
</style>

</head>
<body>
    <!-- ========== TRIPLE AAA QUALITY SPLASH SCREEN ========== -->
    <div class="splash-screen" id="splash">
        <!-- Dynamic Geometric Background -->
        <div class="splash-background">
            <div class="geometric-layer">
                <div class="geo-shape"></div>
                <div class="geo-shape"></div>
                <div class="geo-shape"></div>
                <div class="geo-shape"></div>
            </div>
        </div>
        
        <!-- Advanced Neural Particle System -->
        <div class="splash-particles">
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
        </div>
        
        <!-- Ultra Modern Logo System -->
        <div class="splash-logo-container">
            <div class="logo-hexagon">
                <div class="hex-core"></div>
                <div class="hex-inner">
                    <div class="hex-grid">
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                    </div>
                </div>
            </div>
            
            <!-- Premium Typography -->
            <h1 class="splash-title">CAC UTILI-TRACK</h1>
            <p class="splash-subtitle">Advanced Utility Mapping</p>
        </div>
        
        <!-- Advanced Loading System -->
        <div class="splash-loading">
            <div class="loading-bar-container">
                <div class="loading-bar" id="loadingBar"></div>
            </div>
            <div class="loading-text" id="loadingText">Initializing Systems</div>
            <div class="loading-percentage" id="loadingPercentage">0%</div>
        </div>
    </div>

<!-- Login Screen -->
<div class="login-screen" id="loginScreen">
    <div class="login-container">
        <div class="login-logo">
            <i class="fas fa-map-marked-alt"></i>
        </div>
        <h1 class="login-title">CAC UTILI-TRACK</h1>
        <p class="login-subtitle">Shared Utility Mapping System</p>
        
        <div class="login-form">
            <input type="email" id="loginEmail" placeholder="Email address" class="login-input" required>
            <input type="password" id="loginPassword" placeholder="Password" class="login-input" required>
            
            <button class="login-btn primary" id="loginBtn">
                <i class="fas fa-sign-in-alt"></i>
                Sign In
            </button>
            <button class="login-btn secondary" id="signupBtn">
                <i class="fas fa-user-plus"></i>
                Request Access
            </button>
            
            <div class="login-divider">OR</div>
            
            <button class="login-btn google" id="googleBtn">
                <i class="fab fa-google"></i>
                Sign in with Google
            </button>
        </div>
        
        <div class="login-error" id="loginError"></div>
        <div class="login-info">
            <p><i class="fas fa-info-circle"></i> New users require admin approval</p>
        </div>
    </div>
</div>

<!-- Admin Panel -->
<div class="admin-panel" id="adminPanel">
    <div class="admin-header">
        <h2><i class="fas fa-user-shield"></i> Admin Panel</h2>
        <button class="admin-close" onclick="closeAdminPanel()">
            <i class="fas fa-times"></i>
        </button>
    </div>
    
    <div class="admin-section">
        <h3><i class="fas fa-clock"></i> Pending Changes</h3>
        <div id="pendingChangesList" class="pending-list">
            <p style="color: var(--text-tertiary); text-align: center;">Loading...</p>
        </div>
    </div>
    
    <div class="admin-section">
        <h3><i class="fas fa-users"></i> User Management</h3>
        <div id="usersList" class="users-list">
            <p style="color: var(--text-tertiary); text-align: center;">Loading...</p>
        </div>
        </div>
    </div>

<!-- Main App Container -->
<div class="app-container">
    <!-- Map -->
    <div id="map"></div>

    <!-- Top Bar -->
    <div class="top-bar">
        <div class="utility-selector" role="toolbar" aria-label="Utility type selector">
            <button class="utility-btn water active" data-utility="water" aria-label="Select water utilities" aria-pressed="true">
                <i class="fas fa-tint" aria-hidden="true"></i>
            </button>
            <button class="utility-btn gas" data-utility="gas" aria-label="Select gas utilities" aria-pressed="false">
                <i class="fas fa-fire" aria-hidden="true"></i>
            </button>
            <button class="utility-btn electric" data-utility="electric" aria-label="Select electric utilities" aria-pressed="false">
                <i class="fas fa-bolt" aria-hidden="true"></i>
            </button>
            <button class="utility-btn sewer" data-utility="sewer" aria-label="Select sewer utilities" aria-pressed="false">
                <i class="fas fa-toilet" aria-hidden="true"></i>
            </button>
            <button class="utility-btn telecom" data-utility="telecom" aria-label="Select telecom utilities" aria-pressed="false">
                <i class="fas fa-phone" aria-hidden="true"></i>
            </button>
        </div>
    </div>

    <!-- Measurement Tools -->
    <div class="measurement-tools">
        <button class="measurement-btn" id="measureDistanceBtn" title="Measure Distance">
            <i class="fas fa-ruler"></i>
        </button>
        <button class="measurement-btn" id="measureAreaBtn" title="Measure Area">
            <i class="fas fa-vector-square"></i>
        </button>
    </div>

    <!-- Bottom Controls -->
    <div class="bottom-controls">
        <div class="control-group">
            <button class="control-btn" id="locateBtn">
                <i class="fas fa-location-crosshairs"></i>
            </button>
            <button class="control-btn" id="layersBtn">
                <i class="fas fa-layer-group"></i>
            </button>
        </div>

        <div class="control-group center">
            <div class="main-action-group">
                <button class="main-action-btn" id="drawBtn">
                    <i class="fas fa-pencil-alt"></i>
                </button>
                <div class="line-type-toggle">
                    <button class="line-type-btn active" data-type="service">Service</button>
                    <button class="line-type-btn" data-type="main">Main</button>
                </div>
            </div>
        </div>

        <div class="control-group">
            <button class="control-btn excavation-btn" id="excavationBtn">
                <i class="fas fa-hard-hat"></i>
            </button>
            <button class="control-btn" id="settingsBtn">
                <i class="fas fa-cog"></i>
            </button>
        </div>
    </div>

    <!-- Right Side Controls -->
    <div class="right-controls">
        <button class="control-btn" id="zoomInBtn">
            <i class="fas fa-plus"></i>
        </button>
        <button class="control-btn" id="zoomOutBtn">
            <i class="fas fa-minus"></i>
        </button>
    </div>

    <!-- Add Structure Button -->
    <div class="structure-container">
    <button class="add-structure-btn" id="addStructureBtn">
        <i class="fas fa-plus"></i>
        </button>
        <div class="structure-menu" id="structureMenu">
            <button class="structure-type-btn" data-structure="electricBox" data-utility="electric">
                <i class="fas fa-bolt"></i>
                <span>Elec Box</span>
            </button>
            <button class="structure-type-btn" data-structure="catchBasin" data-utility="sewer">
                <i class="fas fa-water"></i>
                <span>Catch Basin</span>
            </button>
            <button class="structure-type-btn" data-structure="sewerManhole" data-utility="sewer">
                <i class="fas fa-circle"></i>
                <span>Sewer MH</span>
            </button>
            <button class="structure-type-btn" data-structure="waterManhole" data-utility="water">
                <i class="fas fa-tint"></i>
                <span>Water MH</span>
            </button>
            <button class="structure-type-btn" data-structure="gasManhole" data-utility="gas">
                <i class="fas fa-fire"></i>
                <span>Gas MH</span>
            </button>
            <button class="structure-type-btn" data-structure="gasValve" data-utility="gas">
                <i class="fas fa-wrench"></i>
                <span>Gas Valve</span>
            </button>
            <button class="structure-type-btn" data-structure="hydrantValve" data-utility="water">
                <i class="fas fa-fire-extinguisher"></i>
                <span>Hydrant</span>
            </button>
            <button class="structure-type-btn" data-structure="telecomBox" data-utility="telecom">
                <i class="fas fa-network-wired"></i>
                <span>Telecom</span>
            </button>
        </div>
    </div>

    <!-- Drawing UI -->
    <div class="drawing-ui" id="drawingUI">
        <h3>Drawing Utility Line</h3>
        <p id="drawingStatus">Click points on the map</p>
        <div class="drawing-actions">
            <button class="drawing-btn secondary" id="cancelDrawBtn">Cancel</button>
            <button class="drawing-btn primary" id="finishDrawBtn" style="display: none;">Finish</button>
        </div>
    </div>

    <!-- Refine Mode Overlay -->
    <div class="refine-overlay" id="refineOverlay">
        <span> Drag points to refine location</span>
        <button class="drawing-btn primary" id="finishRefineBtn">
            <i class="fas fa-check"></i> Finish Refining
        </button>
    </div>

    <!-- Utility Info Modal -->
    <div class="info-modal" id="infoModal">
        <div class="modal-handle"></div>
        <div class="modal-header">
            <div class="modal-title">
                <i class="fas fa-tint" id="modalIcon"></i>
                <span id="modalTitle">Utility Information</span>
            </div>
            <button class="modal-close" id="closeModalBtn">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="modal-body">
            <!-- View Mode -->
            <div id="viewMode">
                <div class="info-grid">
                    <div class="info-item">
                        <span class="info-label">Type</span>
                        <span class="info-value" id="infoType">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Line Type</span>
                        <span class="info-value" id="infoLineType">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Size</span>
                        <span class="info-value" id="infoSize">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Depth</span>
                        <span class="info-value" id="infoDepth">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Material</span>
                        <span class="info-value" id="infoMaterial">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Condition</span>
                        <span class="info-value" id="infoCondition">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Distance from Curb</span>
                        <span class="info-value" id="infoCurbDistance">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Date Added</span>
                        <span class="info-value" id="infoDate">-</span>
                    </div>
                </div>
                
                <!-- Notes Section -->
                <div class="notes-section">
                    <div class="notes-header">
                        <h3 class="notes-title">Notes</h3>
                        <button class="add-note-btn" id="addNoteBtn">
                            <i class="fas fa-plus"></i>
                            Add Note
                        </button>
                    </div>
                    <div class="notes-list" id="notesList"></div>
                </div>
                
                <div class="modal-actions">
                    <button class="modal-btn primary" id="editBtn">
                        <i class="fas fa-edit"></i>
                        Edit
                    </button>
                    <button class="modal-btn primary" id="refineBtn">
                        <i class="fas fa-crosshairs"></i>
                        Refine Location
                    </button>
                    <button class="modal-btn danger" id="deleteBtn">
                        <i class="fas fa-trash"></i>
                        Delete
                    </button>
                </div>
            </div>

            <!-- Edit Mode -->
            <div class="edit-form" id="editMode">
                <div class="form-group">
                    <label class="form-label">Size (inches)</label>
                    <input type="number" class="form-input" id="editSize" placeholder="e.g., 4">
                </div>
                <div class="form-group">
                    <label class="form-label">Depth (feet)</label>
                    <input type="number" class="form-input" id="editDepth" placeholder="e.g., 3">
                </div>
                <div class="form-group">
                    <label class="form-label">Material</label>
                    <select class="form-input form-select" id="editMaterial">
                        <option value="">Not specified</option>
                        <option value="PVC">PVC</option>
                        <option value="Cast Iron">Cast Iron</option>
                        <option value="Copper">Copper</option>
                        <option value="Steel">Steel</option>
                        <option value="HDPE">HDPE</option>
                        <option value="Concrete">Concrete</option>
                        <option value="Clay">Clay</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Condition</label>
                    <select class="form-input form-select" id="editCondition">
                        <option value="">Not specified</option>
                        <option value="Excellent">Excellent</option>
                        <option value="Good">Good</option>
                        <option value="Fair">Fair</option>
                        <option value="Poor">Poor</option>
                        <option value="Critical">Critical</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Distance from Curb (feet)</label>
                    <input type="number" class="form-input" id="editCurbDistance" placeholder="e.g., 6">
                </div>
                <div class="modal-actions">
                    <button class="modal-btn secondary" id="cancelEditBtn">
                        Cancel
                    </button>
                    <button class="modal-btn primary" id="saveEditBtn">
                        <i class="fas fa-save"></i>
                        Save
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Excavation Mode Overlay -->
    <div class="excavation-overlay" id="excavationOverlay">
        <div class="excavation-radar">
            <div class="radar-ring"></div>
            <div class="radar-ring"></div>
            <div class="radar-ring"></div>
        </div>
        <div class="excavation-header">
            <div class="excavation-info">
            <h2>EXCAVATION MODE ACTIVE</h2>
            <p>Monitoring utility proximity within 15 feet</p>
            </div>
            <button class="excavation-toggle" id="alertToggleBtn" title="Toggle proximity alerts">
                <i class="fas fa-eye"></i>
            </button>
        </div>
        <div class="proximity-alerts" id="proximityAlerts"></div>
        <button class="exit-excavation" id="exitExcavationBtn">Exit Excavation Mode</button>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <h2>Settings</h2>
            <button class="modal-close" id="closeSettingsBtn">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="settings-section">
            <h3>Appearance</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-moon"></i>
                        Dark Mode
                    </span>
                    <button class="toggle-switch active" id="darkModeToggle"></button>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h3>Map Style</h3>
            <div class="map-styles">
                <button class="map-style-btn active" data-style="streets">Streets</button>
                <button class="map-style-btn" data-style="satellite">Satellite</button>
                <button class="map-style-btn" data-style="terrain">Terrain</button>
                <button class="map-style-btn" data-style="dark">Dark</button>
            </div>
        </div>

        <div class="settings-section">
            <h3>Utility Visibility</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-tint" style="color: var(--water-color)"></i>
                        Water
                    </span>
                    <button class="toggle-switch active" data-utility="water"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-fire" style="color: var(--gas-color)"></i>
                        Gas
                    </span>
                    <button class="toggle-switch active" data-utility="gas"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-bolt" style="color: var(--electric-color)"></i>
                        Electric
                    </span>
                    <button class="toggle-switch active" data-utility="electric"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-toilet" style="color: var(--sewer-color)"></i>
                        Sewer
                    </span>
                    <button class="toggle-switch active" data-utility="sewer"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-phone" style="color: var(--telecom-color)"></i>
                        Telecom
                    </span>
                    <button class="toggle-switch active" data-utility="telecom"></button>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h3>Line Types</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-grip-lines"></i>
                        Main Lines
                    </span>
                    <button class="toggle-switch active" data-linetype="main"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-code-branch"></i>
                        Service Lines
                    </span>
                    <button class="toggle-switch active" data-linetype="service"></button>
                </div>
            </div>
        </div>
        
        <div class="settings-section">
            <h3>Cloud Sync</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-cloud"></i>
                        Enable Cloud Sync
                    </span>
                    <button class="toggle-switch" id="cloudSyncToggle"></button>
                </div>
            </div>
            <p style="margin-top: var(--spacing-sm); font-size: 12px; color: var(--text-tertiary);">
                Sync your data across devices
            </p>
        </div>
        
        <div class="settings-section">
            <h3>Account</h3>
            <button class="signout-btn" onclick="signOut()">
                <i class="fas fa-sign-out-alt"></i>
                Sign Out
            </button>
        </div>
    </div>

    <!-- Connection Dialog -->
    <div class="connection-dialog" id="connectionDialog">
        <h3>Connect Utilities?</h3>
        <p>The endpoints are close. Would you like to connect them?</p>
        <div class="connection-actions">
            <button class="drawing-btn secondary" id="noConnectBtn">No</button>
            <button class="drawing-btn primary" id="yesConnectBtn">Yes, Connect</button>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Sync Status -->
    <div class="sync-status" id="syncStatus">
        <i class="fas fa-sync"></i>
        <span>Syncing...</span>
    </div>
    
    <!-- Note Input Modal -->
    <div class="note-input-modal" id="noteInputModal">
        <div class="note-input-content">
            <h3 class="note-input-header">Add Note</h3>
            <textarea class="note-textarea" id="noteTextarea" placeholder="Enter your note..."></textarea>
            <div class="note-input-actions">
                <button class="modal-btn secondary" id="cancelNoteBtn">Cancel</button>
                <button class="modal-btn primary" id="saveNoteBtn">Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Leaflet JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

<script>
    // Premium App State
    const AppState = {
        map: null,
        theme: 'dark',
        selectedUtility: 'water',
        lineType: 'service',
        isDrawing: false,
        drawingPoints: [],
        tempLine: null,
        utilities: [],
        structures: [],
        userLocation: null,
        userMarker: null,
        watchId: null,
        deviceOrientationHandler: null,
        // Firebase & User Management
        currentUser: null,
        userRole: null, // 'admin', 'user', or 'pending'
        pendingChanges: [],
        allUsers: [],
        realtimeListeners: [], // For cleanup
        // Premium GPS Tracking System
        gps: {
            lastPosition: null,
            filteredPosition: null,
            lastHeading: null,
            filteredHeading: null,
            lastAccuracy: null,
            lastUpdateTime: 0,
            isMoving: false,
            movementSpeed: 0,
            headingHistory: [],
            positionHistory: [],
            quality: 'unknown'
        },
        excavationMode: false,
        proximityAlerts: [],
        proximityAlertsVisible: true,
        selectedUtilityData: null,
        refineMode: false,
        refineMarkers: [],
        addingStructure: false,
        structureToAdd: null,
        measureMode: null,
        measurePoints: [],
        measureMarkers: [],
        measureLine: null,
        measurePolygon: null,
        layers: {
            utilities: {},
            structures: {},
            visibility: {
                water: true,
                gas: true,
                electric: true,
                sewer: true,
                telecom: true,
                main: true,
                service: true
            }
        },
        dismissedAlerts: new Map(),
        alertTimeouts: new Map(),
        connectionCandidate: null,
        mapStyles: {
            streets: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            satellite: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
            terrain: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
            dark: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'
        },
        currentMapStyle: 'dark',
        cloudSync: {
            enabled: false,
            lastSync: null,
            apiUrl: 'https://api.cacutilitrack.com',
            userId: null,
            token: null
        },
        needsOrientationPermission: false,
        // Cached DOM elements for performance
        elements: {
            drawingUI: null,
            refineOverlay: null,
            infoModal: null,
            settingsPanel: null,
            proximityAlerts: null,
            toastContainer: null,
            syncStatus: null
        },
        // Cleanup functions for proper memory management
        cleanupFunctions: []
    };

    // Initialize App
    document.addEventListener('DOMContentLoaded', () => {
        initializeApp();
    });

    function initializeApp() {
        // Enhanced mobile detection and optimization
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isAndroid = /Android/.test(navigator.userAgent);
        const isMobile = isIOS || isAndroid || window.innerWidth <= 768;
        
        if (isMobile) {
            document.body.style.height = '100vh';
            document.body.style.height = '100dvh'; // Use dynamic viewport height if supported
            document.body.style.position = 'fixed';
            document.body.style.overflow = 'hidden';
            
            // Prevent rubber band scrolling on iOS
            if (isIOS) {
                document.body.style.webkitOverflowScrolling = 'touch';
                document.addEventListener('touchmove', function(e) {
                    if (e.target.closest('.modal-body, .settings-panel, .proximity-alerts')) {
                        return; // Allow scrolling in specific containers
                    }
                    e.preventDefault();
                }, { passive: false });
            }
        }

        // Check authentication state
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                console.log(' User authenticated:', user.email);
                AppState.currentUser = user;
                
                try {
                    // Get user role from Firestore
                    const userDoc = await db.collection('users').doc(user.uid).get();
                    if (userDoc.exists) {
                        const userData = userDoc.data();
                        AppState.userRole = userData.role || 'pending';
                        
                        console.log(' User role from Firestore:', AppState.userRole);
                        
                        // Check if this is the first user and make them admin
                        if (AppState.userRole === 'pending') {
                            const isFirstAdmin = await checkAndMakeFirstAdmin(user.uid);
                            if (isFirstAdmin) {
                                AppState.userRole = 'admin';
                                console.log(' First user promoted to admin');
                                showToast('Welcome! You are now the system administrator.', 'success');
                            } else {
                                showToast('Your account is pending admin approval', 'warning');
                                showLoginError('Account pending approval. Please contact an admin.');
                                setTimeout(() => auth.signOut(), 2000);
                                return;
                            }
                        }
                    } else {
                        console.warn(' User authenticated but no Firestore document found');
                        showLoginError('Account setup incomplete. Please contact admin.');
                        setTimeout(() => auth.signOut(), 2000);
                        return;
                    }
                    
                    // Successfully authenticated with approved role
                    console.log(' User role verified:', AppState.userRole);
                    
                    // Hide login screen and show app
                    document.getElementById('loginScreen').classList.remove('active');
                    
                    // Show role badge and admin button if needed
                    showRoleBadge();
                    
                    // Initialize main app
                    initializeMainApp();
                    
                } catch (error) {
                    console.error(' Error checking user role:', error);
                    showLoginError('Error verifying account. Please try again.');
                    setTimeout(() => auth.signOut(), 2000);
                }
                
            } else {
                console.log(' User not authenticated');
                
                // Cleanup any Firebase listeners
                cleanupRealtimeListeners();
                
                // Show login after splash completes
                setTimeout(() => {
                    document.getElementById('splash').classList.add('hide');
                    setTimeout(() => {
                        document.getElementById('splash').style.display = 'none';
                        document.getElementById('loginScreen').classList.add('active');
                    }, 2000);
                }, 3000);
                
                // Setup login handlers
                setupLoginHandlers();
            }
        });

        // ========== TRIPLE AAA QUALITY SPLASH SYSTEM ==========
        let progress = 0;
        const splashElement = document.getElementById('splash');
        const loadingBar = document.getElementById('loadingBar');
        const loadingText = document.getElementById('loadingText');
        const loadingPercentage = document.getElementById('loadingPercentage');
        
        // Ultra-sophisticated loading stages with technical descriptions
        const loadingStages = [
            { stage: 'Initializing Neural Networks', duration: 1200, progressJump: 18, color: '#667eea' },
            { stage: 'Calibrating GPS Matrix', duration: 900, progressJump: 22, color: '#ff006e' },
            { stage: 'Loading Quantum Processors', duration: 1100, progressJump: 20, color: '#00f5a0' },
            { stage: 'Optimizing Vector Graphics', duration: 800, progressJump: 25, color: '#ffd60a' },
            { stage: 'Finalizing Core Systems', duration: 600, progressJump: 15, color: '#b565d8' }
        ];
        
        let currentStage = 0;
        
        // Start neural particle animation with sophisticated timing
        setTimeout(() => {
            const particles = document.querySelectorAll('.neural-particle');
            particles.forEach((particle, index) => {
                setTimeout(() => {
                    particle.style.opacity = '1';
                    // Start the neural flow animation with randomized durations
                    const duration = 12 + Math.random() * 8; // 12-20 seconds
                    particle.style.animationDuration = `${duration}s`;
                }, index * 300 + Math.random() * 500);
            });
        }, 800);
        
        // Advanced loading system with smooth animations
        function updateTripleAProgress() {
            if (currentStage < loadingStages.length) {
                const stage = loadingStages[currentStage];
                
                // Update loading text with smooth transition
                loadingText.style.opacity = '0';
                setTimeout(() => {
                    loadingText.textContent = stage.stage;
                    loadingText.style.opacity = '1';
                }, 200);
                
                // Smooth progress increment with easing
                const startProgress = progress;
                const targetProgress = Math.min(progress + stage.progressJump, 100);
                const startTime = Date.now();
                
                function animateProgress() {
                    const elapsed = Date.now() - startTime;
                    const progressPercent = Math.min(elapsed / stage.duration, 1);
                    
                    // Use easeOutCubic for smooth progress animation
                    const eased = 1 - Math.pow(1 - progressPercent, 3);
                    progress = startProgress + (stage.progressJump * eased);
                    
                    // Update visual elements
                    loadingBar.style.width = `${progress}%`;
                    loadingPercentage.textContent = `${Math.round(progress)}%`;
                    
                    // Dynamic color shifting based on stage
                    loadingBar.style.boxShadow = `0 0 20px ${stage.color}30`;
                    
                    // Add subtle pulsing effect at milestones
                    if (Math.round(progress) % 25 === 0 && Math.round(progress) > 0) {
                        loadingPercentage.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            loadingPercentage.style.transform = 'scale(1)';
                        }, 200);
                    }
                    
                    if (progressPercent < 1) {
                        requestAnimationFrame(animateProgress);
                    } else {
                        progress = targetProgress;
                        
                        if (progress >= 100) {
                            // Ultra-premium completion sequence
                            completeSplashScreen();
                        } else {
                            currentStage++;
                            setTimeout(updateTripleAProgress, 300);
                        }
                    }
                }
                
                requestAnimationFrame(animateProgress);
            }
        }
        
        function completeSplashScreen() {
            // Final stage visual effects
            loadingText.style.opacity = '0';
            setTimeout(() => {
                loadingText.textContent = 'SYSTEM READY';
                loadingText.style.opacity = '1';
                loadingText.style.color = '#00f5a0';
                loadingText.style.fontWeight = '700';
                loadingText.style.letterSpacing = '2px';
            }, 200);
            
            loadingPercentage.textContent = 'READY';
            loadingPercentage.style.color = '#00f5a0';
            loadingPercentage.style.transform = 'scale(1.2)';
            
            // Advanced exit sequence with multiple effects
            setTimeout(() => {
                splashElement.style.transition = 'all 2s cubic-bezier(0.23, 1, 0.32, 1)';
                splashElement.style.transform = 'scale(1.1)';
                splashElement.style.filter = 'blur(20px)';
                
                setTimeout(() => {
                    splashElement.classList.add('hide');
                    
                    // Additional cleanup after transition
                    setTimeout(() => {
                        splashElement.style.display = 'none';
                    }, 2000);
                }, 500);
            }, 1200);
        }
        
        // Start the sophisticated loading sequence
        setTimeout(() => {
            updateTripleAProgress();
        }, 1500);
    }

    // Graceful Firestore collection handling - no placeholder documents needed
    function setupGracefulFirestoreHandling() {
        console.log(' Setting up graceful Firestore collection handling...');
        
        // Override Firestore collection methods to handle missing collections gracefully
        const originalGet = db.collection;
        
        // Add global error handler for Firestore operations
        AppState.firestoreErrorHandler = (collectionName, operation, error) => {
            const isCollectionNotFound = error.code === 'not-found' || 
                                        error.code === 'failed-precondition' ||
                                        error.message.includes('Collection') ||
                                        error.message.includes('Missing or insufficient permissions');
            
            if (isCollectionNotFound) {
                console.log(` Collection '${collectionName}' doesn't exist yet - this is normal for new systems`);
                return { empty: true, docs: [], size: 0 };
            } else {
                console.error(` Real Firestore error in ${collectionName}.${operation}:`, error);
                throw error; // Re-throw real errors
            }
        };
        
        // Enhanced collection reference with built-in error handling
        AppState.safeCollection = (collectionName) => {
            const originalRef = db.collection(collectionName);
            
            // Override get method to handle missing collections
            const originalGetMethod = originalRef.get;
            originalRef.get = async function() {
                try {
                    const result = await originalGetMethod.call(this);
                    return result;
                } catch (error) {
                    return AppState.firestoreErrorHandler(collectionName, 'get', error);
                }
            };
            
            // Override onSnapshot to handle missing collections
            const originalOnSnapshot = originalRef.onSnapshot;
            originalRef.onSnapshot = function(successCallback, errorCallback) {
                const wrappedSuccessCallback = (snapshot) => {
                    successCallback(snapshot);
                };
                
                const wrappedErrorCallback = (error) => {
                    const isCollectionNotFound = error.code === 'not-found' || 
                                               error.code === 'failed-precondition';
                    
                    if (isCollectionNotFound) {
                        console.log(` Real-time listener: Collection '${collectionName}' doesn't exist yet`);
                        // Create empty snapshot-like object
                        const emptySnapshot = {
                            empty: true,
                            docs: [],
                            size: 0,
                            docChanges: () => []
                        };
                        successCallback(emptySnapshot);
                    } else if (errorCallback) {
                        errorCallback(error);
                    } else {
                        console.error(` Real-time listener error in ${collectionName}:`, error);
                    }
                };
                
                return originalOnSnapshot.call(this, wrappedSuccessCallback, wrappedErrorCallback);
            };
            
            return originalRef;
        };
        
        console.log(' Graceful Firestore handling setup complete');
    }

    // New function to initialize the main app after authentication
    function initializeMainApp() {
        console.log(' Initializing main app for user:', AppState.currentUser.email);

        // Setup graceful Firestore collection handling
        setupGracefulFirestoreHandling();

        // Initialize core systems
        initializeMap();
        initializeDOMCache();
        initializeEventListeners();

        // Enhanced theme management
        const savedTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'dark');
        setTheme(savedTheme);

        // Watch for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                setTheme(e.matches ? 'dark' : 'light');
            }
        });

        // Load data from Firestore
        loadUtilities();
        loadStructures();

        // Setup admin listeners if admin
        if (AppState.userRole === 'admin') {
            setupAdminListeners();
        }

        // Apply initial zoom-based opacity
        setTimeout(() => {
            handleZoomChange();
        }, 1000);

        // Start premium location tracking with enhanced permissions
        requestLocationPermissions();

        // Premium GPS system initialized
        console.log(' CAC UTILI-TRACK SHARED MAP SYSTEM READY! ');
        console.log('');
        console.log(' NEW SHARED MAP FEATURES:');
        console.log('   Everyone sees the same map');
        console.log('   Admin approval system');
        console.log('   Real-time updates');
        console.log('   User role management');
        console.log('');
        console.log(' YOUR ROLE:', AppState.userRole?.toUpperCase() || 'UNKNOWN');
        if (AppState.userRole === 'admin') {
            console.log('   You can approve changes and manage users');
            console.log('   Click the admin button () in the top right');
        } else {
            console.log('   Your changes need admin approval');
            console.log('   Draw utilities - they appear as dashed lines until approved');
        }
        console.log('');
        console.log(' DEBUG COMMANDS:');
        console.log('  - debugAccountStatus() : Check your account status');
        console.log('  - demoPremiumGPS() : Test GPS features');
        console.log('  - testMobileTouch() : Test mobile touch');
        console.log('');
        console.log(' HAVING ISSUES?');
        console.log('  1. Run: debugAccountStatus()');
        console.log('  2. Check your role and Firestore document');
        console.log('  3. Sign out and back in if needed');
        console.log('');

        // Enhanced touch event prevention - only prevent double-tap zoom and pull-to-refresh
        let touchStartY = 0;
        
        document.addEventListener('touchstart', function(event) {
            if (event.touches && event.touches[0]) {
                touchStartY = event.touches[0].clientY;
            }
        }, { passive: true });
        
        // Prevent pull-to-refresh only at top of page
        document.addEventListener('touchmove', function(event) {
            if (event.touches && event.touches[0]) {
                const touchY = event.touches[0].clientY;
                const touchDiff = touchY - touchStartY;
                
                // Only prevent if pulling down at top of page and not in scrollable areas
                if (touchDiff > 0 && window.scrollY === 0 && 
                    !event.target.closest('.modal-body, .settings-panel, .proximity-alerts, .notes-list')) {
                    event.preventDefault();
                }
            }
        }, { passive: false });
        
        // Enhanced keyboard handling for iOS
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        if (isIOS) {
            const viewport = document.querySelector('meta[name=viewport]');
            document.addEventListener('focusin', function() {
                viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
            });
            
            document.addEventListener('focusout', function() {
                viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover');
            });
        }
        
        // Performance monitoring
        if ('performance' in window && 'PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.entryType === 'paint' && entry.name === 'first-contentful-paint') {
                        console.log('First Contentful Paint:', entry.startTime);
                    }
                }
            });
            observer.observe({ entryTypes: ['paint'] });
        }
    }
    
    async function requestLocationPermissions() {
        if (!navigator.geolocation) {
            showToast('Geolocation not supported', 'error');
            return;
        }
        
        try {
            // Check current permission state
            if ('permissions' in navigator) {
                const permission = await navigator.permissions.query({name: 'geolocation'});
                if (permission.state === 'denied') {
                    showToast('Location access denied. Please enable in settings.', 'warning');
                    return;
                }
            }

        // Start location tracking
        startLocationTracking();

        } catch (error) {
            console.error('Permission error:', error);
            // Fallback to direct geolocation request
            startLocationTracking();
        }
    }

    // ========== FIREBASE AUTHENTICATION & ADMIN SYSTEM ==========



    async function checkAndMakeFirstAdmin(userId) {
        console.log(' Checking if first admin should be created...');
        
        try {
            // Check if any admin users exist
            const adminSnapshot = await db.collection('users')
                .where('role', '==', 'admin')
                .limit(1)
                .get();
            
            if (adminSnapshot.empty) {
                // No admins exist, make this user an admin
                console.log(' No admins found, promoting first user to admin');
                
                await db.collection('users').doc(userId).update({
                    role: 'admin',
                    promotedToAdmin: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                console.log(' First user promoted to admin successfully');
                return true;
            } else {
                console.log(' Admin users already exist, keeping user as pending');
                return false;
            }
            
        } catch (error) {
            console.error(' Error checking for first admin:', error);
            return false;
        }
    }

    function setupLoginHandlers() {
        console.log(' Setting up login handlers');
        
        // Allow Enter key to submit
        document.getElementById('loginPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleEmailLogin();
            }
        });
        
        // Sign In
        document.getElementById('loginBtn').addEventListener('click', async () => {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showLoginError('Please enter both email and password');
                return;
            }
            
            try {
                showLoginError('');
                const result = await auth.signInWithEmailAndPassword(email, password);
                
                // Check if user document exists in Firestore
                const userDoc = await db.collection('users').doc(result.user.uid).get();
                if (!userDoc.exists) {
                    console.log(' Creating missing user document for existing user');
                    // Create user document if it doesn't exist (for existing auth users)
                    await db.collection('users').doc(result.user.uid).set({
                        email: result.user.email,
                        uid: result.user.uid,
                        role: 'pending', // New users start as pending
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    showLoginError('Account created in database. Awaiting admin approval.');
                    await auth.signOut();
                    return;
                }
                
                showLoginError('');
            } catch (error) {
                console.error('Login error:', error);
                let message = 'Login failed';
                switch (error.code) {
                    case 'auth/user-not-found':
                        message = 'No account found with this email';
                        break;
                    case 'auth/wrong-password':
                        message = 'Incorrect password';
                        break;
                    case 'auth/invalid-email':
                        message = 'Invalid email address';
                        break;
                    case 'auth/too-many-requests':
                        message = 'Too many failed attempts. Please try again later';
                        break;
                    default:
                        message = error.message || 'Login failed';
                }
                showLoginError(message);
            }
        });
        
        // Sign Up
        document.getElementById('signupBtn').addEventListener('click', async () => {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showLoginError('Please enter email and password');
                return;
            }
            
            if (password.length < 6) {
                showLoginError('Password must be at least 6 characters');
                return;
            }
            
            try {
                showLoginError('');
                const result = await auth.createUserWithEmailAndPassword(email, password);
                
                console.log(' Creating user document for new signup');
                // Create user document in Firestore
                await db.collection('users').doc(result.user.uid).set({
                    email: result.user.email,
                    uid: result.user.uid,
                    role: 'pending',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                showLoginError(' Account created successfully! Awaiting admin approval.');
                
                // Sign out immediately since they're pending
                await auth.signOut();
                
            } catch (error) {
                console.error('Signup error:', error);
                let message = 'Signup failed';
                switch (error.code) {
                    case 'auth/email-already-in-use':
                        message = 'Email already registered';
                        break;
                    case 'auth/invalid-email':
                        message = 'Invalid email address';
                        break;
                    case 'auth/weak-password':
                        message = 'Password is too weak';
                        break;
                    default:
                        message = error.message || 'Signup failed';
                }
                showLoginError(message);
            }
        });
        
        // Google Sign In
        document.getElementById('googleBtn').addEventListener('click', async () => {
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                showLoginError('');
                const result = await auth.signInWithPopup(provider);
                
                // Check if user document exists
                const userDoc = await db.collection('users').doc(result.user.uid).get();
                if (!userDoc.exists) {
                    console.log(' Creating user document for new Google user');
                    // Create user document for Google users
                    await db.collection('users').doc(result.user.uid).set({
                        email: result.user.email,
                        uid: result.user.uid,
                        displayName: result.user.displayName || '',
                        role: 'pending',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    showLoginError(' Google account created! Awaiting admin approval.');
                    await auth.signOut();
                    return;
                }
                
                showLoginError('');
            } catch (error) {
                console.error('Google login error:', error);
                if (error.code !== 'auth/popup-closed-by-user') {
                    showLoginError('Google sign-in failed. Please try again.');
                }
            }
        });
    }

    function showLoginError(message) {
        const errorEl = document.getElementById('loginError');
        if (message) {
            errorEl.textContent = message;
            errorEl.classList.add('show');
        } else {
            errorEl.classList.remove('show');
        }
    }

    function showRoleBadge() {
        // Remove existing badge/button
        const existingBadge = document.querySelector('.role-badge');
        const existingAdminBtn = document.querySelector('.admin-btn');
        if (existingBadge) existingBadge.remove();
        if (existingAdminBtn) existingAdminBtn.remove();
        
        // Add role badge
        const badge = document.createElement('div');
        badge.className = `role-badge ${AppState.userRole}`;
        badge.innerHTML = `
            <i class="fas ${AppState.userRole === 'admin' ? 'fa-user-shield' : 'fa-user'}"></i>
            ${AppState.userRole.toUpperCase()}
        `;
        document.body.appendChild(badge);
        
        // Add admin button if admin
        if (AppState.userRole === 'admin') {
            const adminBtn = document.createElement('button');
            adminBtn.className = 'admin-btn';
            adminBtn.innerHTML = '<i class="fas fa-cog"></i>';
            adminBtn.onclick = openAdminPanel;
            adminBtn.title = 'Admin Panel';
            document.body.appendChild(adminBtn);
        }
    }



    function setupAdminListeners() {
        if (AppState.userRole !== 'admin') {
            console.log(' Not admin, skipping admin listeners');
            return;
        }
        
        console.log(' Setting up admin real-time listeners...');
        
        // Listen for pending changes
        const pendingListener = AppState.safeCollection('pendingChanges')
            .orderBy('timestamp', 'desc')
            .onSnapshot((snapshot) => {
                console.log(` ${snapshot.docs.length} pending changes found`);
                updatePendingChangesList(snapshot.docs);
            }, (error) => {
                console.error(' Error listening to pending changes:', error);
            });
        
        // Listen for user changes
        const usersListener = AppState.safeCollection('users')
            .onSnapshot((snapshot) => {
                if (document.getElementById('adminPanel').classList.contains('active')) {
                    loadUsers(); // Refresh user list if admin panel is open
                }
            }, (error) => {
                console.error(' Error listening to users:', error);
            });
        
        AppState.realtimeListeners = [pendingListener, usersListener];
        console.log(' Admin listeners setup complete');
    }

    function cleanupRealtimeListeners() {
        console.log(' Cleaning up Firebase listeners');
        AppState.realtimeListeners.forEach(unsubscribe => {
            try {
                unsubscribe();
            } catch (error) {
                console.error('Error unsubscribing listener:', error);
            }
        });
        AppState.realtimeListeners = [];
    }



    function removeUtilityFromMap(utilityId) {
        const index = AppState.utilities.findIndex(u => u.id === utilityId);
        if (index > -1) {
            const utility = AppState.utilities[index];
            
            // Remove from map
            if (utility.lineLayer) {
                AppState.map.removeLayer(utility.lineLayer);
            }
            if (utility.connectionMarkers) {
                utility.connectionMarkers.forEach(marker => {
                    if (AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                });
            }
            
            // Remove from state
            AppState.utilities.splice(index, 1);
        }
    }

    function removeStructureFromMap(structureId) {
        const index = AppState.structures.findIndex(s => s.id === structureId);
        if (index > -1) {
            const structure = AppState.structures[index];
            
            // Remove from map
            if (structure.marker) {
                AppState.map.removeLayer(structure.marker);
            }
            
            // Remove from state
            AppState.structures.splice(index, 1);
        }
    }

    function initializeDOMCache() {
        // Cache frequently accessed DOM elements for performance
        AppState.elements.drawingUI = document.getElementById('drawingUI');
        AppState.elements.refineOverlay = document.getElementById('refineOverlay');
        AppState.elements.infoModal = document.getElementById('infoModal');
        AppState.elements.settingsPanel = document.getElementById('settingsPanel');
        AppState.elements.proximityAlerts = document.getElementById('proximityAlerts');
        AppState.elements.toastContainer = document.getElementById('toastContainer');
        AppState.elements.syncStatus = document.getElementById('syncStatus');
    }

    function initializeMap() {
        // Create map
        AppState.map = L.map('map', {
            center: [40.7128, -74.0060], // Default to NYC
            zoom: 16,
            zoomControl: false,
            attributionControl: false,
            doubleClickZoom: false,
            touchZoom: true,
            scrollWheelZoom: true,
            boxZoom: false,
            keyboard: false,
            tap: false
        });

        // Add tile layer
        L.tileLayer(AppState.mapStyles[AppState.currentMapStyle], {
            maxZoom: 22,
            maxNativeZoom: 19
        }).addTo(AppState.map);

        // Initialize utility layers
        const utilityTypes = ['water', 'gas', 'electric', 'sewer', 'telecom'];
        utilityTypes.forEach(type => {
            AppState.layers.utilities[type] = L.layerGroup().addTo(AppState.map);
            AppState.layers.structures[type] = L.layerGroup().addTo(AppState.map);
        });

        // Map events
        AppState.map.on('click', handleMapClick);
        AppState.map.on('contextmenu', function(e) {
            if (e && e.originalEvent) {
                e.originalEvent.preventDefault();
            }
            return false;
        });
        AppState.map.on('zoomend', handleZoomChange);
        AppState.map.on('zoom', handleZoomChange); // For smooth transitions during zoom
    }

    function initializeEventListeners() {
        // Prevent all context menus
        document.addEventListener('contextmenu', function(e) {
            if (e && e.preventDefault) {
                e.preventDefault();
            }
            return false;
        });

        // Utility selection
        document.querySelectorAll('.utility-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('.utility-btn').forEach(b => {
                    b.classList.remove('active');
                    b.setAttribute('aria-pressed', 'false');
                });
                btn.classList.add('active');
                btn.setAttribute('aria-pressed', 'true');
                AppState.selectedUtility = btn.dataset.utility;
                hapticFeedback(30);
            });
        });

        // Line type selection
        document.querySelectorAll('.line-type-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('.line-type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                AppState.lineType = btn.dataset.type;
                hapticFeedback(30);
            });
        });

        // Control buttons
        document.getElementById('drawBtn').addEventListener('click', startDrawing);
        document.getElementById('locateBtn').addEventListener('click', centerOnLocation);
        document.getElementById('layersBtn').addEventListener('click', toggleLayersPanel);
        document.getElementById('excavationBtn').addEventListener('click', toggleExcavationMode);
        document.getElementById('settingsBtn').addEventListener('click', openSettings);
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            AppState.map.zoomIn();
            hapticFeedback(20);
        });
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            AppState.map.zoomOut();
            hapticFeedback(20);
        });

        // Measurement tools
        document.getElementById('measureDistanceBtn').addEventListener('click', () => toggleMeasureMode('distance'));
        document.getElementById('measureAreaBtn').addEventListener('click', () => toggleMeasureMode('area'));

        // Structure button
        document.getElementById('addStructureBtn').addEventListener('click', toggleStructureMenu);
        document.querySelectorAll('.structure-type-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                startAddingStructure(btn.dataset.structure, btn.dataset.utility);
            });
        });

        // Drawing controls
        document.getElementById('cancelDrawBtn').addEventListener('click', cancelDrawing);
        document.getElementById('finishDrawBtn').addEventListener('click', finishDrawing);

        // Refine controls
        document.getElementById('finishRefineBtn').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            finishRefining();
        });

        // Modal controls
        document.getElementById('closeModalBtn').addEventListener('click', closeInfoModal);
        document.getElementById('editBtn').addEventListener('click', enterEditMode);
        document.getElementById('refineBtn').addEventListener('click', (e) => {
            console.log(' Refine button clicked');
            startRefineLocation();
        });
        document.getElementById('deleteBtn').addEventListener('click', deleteUtility);

        // Edit form controls
        document.getElementById('cancelEditBtn').addEventListener('click', exitEditMode);
        document.getElementById('saveEditBtn').addEventListener('click', saveEdit);

        // Notes
        document.getElementById('addNoteBtn').addEventListener('click', showNoteInput);
        
        // Note input modal
        document.getElementById('cancelNoteBtn').addEventListener('click', hideNoteInput);
        document.getElementById('saveNoteBtn').addEventListener('click', saveNote);

        // Excavation mode
        document.getElementById('exitExcavationBtn').addEventListener('click', exitExcavationMode);
        document.getElementById('alertToggleBtn').addEventListener('click', toggleProximityAlerts);

        // Settings
        document.getElementById('closeSettingsBtn').addEventListener('click', closeSettings);
        document.getElementById('darkModeToggle').addEventListener('click', toggleDarkMode);
        document.getElementById('cloudSyncToggle').addEventListener('click', toggleCloudSync);

        // Map style buttons
        document.querySelectorAll('.map-style-btn').forEach(btn => {
            btn.addEventListener('click', () => changeMapStyle(btn.dataset.style));
        });

        // Visibility toggles
        document.querySelectorAll('.toggle-switch[data-utility]').forEach(toggle => {
            toggle.addEventListener('click', () => toggleUtilityVisibility(toggle));
        });

        document.querySelectorAll('.toggle-switch[data-linetype]').forEach(toggle => {
            toggle.addEventListener('click', () => toggleLineTypeVisibility(toggle));
        });

        // Connection dialog
        document.getElementById('noConnectBtn').addEventListener('click', () => {
            closeConnectionDialog(false);
        });
        document.getElementById('yesConnectBtn').addEventListener('click', () => {
            closeConnectionDialog(true);
        });

        // Close menus on outside click and cancel structure placement
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.structure-container')) {
                document.getElementById('structureMenu').classList.remove('active');
            }
        });

        // Add escape key handler to cancel structure placement
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (AppState.addingStructure) {
                    cancelStructurePlacement();
                }
            }
        });

        // Enhanced gesture prevention for iOS/Safari
        const preventGestures = (e) => e.preventDefault();
        document.addEventListener('gesturestart', preventGestures);
        document.addEventListener('gesturechange', preventGestures);
        document.addEventListener('gestureend', preventGestures);
        
        // Store cleanup functions for proper app shutdown
        AppState.cleanupFunctions = [
            () => {
                document.removeEventListener('gesturestart', preventGestures);
                document.removeEventListener('gesturechange', preventGestures);
                document.removeEventListener('gestureend', preventGestures);
            }
        ];
    }

    // Haptic Feedback
    function hapticFeedback(duration = 50) {
        if ('vibrate' in navigator) {
            navigator.vibrate(duration);
        }
    }

    // Location tracking
    function startLocationTracking() {
        if (!navigator.geolocation) {
            showToast('Geolocation not supported', 'error');
            return;
        }

        console.log(' Starting location tracking...');

        // Get initial position with better options
        navigator.geolocation.getCurrentPosition(
            position => {
                console.log(' Initial location acquired');
                updateUserLocation(position);
            },
            error => {
                console.error(' Initial location error:', error);
                showToast('Location access denied', 'error');
            },
            { 
                enableHighAccuracy: true,
                timeout: 15000,
                maximumAge: 0
            }
        );

        // Watch position with more forgiving settings
        AppState.watchId = navigator.geolocation.watchPosition(
            position => {
                updateUserLocation(position);
            },
            error => {
                console.error(' Watch position error:', error);
                let message = 'Location error';
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        message = 'Location access denied by user';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        message = 'Location information unavailable';
                        break;
                    case error.TIMEOUT:
                        message = 'Location request timed out';
                        break;
                }
                showToast(message, 'warning');
            },
            {
                enableHighAccuracy: true,
                timeout: 15000,
                maximumAge: 5000  // Allow slightly cached positions
            }
        );

        // Watch device orientation
        if (window.DeviceOrientationEvent) {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                AppState.needsOrientationPermission = true;
            } else {
                window.addEventListener('deviceorientation', handleDeviceOrientation);
            }
        }
    }

    function handleDeviceOrientation(event) {
        let heading = 0;
        
        if (event.webkitCompassHeading !== undefined) {
            // iOS - webkitCompassHeading gives heading relative to magnetic north
            heading = event.webkitCompassHeading;
        } else if (event.alpha !== null) {
            // Android - alpha gives rotation around z-axis
            if (event.absolute) {
                heading = event.alpha;
            } else {
                // If not absolute, we need to adjust for device orientation
                heading = 360 - event.alpha;
            }
        }
        
        updatePremiumDirectionIndicator(heading);
    }

    // ========== PREMIUM GPS TRACKING SYSTEM ==========

    function updateUserLocation(position) {
        const { latitude, longitude, accuracy, speed } = position.coords;
        const timestamp = Date.now();
        
        console.log(` Raw GPS: ${latitude.toFixed(6)}, ${longitude.toFixed(6)}, ${accuracy.toFixed(1)}m`);
        
        // Validate coordinates
        if (!isValidCoordinate(latitude, longitude)) {
            console.error(' Invalid coordinates received:', latitude, longitude);
            return;
        }
        
        // Process location through premium filtering system
        const processedLocation = processLocationUpdate({
            lat: latitude,
            lng: longitude,
            accuracy: accuracy,
            speed: speed || 0,
            timestamp: timestamp
        });
        
        if (!processedLocation) {
            console.log(' Location update filtered out');
            return;
        }
        
        // Update app state
        AppState.userLocation = [processedLocation.lat, processedLocation.lng];
        
        // Create or update marker
        if (!AppState.userMarker) {
            createPremiumLocationMarker(processedLocation);
        } else {
            updatePremiumLocationMarker(processedLocation);
        }
        
        // Check proximity in excavation mode
        if (AppState.excavationMode) {
            checkProximity();
        }
    }

    function processLocationUpdate(rawLocation) {
        const gps = AppState.gps;
        const now = rawLocation.timestamp;
        
        // First location - initialize system
        if (!gps.lastPosition) {
            gps.lastPosition = rawLocation;
            gps.filteredPosition = { ...rawLocation };
            gps.lastUpdateTime = now;
            gps.quality = getGPSQuality(rawLocation.accuracy);
            return gps.filteredPosition;
        }
        
        // Calculate time delta
        const timeDelta = (now - gps.lastUpdateTime) / 1000; // seconds
        if (timeDelta < 0.1) return null; // Too frequent, skip
        
        // Calculate movement
        const distance = haversineDistance(
            gps.lastPosition.lat, gps.lastPosition.lng,
            rawLocation.lat, rawLocation.lng
        );
        
        // Detect if we're actually moving
        gps.movementSpeed = distance / timeDelta;
        gps.isMoving = gps.movementSpeed > 0.5; // Moving faster than 0.5 m/s
        
        // Apply sophisticated filtering
        const filtered = applyLocationFilter(rawLocation, gps, timeDelta);
        
        // Update GPS state
        gps.lastPosition = rawLocation;
        gps.filteredPosition = filtered;
        gps.lastUpdateTime = now;
        gps.lastAccuracy = rawLocation.accuracy;
        gps.quality = getGPSQuality(rawLocation.accuracy);
        
        // Maintain position history for trend analysis
        gps.positionHistory.push({
            ...filtered,
            timestamp: now
        });
        
        // Keep only last 10 positions
        if (gps.positionHistory.length > 10) {
            gps.positionHistory.shift();
        }
        
        console.log(` Filtered GPS: ${filtered.lat.toFixed(6)}, ${filtered.lng.toFixed(6)}, speed: ${gps.movementSpeed.toFixed(1)}m/s`);
        
        return filtered;
    }

    function applyLocationFilter(rawLocation, gps, timeDelta) {
        const lastFiltered = gps.filteredPosition;
        
        // If we haven't moved much and accuracy is poor, use more aggressive smoothing
        const accuracyFactor = Math.min(1, rawLocation.accuracy / 10);
        const movementFactor = Math.min(1, gps.movementSpeed / 2);
        
        // Adaptive smoothing based on movement and accuracy
        let smoothingFactor;
        if (gps.isMoving) {
            // When moving, be more responsive but still smooth
            smoothingFactor = 0.3 + (movementFactor * 0.4); // 0.3 to 0.7
        } else {
            // When stationary, apply heavy smoothing
            smoothingFactor = 0.1 + (accuracyFactor * 0.2); // 0.1 to 0.3
        }
        
        // Apply exponential smoothing
        const filtered = {
            lat: lastFiltered.lat + (rawLocation.lat - lastFiltered.lat) * smoothingFactor,
            lng: lastFiltered.lng + (rawLocation.lng - lastFiltered.lng) * smoothingFactor,
            accuracy: rawLocation.accuracy,
            speed: rawLocation.speed,
            timestamp: rawLocation.timestamp
        };
        
        return filtered;
    }

    function createPremiumLocationMarker(location) {
        console.log(' Creating premium location marker');
        
            const userIcon = L.divIcon({
                className: 'user-location-marker',
                html: `
                <div class="location-container" data-gps-quality="${AppState.gps.quality}" data-moving="${AppState.gps.isMoving}">
                    <div class="location-signal"></div>
                    <div class="location-signal"></div>
                    <div class="location-signal"></div>
                        <div class="location-accuracy"></div>
                    <div class="location-arrow">
                        <div class="location-center"></div>
                        </div>
                    </div>
                `,
            iconSize: [56, 56],
            iconAnchor: [28, 28]
            });

        AppState.userMarker = L.marker([location.lat, location.lng], {
                icon: userIcon,
                zIndexOffset: 1000
            }).addTo(AppState.map);
        
                 // Apply initial scaling
        setTimeout(() => {
            applyPremiumLocationTransform();
        }, 50);
        
        // Initialize direction indicator if orientation is available
        if (window.DeviceOrientationEvent && !AppState.needsOrientationPermission) {
            setTimeout(() => {
                if (window.orientation !== undefined) {
                    updatePremiumDirectionIndicator(window.orientation);
                }
            }, 100);
        }
        
        console.log(` Premium marker created at: ${location.lat.toFixed(6)}, ${location.lng.toFixed(6)}`);
    }

    function updatePremiumLocationMarker(location) {
        if (!AppState.userMarker) return;
        
        // Smooth animation to new position
        const currentLatLng = AppState.userMarker.getLatLng();
        const newLatLng = L.latLng(location.lat, location.lng);
        
        // Use smooth animation for position updates
        animateMarkerToPosition(AppState.userMarker, currentLatLng, newLatLng, 800);
        
        // Update marker attributes for visual states
        const container = AppState.userMarker.getElement()?.querySelector('.location-container');
        if (container) {
            container.setAttribute('data-gps-quality', AppState.gps.quality);
            container.setAttribute('data-moving', AppState.gps.isMoving.toString());
        }
        
        // Update accuracy visualization
        updatePremiumAccuracyDisplay(location.accuracy);
    }

    function animateMarkerToPosition(marker, fromLatLng, toLatLng, duration) {
        const startTime = Date.now();
        const startLat = fromLatLng.lat;
        const startLng = fromLatLng.lng;
        const deltaLat = toLatLng.lat - startLat;
        const deltaLng = toLatLng.lng - startLng;
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Use easing function for smooth movement
            const eased = easeOutCubic(progress);
            
            const currentLat = startLat + (deltaLat * eased);
            const currentLng = startLng + (deltaLng * eased);
            
            marker.setLatLng([currentLat, currentLng]);
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        }
        
        requestAnimationFrame(animate);
    }

    function updatePremiumDirectionIndicator(heading) {
        if (heading === null || heading === undefined) return;
        
        // Normalize heading to 0-360 range
        const normalizedHeading = ((heading % 360) + 360) % 360;
        
        // Apply sophisticated heading filtering
        const filteredHeading = filterHeading(normalizedHeading);
        
        if (filteredHeading === null) return;
        
        console.log(` Smooth heading: ${filteredHeading.toFixed(1)}`);
        
        // Apply smooth rotation
        if (AppState.userMarker) {
            const markerElement = AppState.userMarker.getElement();
            if (markerElement) {
                const arrow = markerElement.querySelector('.location-arrow');
                if (arrow) {
                    arrow.style.transform = `rotate(${filteredHeading}deg)`;
                }
                
                const container = markerElement.querySelector('.location-container');
                if (container) {
                    container.setAttribute('data-heading', filteredHeading.toFixed(0));
                }
            }
        }
    }

    function filterHeading(rawHeading) {
        const gps = AppState.gps;
        
        // Initialize heading history
        if (!gps.lastHeading) {
            gps.lastHeading = rawHeading;
            gps.filteredHeading = rawHeading;
            gps.headingHistory = [rawHeading];
            return rawHeading;
        }
        
        // Add to history
        gps.headingHistory.push(rawHeading);
        if (gps.headingHistory.length > 5) {
            gps.headingHistory.shift();
        }
        
        // Calculate heading difference (accounting for 360 wrap)
        const diff = ((rawHeading - gps.lastHeading + 540) % 360) - 180;
        
        // Apply different filtering based on movement
        let smoothingFactor;
        if (gps.isMoving) {
            // More responsive when moving
            smoothingFactor = Math.abs(diff) > 45 ? 0.7 : 0.4;
        } else {
            // Heavy smoothing when stationary
            smoothingFactor = Math.abs(diff) > 90 ? 0.3 : 0.1;
        }
        
        // Apply exponential smoothing with wrap-around handling
        let filteredHeading = gps.filteredHeading + (diff * smoothingFactor);
        filteredHeading = ((filteredHeading % 360) + 360) % 360;
        
        gps.lastHeading = rawHeading;
        gps.filteredHeading = filteredHeading;
        
        return filteredHeading;
    }

    function updatePremiumAccuracyDisplay(accuracy) {
        const accuracyElement = document.querySelector('.location-accuracy');
        if (!accuracyElement || !accuracy) return;
        
        // Sophisticated accuracy scaling
        const minScale = 0.4;
        const maxScale = 2.5;
        const scale = Math.min(maxScale, Math.max(minScale, accuracy / 8));
        
        // Smooth scale transition
            accuracyElement.style.transform = `scale(${scale})`;
        
        // Update opacity based on confidence
        const confidence = Math.max(0.2, Math.min(1, 1 - (accuracy / 30)));
        accuracyElement.style.opacity = confidence.toString();
    }

    function applyPremiumLocationTransform() {
        if (!AppState.userMarker) return;
        
        const zoom = AppState.map.getZoom();
        const scale = calculateZoomScale(zoom);
        const markerElement = AppState.userMarker.getElement();
        
        if (markerElement) {
            // Apply scale to the entire marker container (not individual elements)
            markerElement.style.transform = `scale(${scale})`;
            markerElement.style.transformOrigin = 'center center';
        }
    }

    // ========== UTILITY FUNCTIONS ==========

    function getGPSQuality(accuracy) {
        if (accuracy <= 3) return 'excellent';
        if (accuracy <= 8) return 'good';
        if (accuracy <= 20) return 'fair';
        return 'poor';
    }

    function haversineDistance(lat1, lng1, lat2, lng2) {
        const R = 6371000; // Earth's radius in meters
        const 1 = lat1 * Math.PI / 180;
        const 2 = lat2 * Math.PI / 180;
        const  = (lat2 - lat1) * Math.PI / 180;
        const  = (lng2 - lng1) * Math.PI / 180;

        const a = Math.sin( / 2) * Math.sin( / 2) +
                  Math.cos(1) * Math.cos(2) *
                  Math.sin( / 2) * Math.sin( / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
    }

    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }

    function isValidCoordinate(lat, lng) {
        return !isNaN(lat) && !isNaN(lng) && 
               lat >= -90 && lat <= 90 && 
               lng >= -180 && lng <= 180 &&
               (lat !== 0 || lng !== 0); // Reject null island
    }

    async function centerOnLocation() {
        // Request orientation permission if needed (iOS 13+)
        if (AppState.needsOrientationPermission) {
            try {
                const permission = await DeviceOrientationEvent.requestPermission();
                if (permission === 'granted') {
                    window.addEventListener('deviceorientation', handleDeviceOrientation);
                    AppState.needsOrientationPermission = false;
                }
            } catch (error) {
                console.error('Orientation permission denied');
            }
        }

        if (AppState.userLocation) {
            AppState.map.setView(AppState.userLocation, 18);
            showToast('Centered on your location', 'info');
            hapticFeedback(50);
        } else {
            showToast('Location not available', 'error');
        }
    }

    // Drawing functions
    function startDrawing() {
        if (AppState.measureMode) {
            toggleMeasureMode(null);
        }
        
        // Cancel structure placement if active
        if (AppState.addingStructure) {
            cancelStructurePlacement();
        }
        
        AppState.isDrawing = true;
        AppState.drawingPoints = [];
        document.getElementById('drawingUI').classList.add('active');
        document.getElementById('drawBtn').classList.add('active');
        updateDrawingStatus();
        hapticFeedback(50);
    }

    function handleMapClick(e) {
        if (AppState.isDrawing) {
            addDrawingPoint(e.latlng);
        } else if (AppState.refineMode) {
            // Ignore map clicks during refine mode - only marker dragging allowed
            return;
        } else if (AppState.addingStructure) {
            addStructure(e.latlng);
        } else if (AppState.measureMode) {
            addMeasurePoint(e.latlng);
        }
    }

    // Enhanced zoom-based visibility and scaling system
    function handleZoomChange() {
        const currentZoom = AppState.map.getZoom();
        const opacity = calculateZoomOpacity(currentZoom);
        const userScale = calculateZoomScale(currentZoom);
        const lineScale = calculateUtilityLineScale(currentZoom);
        
        console.log(` Zoom: ${currentZoom}, Opacity: ${opacity.toFixed(2)}, Line Scale: ${lineScale.toFixed(2)}`);
        
        // Apply to all utility lines with inverse scaling (thinner when zoomed out)
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                // Don't fade if currently highlighted/selected, in refine mode, or in excavation mode
                const isHighlighted = utility.lineLayer.options.className && 
                                    utility.lineLayer.options.className.includes('highlighted');
                const isBeingRefined = AppState.refineMode && 
                                     AppState.selectedUtilityData && 
                                     utility.id === AppState.selectedUtilityData.id;
                const isExcavationMode = AppState.excavationMode;
                const finalOpacity = (isHighlighted || isBeingRefined || isExcavationMode) ? 1.0 : opacity;
                
                // Base weight with inverse zoom scaling (thinner when zoomed out)
                const baseWeight = utility.lineType === 'main' ? 8 : 6;
                const scaledWeight = Math.max(1, baseWeight * lineScale); // Minimum of 1px
                
                utility.lineLayer.setStyle({ 
                    opacity: finalOpacity,
                    weight: scaledWeight
                });
                
                // Apply to connection markers
                if (utility.connectionMarkers) {
                    utility.connectionMarkers.forEach(marker => {
                        if (marker._icon) {
                            marker._icon.style.opacity = finalOpacity;
                        }
                    });
                }
            }
        });
        
        // Apply to all structure markers
        AppState.structures.forEach(structure => {
            if (structure.marker && structure.marker._icon) {
                const finalOpacity = AppState.excavationMode ? 1.0 : opacity;
                structure.marker._icon.style.opacity = finalOpacity;
            }
        });
        
        // Scale user location marker with premium transforms
        if (AppState.userMarker) {
            applyPremiumLocationTransform();
        }
        
        // Ensure refine markers are always fully visible
        if (AppState.refineMode && AppState.refineMarkers) {
            AppState.refineMarkers.forEach(marker => {
                if (marker._icon) {
                    marker._icon.style.opacity = 1.0;
                }
            });
        }
    }

    function calculateZoomOpacity(zoom) {
        // VERY AGGRESSIVE zoom-based fading:
        // 20+ (max zoom): 1.0 (fully visible)
        // 18-19 (street level): 0.7 (noticeable fade starts early)
        // 16-17 (building level): 0.4 (heavy fade)
        // 14-15 (block level): 0.15 (barely visible)
        // <14 (neighborhood+): 0.02 (almost invisible)
        
        if (zoom >= 20) {
            return 1.0; // Full visibility only at maximum zoom
        } else if (zoom >= 18) {
            return 0.7; // Start fading aggressively at street level
        } else if (zoom >= 16) {
            return 0.4; // Heavy fade at building level
        } else if (zoom >= 14) {
            return 0.15; // Barely visible at block level
        } else {
            return 0.02; // Almost completely invisible below zoom 14
        }
    }

    // Zoom-based scaling calculation for user location marker
    function calculateZoomScale(zoom) {
        // Responsive scaling - smaller at low zoom, larger at high zoom
        if (zoom >= 18) return 1.0;     // Full size at close zoom
        if (zoom >= 16) return 0.8;     // 80% size
        if (zoom >= 14) return 0.6;     // 60% size
        if (zoom >= 12) return 0.4;     // 40% size
        if (zoom >= 10) return 0.3;     // 30% size
        return 0.2;                     // 20% size at far zoom
    }

    // Utility line thickness scaling - thinner when zoomed out for cleaner appearance
    function calculateUtilityLineScale(zoom) {
        // Inverse scaling for utility lines - thinner at low zoom to reduce clutter
        if (zoom >= 20) return 1.0;     // Full thickness at max zoom
        if (zoom >= 18) return 0.9;     // Slightly thinner
        if (zoom >= 16) return 0.7;     // 70% thickness
        if (zoom >= 14) return 0.5;     // 50% thickness
        if (zoom >= 12) return 0.4;     // 40% thickness
        if (zoom >= 10) return 0.3;     // 30% thickness
        return 0.25;                    // Very thin at far zoom to prevent clutter
    }

    function addDrawingPoint(latlng) {
        AppState.drawingPoints.push(latlng);
        updateDrawingStatus();
        updateTempLine();
        hapticFeedback(30);

        // Check for nearby connections
        if (AppState.drawingPoints.length >= 1) {
            checkForNearbyConnections(latlng);
        }

        // Add a temporary marker for visual feedback
        const tempMarker = L.circleMarker(latlng, {
            radius: 6,
            fillColor: getUtilityColor(AppState.selectedUtility),
            fillOpacity: 1,
            color: 'white',
            weight: 2
        }).addTo(AppState.map);

        setTimeout(() => {
            AppState.map.removeLayer(tempMarker);
        }, 1000);
    }

    function updateDrawingStatus() {
        const status = document.getElementById('drawingStatus');
        const finishBtn = document.getElementById('finishDrawBtn');
        
        if (AppState.drawingPoints.length === 0) {
            status.textContent = 'Click points on the map';
            finishBtn.style.display = 'none';
        } else if (AppState.drawingPoints.length === 1) {
            status.textContent = 'Click to add more points';
            finishBtn.style.display = 'none';
        } else {
            status.textContent = `${AppState.drawingPoints.length} points added`;
            finishBtn.style.display = 'block';
        }
    }

    function updateTempLine() {
        if (AppState.tempLine) {
            AppState.map.removeLayer(AppState.tempLine);
        }

        if (AppState.drawingPoints.length > 1) {
            // Use current zoom scaling for consistent appearance
            const zoom = AppState.map.getZoom();
            const lineScale = calculateUtilityLineScale(zoom);
            const baseWeight = AppState.lineType === 'main' ? 8 : 6;
            const scaledWeight = Math.max(1, baseWeight * lineScale);
            
            AppState.tempLine = L.polyline(AppState.drawingPoints, {
                color: getUtilityColor(AppState.selectedUtility),
                weight: scaledWeight,
                opacity: 1.0, // Always fully visible during drawing
                dashArray: AppState.lineType === 'service' ? '15, 5' : null,
                className: 'utility-line drawing'
            }).addTo(AppState.map);
        }
    }

    function checkForNearbyConnections(currentPoint) {
        const threshold = 0.00009; // Approximately 10 meters
        AppState.connectionCandidate = null;

        // Check for nearby utilities of the same type
        AppState.utilities.forEach(utility => {
            if (utility.type === AppState.selectedUtility) {
                // For service lines, check if we can connect to a main
                if (AppState.lineType === 'service' && utility.lineType === 'main') {
                    // Check distance to any point on the main line
                    const closestPoint = getClosestPointOnLine(currentPoint, utility.points);
                    if (closestPoint.distance < threshold) {
                        AppState.connectionCandidate = {
                            utility: utility,
                            point: closestPoint.point,
                            type: 'main-to-service'
                        };
                    }
                } else if (utility.lineType === AppState.lineType) {
                    // Same line type - check endpoints only
                    const startPoint = utility.points[0];
                    const endPoint = utility.points[utility.points.length - 1];

                    if (getDistance(currentPoint, startPoint) < threshold) {
                        AppState.connectionCandidate = {
                            utility: utility,
                            point: startPoint,
                            type: 'endpoint'
                        };
                    } else if (getDistance(currentPoint, endPoint) < threshold) {
                        AppState.connectionCandidate = {
                            utility: utility,
                            point: endPoint,
                            type: 'endpoint'
                        };
                    }
                }
            }
        });

        // Check for nearby structures
        AppState.structures.forEach(structure => {
            if (structure.utilityType === AppState.selectedUtility) {
                if (getDistance(currentPoint, structure.latlng) < threshold) {
                    AppState.connectionCandidate = {
                        structure: structure,
                        point: structure.latlng,
                        type: 'structure'
                    };
                }
            }
        });
    }

    function getClosestPointOnLine(point, linePoints) {
        let minDistance = Infinity;
        let closestPoint = null;

        for (let i = 0; i < linePoints.length - 1; i++) {
            const projectedPoint = projectPointOnSegment(point, linePoints[i], linePoints[i + 1]);
            const distance = getDistance(point, projectedPoint);
            
            if (distance < minDistance) {
                minDistance = distance;
                closestPoint = projectedPoint;
            }
        }

        return { point: closestPoint, distance: minDistance };
    }

    function projectPointOnSegment(point, segStart, segEnd) {
        const A = point.lat - segStart.lat;
        const B = point.lng - segStart.lng;
        const C = segEnd.lat - segStart.lat;
        const D = segEnd.lng - segStart.lng;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
            param = dot / lenSq;
        }

        let lat, lng;

        if (param < 0) {
            lat = segStart.lat;
            lng = segStart.lng;
        } else if (param > 1) {
            lat = segEnd.lat;
            lng = segEnd.lng;
        } else {
            lat = segStart.lat + param * C;
            lng = segStart.lng + param * D;
        }

        return L.latLng(lat, lng);
    }

    function getDistance(point1, point2) {
        const lat1 = point1.lat || point1[0];
        const lng1 = point1.lng || point1[1];
        const lat2 = point2.lat || point2[0];
        const lng2 = point2.lng || point2[1];
        
        return Math.sqrt(Math.pow(lat2 - lat1, 2) + Math.pow(lng2 - lng1, 2));
    }

    function showConnectionDialog() {
        const dialog = document.getElementById('connectionDialog');
        dialog.classList.add('active');
        hapticFeedback(50);
    }

    function closeConnectionDialog(connect) {
        const dialog = document.getElementById('connectionDialog');
        dialog.classList.remove('active');
        
        if (connect && AppState.connectionCandidate) {
            // Snap to connection point
            const lastIndex = AppState.drawingPoints.length - 1;
            AppState.drawingPoints[lastIndex] = AppState.connectionCandidate.point;
            updateTempLine();
            hapticFeedback(30);
            
            // Finish drawing immediately after connecting
            finishDrawingWithConnection();
        }
        
        // Clear connection candidate
        AppState.connectionCandidate = null;
    }
    
    function finishDrawingWithConnection() {
        if (AppState.drawingPoints.length < 2) {
            showToast('Need at least 2 points', 'warning');
            return;
        }

        // Create utility data
        const utilityData = {
            id: generateId(),
            type: AppState.selectedUtility,
            lineType: AppState.lineType,
            points: [...AppState.drawingPoints],
            size: '',
            depth: '',
            material: '',
            condition: '',
            curbDistance: '',
            dateAdded: new Date().toISOString(),
            connections: [],
            notes: []
        };

        // Add connection info if connected
        if (AppState.connectionCandidate) {
            utilityData.connections.push({
                type: AppState.connectionCandidate.type,
                targetId: AppState.connectionCandidate.utility?.id || AppState.connectionCandidate.structure?.id,
                point: AppState.connectionCandidate.point
            });
        }

        // Add utility to state
        AppState.utilities.push(utilityData);

        // Create the utility line on map
        createUtilityLine(utilityData);

        // Save
        saveUtilities();

        // Show info modal for editing
        showInfoModal(utilityData);

        // Reset drawing state
        cancelDrawing();

        showToast('Utility line connected and added', 'success');
        hapticFeedback(100);
    }

    function finishDrawing() {
        if (AppState.drawingPoints.length < 2) {
            showToast('Need at least 2 points', 'warning');
            return;
        }

        // Check if we should show connection dialog
        if (AppState.connectionCandidate && AppState.drawingPoints.length > 0) {
            showConnectionDialog();
            return;
        }

        // Create utility data with pending status
        const utilityData = {
            id: generateId(),
            type: AppState.selectedUtility,
            lineType: AppState.lineType,
            points: [...AppState.drawingPoints],
            size: '',
            depth: '',
            material: '',
            condition: '',
            curbDistance: '',
            dateAdded: new Date().toISOString(),
            connections: [],
            notes: [],
            isLocal: true, // Mark as pending approval
            isApproved: false
        };

        // Add connection info if connected
        if (AppState.connectionCandidate) {
            utilityData.connections.push({
                type: AppState.connectionCandidate.type,
                targetId: AppState.connectionCandidate.utility?.id || AppState.connectionCandidate.structure?.id,
                point: AppState.connectionCandidate.point
            });
        }

        // Add utility to state
        AppState.utilities.push(utilityData);

        // Create the utility line on map
        createUtilityLine(utilityData);

        // Save to Firebase for admin approval
        saveUtilities();

        // Show info modal for editing
        showInfoModal(utilityData);

        // Reset drawing state
        cancelDrawing();

        // Don't show duplicate toast - saveUtilities() already shows one
        hapticFeedback(100);
    }

    function cancelDrawing() {
        AppState.isDrawing = false;
        AppState.drawingPoints = [];
        AppState.connectionCandidate = null;
        
        if (AppState.tempLine) {
            AppState.map.removeLayer(AppState.tempLine);
            AppState.tempLine = null;
        }

        document.getElementById('drawingUI').classList.remove('active');
        document.getElementById('drawBtn').classList.remove('active');
    }

    function createUtilityLine(utilityData) {
        // Use current zoom scaling for initial line creation
        const zoom = AppState.map.getZoom();
        const lineScale = calculateUtilityLineScale(zoom);
        const baseWeight = utilityData.lineType === 'main' ? 8 : 6;
        const scaledWeight = Math.max(1, baseWeight * lineScale);
        
        const line = L.polyline(utilityData.points, {
            color: getUtilityColor(utilityData.type),
            weight: scaledWeight,
            opacity: 1,
            dashArray: utilityData.lineType === 'service' ? '15, 5' : null,
            className: `utility-line ${utilityData.type} ${utilityData.lineType}`,
            interactive: true
        });

        // Enhanced mobile-first interaction handling
        let pressTimer;
        let longPress = false;
        let startTime = 0;
        let lastClickTime = 0;
        let startPos = null;
        let hasMoved = false;
        
        const startPress = (e) => {
            if (AppState.isDrawing || AppState.refineMode || AppState.addingStructure || AppState.measureMode) {
                return; // Don't interfere with other modes
            }
            
            // Prevent event bubbling and default behavior
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
            
            longPress = false;
            hasMoved = false;
            startTime = Date.now();
            
            // Enhanced touch position detection
            let clientX, clientY;
            
            if (e.type === 'touchstart') {
                // Try multiple ways to get touch coordinates
                if (e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0]) {
                    clientX = e.originalEvent.touches[0].clientX;
                    clientY = e.originalEvent.touches[0].clientY;
                } else if (e.touches && e.touches[0]) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.originalEvent && e.originalEvent.clientX !== undefined) {
                    clientX = e.originalEvent.clientX;
                    clientY = e.originalEvent.clientY;
                } else {
                    // Fallback to container point
                    const point = e.containerPoint || e.layerPoint;
                    if (point) {
                        clientX = point.x;
                        clientY = point.y;
                    } else {
                        console.warn('Could not determine touch position');
                        return;
                    }
                }
            } else {
                // Mouse event
                clientX = e.originalEvent ? e.originalEvent.clientX : e.clientX;
                clientY = e.originalEvent ? e.originalEvent.clientY : e.clientY;
            }
            
            startPos = { x: clientX, y: clientY };
            
            console.log(' Touch start detected on utility line', {
                type: e.type,
                position: startPos,
                utilityId: utilityData.id
            });
            
            // Start long press timer (shorter for better mobile UX)
            pressTimer = setTimeout(() => {
                if (!hasMoved) {
                    console.log(' Long press triggered!');
                    longPress = true;
                    hapticFeedback(100);
                    showInfoModal(utilityData);
                }
            }, 500); // Reduced from 600ms to 500ms
            
            // Highlight line on press
            line.setStyle({
                weight: (utilityData.lineType === 'main' ? 8 : 6) + 2,
                opacity: 0.8
            });
        };
        
        const movePress = (e) => {
            if (!startPos) return;
            
            // Enhanced touch position detection for move events
            let clientX, clientY;
            
            if (e.type === 'touchmove') {
                if (e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0]) {
                    clientX = e.originalEvent.touches[0].clientX;
                    clientY = e.originalEvent.touches[0].clientY;
                } else if (e.touches && e.touches[0]) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.originalEvent && e.originalEvent.clientX !== undefined) {
                    clientX = e.originalEvent.clientX;
                    clientY = e.originalEvent.clientY;
                } else {
                    const point = e.containerPoint || e.layerPoint;
                    if (point) {
                        clientX = point.x;
                        clientY = point.y;
                    } else {
                        return;
                    }
                }
            } else {
                clientX = e.originalEvent ? e.originalEvent.clientX : e.clientX;
                clientY = e.originalEvent ? e.originalEvent.clientY : e.clientY;
            }
            
            const currentPos = { x: clientX, y: clientY };
            
            // Check if moved more than 20px (increased threshold for mobile)
            const distance = Math.sqrt(
                Math.pow(currentPos.x - startPos.x, 2) + 
                Math.pow(currentPos.y - startPos.y, 2)
            );
            
            if (distance > 20) { // Increased from 10px to 20px for better mobile tolerance
                console.log(' Movement detected, cancelling long press', { distance });
                hasMoved = true;
                clearTimeout(pressTimer);
            }
        };
        
        const endPress = (e) => {
            const pressDuration = Date.now() - startTime;
            
            console.log(' Touch end detected', {
                type: e.type,
                duration: pressDuration,
                longPress,
                hasMoved,
                utilityId: utilityData.id
            });
            
            clearTimeout(pressTimer);
            
            // Reset line style to current zoom-appropriate weight
            const currentZoom = AppState.map.getZoom();
            const lineScale = calculateUtilityLineScale(currentZoom);
            const baseWeight = utilityData.lineType === 'main' ? 8 : 6;
            const scaledWeight = Math.max(1, baseWeight * lineScale);
            
            line.setStyle({
                weight: scaledWeight,
                opacity: 1
            });
            
            // Show quick info on short press without movement (if not a long press)
            if (!longPress && !hasMoved && pressDuration < 450 && pressDuration > 50) {
                const utilityName = `${capitalizeFirst(utilityData.type)} ${capitalizeFirst(utilityData.lineType)}`;
                const info = utilityData.size ? ` (${utilityData.size}")` : '';
                showToast(`${utilityName}${info} - Hold to edit`, 'info');
                hapticFeedback(30);
            }
            
            // Reset state
            startPos = null;
            hasMoved = false;
        };

        // Enhanced event handling for mobile with explicit touch support
        line.on('mousedown', startPress);
        line.on('touchstart', startPress);
        line.on('mousemove', movePress);
        line.on('touchmove', movePress);
        line.on('mouseup', endPress);
        line.on('touchend', endPress);
        line.on('mouseleave', endPress);
        line.on('touchcancel', endPress);
        
        // Additional debugging for mobile touch events
        if ('ontouchstart' in window) {
            console.log(' Touch support detected, utility line touch events registered for:', utilityData.id);
        }

        line.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
            
            // Handle double-tap to open modal (alternative to long press)
            const now = Date.now();
            if (now - lastClickTime < 300) {
                // Double tap detected
                if (!AppState.isDrawing && !AppState.refineMode && !AppState.addingStructure && !AppState.measureMode) {
                    showInfoModal(utilityData);
                    hapticFeedback(50);
                }
            }
            lastClickTime = now;
        });

        // Store reference
        utilityData.lineLayer = line;

        // Add to appropriate layer
        line.addTo(AppState.layers.utilities[utilityData.type]);

        // Apply current zoom-based opacity
        const opacity = calculateZoomOpacity(zoom);
        line.setStyle({ opacity: opacity });

        // Enhanced connection markers with animations
        if (utilityData.connections && utilityData.connections.length > 0) {
            utilityData.connections.forEach((conn, index) => {
                let markerClass = 'connection-marker';
                let radius = 8;
                let fillColor = 'white';
                
                if (conn.type === 'main-to-service') {
                    markerClass += ' t-junction';
                    radius = 10;
                    fillColor = '#f0f8ff';
                } else if (conn.type === 'endpoint') {
                    markerClass += ' endpoint';
                    radius = 8;
                    fillColor = '#fff5f5';
                } else if (conn.type === 'structure') {
                    markerClass += ' structure';
                    radius = 12;
                    fillColor = '#f0fff0';
                }
                
                const marker = L.circleMarker(conn.point, {
                    radius: radius,
                    fillColor: fillColor,
                    color: getUtilityColor(utilityData.type),
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 1,
                    className: `${markerClass} ${utilityData.type}`
                });
                
                // Add subtle animation delay for visual effect
                setTimeout(() => {
                marker.addTo(AppState.layers.utilities[utilityData.type]);
                }, index * 100);
                
                // Store connection marker reference
                if (!utilityData.connectionMarkers) {
                    utilityData.connectionMarkers = [];
                }
                utilityData.connectionMarkers.push(marker);
            });
        }
    }

    function getUtilityColor(type) {
        const colors = {
            water: '#00b4d8',
            gas: '#ffd60a',
            electric: '#ff006e',
            sewer: '#a8763e',
            telecom: '#b565d8'
        };
        return colors[type] || '#000000';
    }

    // Structure functions
    function toggleStructureMenu() {
        // If currently placing a structure, cancel it
        if (AppState.addingStructure) {
            cancelStructurePlacement();
            return;
        }
        
        const menu = document.getElementById('structureMenu');
        if (!menu) {
            console.error(' Structure menu element not found!');
            showToast('Structure menu not found', 'error');
            return;
        }
        
        const isActive = menu.classList.contains('active');
        
        if (isActive) {
            menu.classList.remove('active');
            console.log(' Structure menu closed');
        } else {
            menu.classList.add('active');
            console.log(' Structure menu opened, checking visibility...');
            
            // Debug menu visibility
            setTimeout(() => {
                const computedStyle = window.getComputedStyle(menu);
                console.log('Menu display:', computedStyle.display);
                console.log('Menu visibility:', computedStyle.visibility);
                console.log('Menu z-index:', computedStyle.zIndex);
                console.log('Menu position:', {
                    bottom: computedStyle.bottom,
                    right: computedStyle.right,
                    width: computedStyle.width,
                    height: computedStyle.height
                });
            }, 100);
            
            showToast(' Structure menu opened above green button', 'info');
        }
        
        hapticFeedback(30);
    }

    function startAddingStructure(structureType, utilityType) {
        console.log(' Starting to add structure:', { structureType, utilityType });
        
        AppState.addingStructure = true;
        AppState.structureToAdd = {
            type: structureType,
            utilityType: utilityType
        };
        
        // Close menu
        document.getElementById('structureMenu').classList.remove('active');
        
        // Add visual feedback to structure button
        document.getElementById('addStructureBtn').classList.add('active');
        
        // Change cursor to crosshair for better UX
        document.getElementById('map').style.cursor = 'crosshair';
        
        showToast(`Tap on map to place ${getStructureName(structureType)}`, 'success');
        hapticFeedback(50);
    }
    
    function getStructureName(structureType) {
        const names = {
            electricBox: 'Electric Box',
            catchBasin: 'Catch Basin',
            sewerManhole: 'Sewer Manhole',
            waterManhole: 'Water Manhole',
            gasManhole: 'Gas Manhole',
            gasValve: 'Gas Valve',
            hydrantValve: 'Hydrant',
            telecomBox: 'Telecom Box'
        };
        return names[structureType] || structureType;
    }

    function addStructure(latlng) {
        if (!AppState.structureToAdd) {
            console.warn(' No structure to add');
            return;
        }

        console.log(' Adding structure at:', latlng);

        const structureData = {
            id: generateId(),
            type: AppState.structureToAdd.type,
            utilityType: AppState.structureToAdd.utilityType,
            latlng: latlng,
            dateAdded: new Date().toISOString(),
            isLocal: true, // Mark as pending approval
            isApproved: false
        };

        // Add to state
        AppState.structures.push(structureData);

        // Create marker
        createStructureMarker(structureData);

        // Save to Firebase for admin approval
        saveStructures();

        // Reset cursor and state
        document.getElementById('map').style.cursor = '';
        document.getElementById('addStructureBtn').classList.remove('active');
        AppState.addingStructure = false;
        AppState.structureToAdd = null;

        const structureName = getStructureName(structureData.type);
        showToast(`${structureName} submitted for admin approval`, 'info');
        hapticFeedback(100);
        
        console.log(' Structure submitted for approval:', structureData);
    }
    
    function cancelStructurePlacement() {
        if (AppState.addingStructure) {
            console.log(' Cancelling structure placement');
            
            // Reset cursor and state
            document.getElementById('map').style.cursor = '';
            document.getElementById('addStructureBtn').classList.remove('active');
            AppState.addingStructure = false;
            AppState.structureToAdd = null;
            
            // Close menu if open
            document.getElementById('structureMenu').classList.remove('active');
            
            showToast('Structure placement cancelled', 'info');
            hapticFeedback(30);
        }
    }

    function createStructureMarker(structureData) {
        const icons = {
            electricBox: 'fa-bolt',
            catchBasin: 'fa-water',
            sewerManhole: 'fa-circle',
            waterManhole: 'fa-tint',
            gasManhole: 'fa-fire',
            gasValve: 'fa-wrench',
            hydrantValve: 'fa-fire-extinguisher',
            telecomBox: 'fa-network-wired'
        };

        const icon = L.divIcon({
            className: '',
            html: `<div class="structure-marker ${structureData.utilityType}">
                <i class="fas ${icons[structureData.type]}"></i>
            </div>`,
            iconSize: [48, 48],
            iconAnchor: [24, 24]
        });

        const marker = L.marker(structureData.latlng, { icon: icon });
        
        // Add click handler
        marker.on('click', () => {
            showStructureInfo(structureData);
        });

        // Store reference
        structureData.marker = marker;

        // Add to layer
        marker.addTo(AppState.layers.structures[structureData.utilityType]);

        // Apply current zoom-based opacity
        const currentZoom = AppState.map.getZoom();
        const opacity = calculateZoomOpacity(currentZoom);
        if (marker._icon) {
            marker._icon.style.opacity = opacity;
        }
    }

    function showStructureInfo(structureData) {
        const structureNames = {
            electricBox: 'Electrical Box',
            catchBasin: 'Catch Basin',
            sewerManhole: 'Sewer Manhole',
            waterManhole: 'Water Manhole',
            gasManhole: 'Gas Manhole',
            gasValve: 'Gas Valve',
            hydrantValve: 'Hydrant Valve',
            telecomBox: 'Telecom Box'
        };

        showToast(`${structureNames[structureData.type]}`, 'info');
    }

    // Info Modal functions
    function showInfoModal(utilityData) {
        console.log(' Opening info modal for utility:', utilityData?.id);
        AppState.selectedUtilityData = utilityData;
        
        // Update modal content
        document.getElementById('modalIcon').className = getUtilityIcon(utilityData.type);
        document.getElementById('modalIcon').style.color = getUtilityColor(utilityData.type);
        document.getElementById('modalTitle').textContent = `${capitalizeFirst(utilityData.type)} ${capitalizeFirst(utilityData.lineType)} Line`;
        
        document.getElementById('infoType').textContent = capitalizeFirst(utilityData.type);
        document.getElementById('infoLineType').textContent = capitalizeFirst(utilityData.lineType);
        document.getElementById('infoSize').textContent = utilityData.size ? `${utilityData.size}"` : 'Not specified';
        document.getElementById('infoDepth').textContent = utilityData.depth ? `${utilityData.depth}'` : 'Not specified';
        document.getElementById('infoMaterial').textContent = utilityData.material || 'Not specified';
        document.getElementById('infoCondition').textContent = utilityData.condition || 'Not specified';
        document.getElementById('infoCurbDistance').textContent = utilityData.curbDistance ? `${utilityData.curbDistance}'` : 'Not specified';
        document.getElementById('infoDate').textContent = new Date(utilityData.dateAdded).toLocaleDateString();

        // Load notes
        loadNotes(utilityData);

        // Show view mode, hide edit mode
        document.getElementById('viewMode').style.display = 'block';
        document.getElementById('editMode').classList.remove('active');

        // Show modal
        document.getElementById('infoModal').classList.add('active');
    }

    function closeInfoModal() {
        document.getElementById('infoModal').classList.remove('active');
        // Don't clear selectedUtilityData if we're entering refine mode
        if (!AppState.refineMode) {
        AppState.selectedUtilityData = null;
        }
    }

    function getUtilityIcon(type) {
        const icons = {
            water: 'fas fa-tint',
            gas: 'fas fa-fire',
            electric: 'fas fa-bolt',
            sewer: 'fas fa-toilet',
            telecom: 'fas fa-phone'
        };
        return icons[type] || 'fas fa-question';
    }

    function capitalizeFirst(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function enterEditMode() {
        if (!AppState.selectedUtilityData) return;

        // Populate edit form
        document.getElementById('editSize').value = AppState.selectedUtilityData.size || '';
        document.getElementById('editDepth').value = AppState.selectedUtilityData.depth || '';
        document.getElementById('editMaterial').value = AppState.selectedUtilityData.material || '';
        document.getElementById('editCondition').value = AppState.selectedUtilityData.condition || '';
        document.getElementById('editCurbDistance').value = AppState.selectedUtilityData.curbDistance || '';

        // Show edit mode, hide view mode
        document.getElementById('viewMode').style.display = 'none';
        document.getElementById('editMode').classList.add('active');
    }

    function exitEditMode() {
        // Show view mode, hide edit mode
        document.getElementById('viewMode').style.display = 'block';
        document.getElementById('editMode').classList.remove('active');
    }

    async function saveEdit() {
        if (!AppState.selectedUtilityData) return;

        // Get and validate input values
        const size = document.getElementById('editSize').value.trim();
        const depth = document.getElementById('editDepth').value.trim();
        const material = document.getElementById('editMaterial').value.trim();
        const condition = document.getElementById('editCondition').value.trim();
        const curbDistance = document.getElementById('editCurbDistance').value.trim();

        // Validate numeric inputs
        if (size && (isNaN(size) || parseFloat(size) < 0)) {
            showToast('Size must be a positive number', 'error');
            return;
        }
        if (depth && (isNaN(depth) || parseFloat(depth) < 0)) {
            showToast('Depth must be a positive number', 'error');
            return;
        }
        if (curbDistance && (isNaN(curbDistance) || parseFloat(curbDistance) < 0)) {
            showToast('Curb distance must be a positive number', 'error');
            return;
        }

        // Update utility data
        AppState.selectedUtilityData.size = size;
        AppState.selectedUtilityData.depth = depth;
        AppState.selectedUtilityData.material = material;
        AppState.selectedUtilityData.condition = condition;
        AppState.selectedUtilityData.curbDistance = curbDistance;

        try {
            // Save changes - saveUtilities() will show its own success/error message
            await saveUtilities();
            
            // Exit edit mode and refresh display only if save succeeded
        exitEditMode();
        showInfoModal(AppState.selectedUtilityData);
        
            // Don't show duplicate toast - saveUtilities already shows one
        hapticFeedback(50);
        } catch (error) {
            console.error('Error saving edits:', error);
            showToast('Error saving changes', 'error');
        }
    }

    // Notes functions
    function loadNotes(utilityData) {
        const notesList = document.getElementById('notesList');
        notesList.innerHTML = '';
        
        if (utilityData.notes && utilityData.notes.length > 0) {
            utilityData.notes.forEach((note, index) => {
                const noteItem = document.createElement('div');
                noteItem.className = 'note-item';
                noteItem.innerHTML = `
                    <p class="note-text">${note.text}</p>
                    <span class="note-date">${new Date(note.date).toLocaleString()}</span>
                    <button class="note-delete" onclick="deleteNote(${index})">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                notesList.appendChild(noteItem);
            });
        } else {
            notesList.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">No notes yet</p>';
        }
    }

    function showNoteInput() {
        document.getElementById('noteInputModal').classList.add('active');
        document.getElementById('noteTextarea').focus();
    }

    function hideNoteInput() {
        document.getElementById('noteInputModal').classList.remove('active');
        document.getElementById('noteTextarea').value = '';
    }

    function saveNote() {
        const noteText = document.getElementById('noteTextarea').value.trim();
        
        if (!noteText) {
            showToast('Please enter a note', 'warning');
            return;
        }
        
        if (noteText.length > 1000) {
            showToast('Note is too long (max 1000 characters)', 'error');
            return;
        }
        
        if (!AppState.selectedUtilityData) {
            showToast('No utility selected', 'error');
            return;
        }
        
        if (!AppState.selectedUtilityData.notes) {
            AppState.selectedUtilityData.notes = [];
        }
        
        AppState.selectedUtilityData.notes.push({
            text: noteText,
            date: new Date().toISOString()
        });
        
        saveUtilities();
        loadNotes(AppState.selectedUtilityData);
        hideNoteInput();
        showToast('Note added', 'success');
        hapticFeedback(50);
    }

    function deleteNote(index) {
        if (!AppState.selectedUtilityData || !AppState.selectedUtilityData.notes) return;
        
        AppState.selectedUtilityData.notes.splice(index, 1);
        saveUtilities();
        loadNotes(AppState.selectedUtilityData);
        showToast('Note deleted', 'success');
    }

    window.deleteNote = deleteNote;

    // Premium Refine Location - Completely Rebuilt for Reliability
    function startRefineLocation() {
        if (!AppState.selectedUtilityData) {
            console.error(' No selectedUtilityData found');
            showToast('No utility selected for refining', 'error');
            return;
        }

        console.log(' Starting refine mode for utility:', AppState.selectedUtilityData.id);
        
        // Store reference to prevent accidental clearing
        const utilityToRefine = AppState.selectedUtilityData;
        
        // Cancel any other active modes
        if (AppState.addingStructure) {
            cancelStructurePlacement();
        }
        
        // Set refine mode FIRST
        AppState.refineMode = true;
        AppState.refineMarkers = [];
        
        // Close modal and show overlay
        closeInfoModal();

        // Ensure selectedUtilityData is still available
        AppState.selectedUtilityData = utilityToRefine;
        
        document.getElementById('refineOverlay').classList.add('active');

        // Highlight the utility line
        if (AppState.selectedUtilityData.lineLayer) {
            AppState.selectedUtilityData.lineLayer.setStyle({
                weight: AppState.selectedUtilityData.lineType === 'main' ? 12 : 10,
                opacity: 1,
                className: `utility-line ${AppState.selectedUtilityData.type} ${AppState.selectedUtilityData.lineType} highlighted`
            });
        }

        // Create simple, numbered refine markers
        const points = AppState.selectedUtilityData.points;
        points.forEach((point, index) => {
            createRefineMarker(point, index, false); // false = vertex marker
        });
        
        // Create intermediate markers for adding new points
        for (let i = 0; i < points.length - 1; i++) {
            const start = points[i];
            const end = points[i + 1];
            const midPoint = L.latLng(
                (start.lat + end.lat) / 2,
                (start.lng + end.lng) / 2
            );
            createRefineMarker(midPoint, i + 0.5, true); // true = intermediate marker
        }

        // Zoom to utility
        const bounds = L.latLngBounds(points);
        AppState.map.fitBounds(bounds, { 
            padding: [100, 100],
            maxZoom: 20
        });

        showToast(`Refine mode active - ${points.length} points to adjust. Drag + markers to add new points!`, 'success');
        hapticFeedback(100);
    }

    function createRefineMarker(latlng, index, isIntermediate = false) {
        const isVertex = !isIntermediate;
        
        const marker = L.marker(latlng, {
            icon: L.divIcon({
                className: 'refine-marker',
                html: isVertex 
                    ? `<div class="refine-point" title="Point ${Math.floor(index) + 1} - Drag to move">${Math.floor(index) + 1}</div>`
                    : `<div class="refine-point intermediate" title="Drag to create new point" style="width: 28px; height: 28px; font-size: 12px; background: linear-gradient(135deg, #e6f3ff 0%, #cce7ff 100%); border-color: #4d94ff;">+</div>`,
                iconSize: isVertex ? [40, 40] : [28, 28],
                iconAnchor: isVertex ? [20, 20] : [14, 14]
            }),
            draggable: true,
            zIndexOffset: isVertex ? 10000 : 9500
        });

        // Store marker properties
        marker.pointIndex = index;
        marker.utilityId = AppState.selectedUtilityData.id;
        marker.isIntermediate = isIntermediate;
        marker.originalPosition = L.latLng(latlng.lat, latlng.lng);

        // Enhanced drag events for mobile
        let isDragging = false;
        
        marker.on('dragstart', (e) => {
            isDragging = true;
            const displayIndex = isVertex ? Math.floor(index) + 1 : 'new';
            console.log(` Starting drag of ${isVertex ? 'point' : 'intermediate'} ${displayIndex}`);
            
            // Visual feedback
            if (marker._icon) {
                const pointElement = marker._icon.querySelector('.refine-point');
                if (pointElement) {
                    pointElement.classList.add('dragging');
                }
            }
            
            // Disable map dragging
            AppState.map.dragging.disable();
            AppState.map.scrollWheelZoom.disable();
            
            const message = isVertex ? `Moving point ${displayIndex}` : 'Creating new point';
            showToast(message, 'info');
            hapticFeedback(50);
        });

        marker.on('drag', (e) => {
            if (!isDragging) return;
            
            // Update the line in real-time
                updateRefinedLine();
            hapticFeedback(5);
        });

        marker.on('dragend', (e) => {
                isDragging = false;
            const displayIndex = isVertex ? Math.floor(index) + 1 : 'new';
            console.log(` Finished drag of ${isVertex ? 'point' : 'intermediate'} ${displayIndex}`);
            
            // Check if intermediate marker should become vertex
            if (isIntermediate) {
                const currentPos = marker.getLatLng();
                const distance = currentPos.distanceTo(marker.originalPosition);
                
                if (distance > 10) { // 10 meters threshold to create new vertex
                    console.log(' Converting intermediate marker to vertex');
                    convertIntermediateToVertex(marker);
                    showToast('New point created!', 'success');
                    hapticFeedback(100);
                } else {
                    // If not moved far enough, snap back to middle
                    marker.setLatLng(marker.originalPosition);
                }
            }
            
            // Visual feedback reset
            if (marker._icon) {
                const pointElement = marker._icon.querySelector('.refine-point');
                if (pointElement) {
                    pointElement.classList.remove('dragging');
                }
            }
            
            // Re-enable map interactions
            setTimeout(() => {
                AppState.map.dragging.enable();
                AppState.map.scrollWheelZoom.enable();
            }, 100);
            
            // Final line update
            updateRefinedLine();
                hapticFeedback(30);
        });

        // Add to map and store reference
        marker.addTo(AppState.map);
        AppState.refineMarkers.push(marker);
        
        console.log(` Created ${isVertex ? 'vertex' : 'intermediate'} marker ${index} at`, latlng);
    }

    function convertIntermediateToVertex(intermediateMarker) {
        const insertAfterIndex = Math.floor(intermediateMarker.pointIndex);
        
        // Convert the marker to a vertex
        intermediateMarker.isIntermediate = false;
        intermediateMarker.pointIndex = insertAfterIndex + 1;
        
        // Update all subsequent vertex markers' indices
        AppState.refineMarkers.forEach(marker => {
            if (!marker.isIntermediate && marker !== intermediateMarker && marker.pointIndex > insertAfterIndex) {
                marker.pointIndex += 1;
                
                // Update the visual number
                if (marker._icon) {
                    const pointElement = marker._icon.querySelector('.refine-point');
                    if (pointElement && !pointElement.classList.contains('intermediate')) {
                        pointElement.textContent = Math.floor(marker.pointIndex) + 1;
                        pointElement.title = `Point ${Math.floor(marker.pointIndex) + 1} - Drag to move`;
                    }
                }
            }
        });
        
        // Update the converted marker's appearance
        const newIcon = L.divIcon({
            className: 'refine-marker',
            html: `<div class="refine-point" title="Point ${Math.floor(intermediateMarker.pointIndex) + 1} - Drag to move">${Math.floor(intermediateMarker.pointIndex) + 1}</div>`,
            iconSize: [40, 40],
            iconAnchor: [20, 20]
        });
        intermediateMarker.setIcon(newIcon);
        intermediateMarker.setZIndexOffset(10000);
        
        // Recreate intermediate markers between all vertices
        recreateIntermediateMarkers();
        
        console.log(' Updated marker indices and recreated intermediates');
    }

    function recreateIntermediateMarkers() {
        // Remove all existing intermediate markers
        const intermediateMarkers = AppState.refineMarkers.filter(m => m.isIntermediate);
        intermediateMarkers.forEach(marker => {
            AppState.map.removeLayer(marker);
        });
        
        // Remove them from the array
        AppState.refineMarkers = AppState.refineMarkers.filter(m => !m.isIntermediate);
        
        // Get all vertex markers sorted by index
        const vertexMarkers = AppState.refineMarkers
            .filter(m => !m.isIntermediate)
            .sort((a, b) => a.pointIndex - b.pointIndex);
        
        // Create new intermediate markers between each pair of vertices
        for (let i = 0; i < vertexMarkers.length - 1; i++) {
            const start = vertexMarkers[i].getLatLng();
            const end = vertexMarkers[i + 1].getLatLng();
            const midPoint = L.latLng(
                (start.lat + end.lat) / 2,
                (start.lng + end.lng) / 2
            );
            
            createRefineMarker(midPoint, vertexMarkers[i].pointIndex + 0.5, true);
        }
    }

    function updateRefinedLine() {
        if (!AppState.selectedUtilityData || !AppState.selectedUtilityData.lineLayer || !AppState.refineMode) {
            return;
        }

        try {
            // Get current positions from vertex markers only, sorted by index
            const currentPoints = AppState.refineMarkers
                .filter(marker => !marker.isIntermediate)
                .sort((a, b) => a.pointIndex - b.pointIndex)
                .map(marker => marker.getLatLng());
            
            if (currentPoints.length >= 2) {
                // Update the line on the map
                AppState.selectedUtilityData.lineLayer.setLatLngs(currentPoints);
                console.log(` Updated line with ${currentPoints.length} vertex points`);
            }
        } catch (error) {
            console.error('Error updating refined line:', error);
        }
    }

    function finishRefining() {
        console.log(' Checking refine state:', {
            selectedUtilityData: !!AppState.selectedUtilityData,
            refineMode: AppState.refineMode,
            markersCount: AppState.refineMarkers?.length || 0
        });
        
        if (!AppState.selectedUtilityData) {
            console.error(' No selectedUtilityData available');
            showToast('No utility data available for refining', 'error');
            return;
        }
        
        if (!AppState.refineMode) {
            console.error(' Refine mode not active');
            showToast('Refine mode not active', 'warning');
            return;
        }

        try {
            console.log(' Finishing refine mode...');
            
            // Get final positions from vertex markers only
            const finalPoints = AppState.refineMarkers
                .filter(marker => !marker.isIntermediate)
                .sort((a, b) => a.pointIndex - b.pointIndex)
                .map(marker => marker.getLatLng());

            if (finalPoints.length >= 2) {
                // Update utility data
                AppState.selectedUtilityData.points = [...finalPoints];
                console.log(` Updated utility with ${finalPoints.length} points`);
            }
            
            // Clean up refine markers
            AppState.refineMarkers.forEach((marker, index) => {
                if (AppState.map.hasLayer(marker)) {
            AppState.map.removeLayer(marker);
                }
        });

            // Reset line styling
        if (AppState.selectedUtilityData.lineLayer) {
            AppState.selectedUtilityData.lineLayer.setStyle({
                    weight: AppState.selectedUtilityData.lineType === 'main' ? 8 : 6,
                    opacity: 1,
                className: `utility-line ${AppState.selectedUtilityData.type} ${AppState.selectedUtilityData.lineType}`
            });
                
                // Ensure line is updated with final points
                AppState.selectedUtilityData.lineLayer.setLatLngs(AppState.selectedUtilityData.points);
        }

            // Clear refine state
        AppState.refineMode = false;
        AppState.refineMarkers = [];
        
        // Hide overlay
        document.getElementById('refineOverlay').classList.remove('active');

            // Re-enable map interactions
            AppState.map.dragging.enable();
            AppState.map.scrollWheelZoom.enable();

            // Save changes
        saveUtilities();

            showToast(' Location refined and saved!', 'success');
            hapticFeedback(200);
            
            console.log(' Refine mode completed successfully');
            
        } catch (error) {
            console.error(' Error finishing refining:', error);
            showToast('Error saving refined location', 'error');
            
            // Emergency cleanup
            AppState.refineMode = false;
            AppState.refineMarkers.forEach(marker => {
                try {
                    if (AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                } catch (e) { /* ignore */ }
            });
            AppState.refineMarkers = [];
            document.getElementById('refineOverlay').classList.remove('active');
            AppState.map.dragging.enable();
            AppState.map.scrollWheelZoom.enable();
        }
    }

    function deleteUtility() {
        if (!AppState.selectedUtilityData) return;

        if (confirm('Are you sure you want to delete this utility line?')) {
            // Remove from map
            if (AppState.selectedUtilityData.lineLayer) {
                AppState.map.removeLayer(AppState.selectedUtilityData.lineLayer);
            }
            
            // Remove connection markers if they exist
            if (AppState.selectedUtilityData.connectionMarkers) {
                AppState.selectedUtilityData.connectionMarkers.forEach(marker => {
                    if (AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                });
            }

            // Remove from state
            const index = AppState.utilities.findIndex(u => u.id === AppState.selectedUtilityData.id);
            if (index > -1) {
                AppState.utilities.splice(index, 1);
            }

            saveUtilities();
            syncToCloud();
            closeInfoModal();
            showToast('Utility deleted', 'success');
            hapticFeedback(50);
        }
    }

    // Excavation Mode
    function toggleExcavationMode() {
        if (AppState.excavationMode) {
            exitExcavationMode();
        } else {
            enterExcavationMode();
        }
    }

    function enterExcavationMode() {
        console.log('Entering excavation mode...');
        
        AppState.excavationMode = true;
        document.getElementById('excavationBtn').classList.add('active');
        document.getElementById('excavationOverlay').classList.add('active');

        // Enhanced utility visibility during excavation
        enhanceUtilityVisibilityForExcavation();
        
        // Initialize toggle state
        const toggleBtn = document.getElementById('alertToggleBtn');
        const toggleIcon = toggleBtn.querySelector('i');
        if (AppState.proximityAlertsVisible) {
            toggleBtn.classList.remove('alerts-hidden');
            toggleIcon.className = 'fas fa-eye';
            toggleBtn.title = 'Hide proximity alerts';
        } else {
            toggleBtn.classList.add('alerts-hidden');
            toggleIcon.className = 'fas fa-eye-slash';
            toggleBtn.title = 'Show proximity alerts';
            document.getElementById('proximityAlerts').classList.add('hidden');
        }

        // Check if user location is available
        if (!AppState.userLocation) {
            console.log('User location not available, requesting location...');
            showToast('Getting your location for excavation mode...', 'info');
            
            // Try to get current location
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        const { latitude, longitude } = position.coords;
                        AppState.userLocation = [latitude, longitude];
                        console.log('Got user location:', AppState.userLocation);
                        
                        // Update user marker if it exists
                        if (AppState.userMarker) {
                            AppState.userMarker.setLatLng([latitude, longitude]);
                        }
                        
                        // Zoom to location and start checking
            AppState.map.setView(AppState.userLocation, 20);
                        checkProximity();
                        showExcavationModeStatus();
                    },
                    error => {
                        console.error('Location error:', error);
                        showToast('Location required for excavation mode. Please enable location services.', 'error');
                        exitExcavationMode();
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
                );
            } else {
                showToast('Location services not available', 'error');
                exitExcavationMode();
                return;
            }
        } else {
            console.log('Using existing user location:', AppState.userLocation);
            // Zoom to user location
            AppState.map.setView(AppState.userLocation, 20);
            
            // Start proximity checking immediately
        checkProximity();
            showExcavationModeStatus();
        }

        // Start periodic proximity checking
        AppState.proximityInterval = setInterval(checkProximity, 2000); // Check every 2 seconds

        console.log('Excavation mode setup complete', {
            userLocation: AppState.userLocation,
            utilitiesCount: AppState.utilities.length,
            intervalId: AppState.proximityInterval
        });

        // Strong haptic feedback
        hapticFeedback(200);
        setTimeout(() => hapticFeedback(200), 200);
        setTimeout(() => hapticFeedback(200), 400);
    }

    function showExcavationModeStatus() {
        const utilitiesCount = AppState.utilities.length;
        if (utilitiesCount === 0) {
            showToast('Excavation mode active - No utilities mapped yet', 'warning');
            console.log('No utilities available for proximity checking');
        } else {
            showToast(`Excavation mode active - Monitoring ${utilitiesCount} utilities`, 'warning');
        }
    }

    // Debug function to create test utilities for testing excavation mode
    function createTestUtility(offsetLat = 0.0001, offsetLng = 0.0001) {
        if (!AppState.userLocation) {
            console.log('Cannot create test utility - no user location');
            return;
        }

        const testUtility = {
            id: generateId(),
            type: 'water',
            lineType: 'main',
            points: [
                L.latLng(AppState.userLocation[0] + offsetLat, AppState.userLocation[1] + offsetLng),
                L.latLng(AppState.userLocation[0] + offsetLat + 0.0001, AppState.userLocation[1] + offsetLng + 0.0001)
            ],
            size: '8',
            depth: '4',
            material: 'Cast Iron',
            condition: 'Good',
            curbDistance: '6',
            dateAdded: new Date().toISOString(),
            connections: [],
            notes: []
        };

        AppState.utilities.push(testUtility);
        createUtilityLine(testUtility);
        saveUtilities();
        
        console.log('Created test utility:', testUtility);
        return testUtility;
    }

    // Make debug function available globally for testing
    window.createTestUtility = createTestUtility;
    
    // Quick Test Function for New Refine Feature
    function createTestUtilityForRefining() {
        try {
            if (AppState.utilities.length > 0) {
                console.log(' Opening first utility for testing refine...');
                showInfoModal(AppState.utilities[0]);
                return AppState.utilities[0];
            }
            
            let testLocation;
            if (AppState.userLocation) {
                testLocation = AppState.userLocation;
            } else {
                testLocation = [40.7128, -74.0060]; // Default NYC
            }
            
            console.log(' Creating test utility for refining at:', testLocation);
            
            const testUtility = {
                id: generateId(),
                type: 'water',
                lineType: 'main',
                points: [
                    L.latLng(testLocation[0] - 0.0003, testLocation[1] - 0.0003),
                    L.latLng(testLocation[0] + 0.0003, testLocation[1] + 0.0003)
                ],
                size: '8',
                depth: '4',
                material: 'Cast Iron',
                condition: 'Good',
                curbDistance: '6',
                dateAdded: new Date().toISOString(),
                connections: [],
                notes: []
            };

            AppState.utilities.push(testUtility);
            createUtilityLine(testUtility);
            saveUtilities();
            
            console.log(' Test utility created with 2 points for refining');
            showToast(' Test utility created! Long press line  Edit  Refine. Drag + to add points!', 'success');
            
            // Zoom to the test utility
            const bounds = L.latLngBounds(testUtility.points);
            AppState.map.fitBounds(bounds, { padding: [80, 80] });
            
            return testUtility;
        } catch (error) {
            console.error(' Error creating test utility:', error);
            showToast('Error creating test utility', 'error');
            return null;
        }
    }
    
    // Make it available globally for testing
    window.createTestUtilityForRefining = createTestUtilityForRefining;

    function exitExcavationMode() {
        AppState.excavationMode = false;
        document.getElementById('excavationBtn').classList.remove('active');
        document.getElementById('excavationOverlay').classList.remove('active');

        // Reset utility visibility
        resetUtilityVisibilityFromExcavation();

        // Clear proximity alerts and reset visibility
        clearProximityAlerts();
        document.getElementById('proximityAlerts').classList.remove('hidden');

        // Stop proximity checking
        if (AppState.proximityInterval) {
            clearInterval(AppState.proximityInterval);
        }

        showToast('Excavation mode deactivated', 'info');
        hapticFeedback(50);
    }

    function checkProximity() {
        if (!AppState.userLocation || !AppState.excavationMode) {
            console.log('Proximity check skipped:', {
                userLocation: !!AppState.userLocation,
                excavationMode: AppState.excavationMode
            });
            return;
        }

        const alertsContainer = document.getElementById('proximityAlerts');
        const radius = 15; // 15 feet in meters
        const radiusMeters = radius * 0.3048;

        console.log('Checking proximity:', {
            userLocation: AppState.userLocation,
            radiusMeters: radiusMeters,
            utilitiesCount: AppState.utilities.length
        });

        // Track which utilities are in range
        const inRangeUtilities = new Set();

        // Check each utility
        AppState.utilities.forEach((utility, index) => {
            // Skip if utility is not visible
            if (!AppState.layers.visibility[utility.type] || 
                !AppState.layers.visibility[utility.lineType]) {
                console.log(`Utility ${index} skipped - not visible:`, {
                    type: utility.type,
                    lineType: utility.lineType,
                    typeVisible: AppState.layers.visibility[utility.type],
                    lineTypeVisible: AppState.layers.visibility[utility.lineType]
                });
                return;
            }

            // Calculate distance to utility line
            const distance = calculateDistanceToLine(AppState.userLocation, utility.points);
            
            console.log(`Utility ${index} distance:`, {
                id: utility.id,
                type: utility.type,
                lineType: utility.lineType,
                distance: distance,
                radiusMeters: radiusMeters,
                inRange: distance <= radiusMeters
            });
            
            if (distance <= radiusMeters) {
                inRangeUtilities.add(utility.id);
                
                // Check if already alerted and not dismissed
                const alertId = `alert-${utility.id}`;
                const existingAlert = document.getElementById(alertId);
                const dismissedTime = AppState.dismissedAlerts.get(utility.id);
                
                if (dismissedTime) {
                    // Check if 3 minutes have passed
                    if (Date.now() - dismissedTime < 180000) {
                        console.log(`Alert for ${utility.id} dismissed recently`);
                        return;
                    }
                    AppState.dismissedAlerts.delete(utility.id);
                }

                if (!existingAlert) {
                    console.log(`Creating new proximity alert for utility ${utility.id}`);
                    createProximityAlert(utility, distance);
                } else {
                    console.log(`Updating existing alert for utility ${utility.id}`);
                    updateProximityAlert(utility, distance);
                }
            }
        });

        console.log('In-range utilities:', Array.from(inRangeUtilities));

        // Handle alerts for utilities that are out of range
        AppState.alertTimeouts.forEach((timeout, utilityId) => {
            if (!inRangeUtilities.has(utilityId)) {
                // Start or continue timeout
                if (!timeout) {
                    AppState.alertTimeouts.set(utilityId, Date.now());
                }
            } else {
                // In range again, clear timeout
                AppState.alertTimeouts.delete(utilityId);
            }
        });

        // Remove alerts that have been out of range for 45 seconds
        AppState.alertTimeouts.forEach((startTime, utilityId) => {
            if (Date.now() - startTime > 45000) {
                removeProximityAlert(utilityId);
                AppState.alertTimeouts.delete(utilityId);
            }
        });
    }

    function calculateDistanceToLine(point, linePoints) {
        let minDistance = Infinity;

        for (let i = 0; i < linePoints.length - 1; i++) {
            const distance = distanceToLineSegment(point, linePoints[i], linePoints[i + 1]);
            minDistance = Math.min(minDistance, distance);
        }

        return minDistance;
    }

    function distanceToLineSegment(point, lineStart, lineEnd) {
        const startLat = lineStart.lat || lineStart[0];
        const startLng = lineStart.lng || lineStart[1];
        const endLat = lineEnd.lat || lineEnd[0];
        const endLng = lineEnd.lng || lineEnd[1];

        const A = point[0] - startLat;
        const B = point[1] - startLng;
        const C = endLat - startLat;
        const D = endLng - startLng;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
            param = dot / lenSq;
        }

        let closestLat, closestLng;

        if (param < 0) {
            // Closest point is the start of the segment
            closestLat = startLat;
            closestLng = startLng;
        } else if (param > 1) {
            // Closest point is the end of the segment
            closestLat = endLat;
            closestLng = endLng;
        } else {
            // Closest point is somewhere along the segment
            closestLat = startLat + param * C;
            closestLng = startLng + param * D;
        }

        // Calculate distance using Haversine formula for better accuracy
        const R = 6371000; // Earth's radius in meters
        const 1 = point[0] * Math.PI / 180;
        const 2 = closestLat * Math.PI / 180;
        const  = (closestLat - point[0]) * Math.PI / 180;
        const  = (closestLng - point[1]) * Math.PI / 180;

        const a = Math.sin( / 2) * Math.sin( / 2) +
                  Math.cos(1) * Math.cos(2) *
                  Math.sin( / 2) * Math.sin( / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c; // Distance in meters
    }

    function createProximityAlert(utility, distance) {
        // Don't create alerts if they're hidden
        if (!AppState.proximityAlertsVisible) {
            return;
        }
        
        const alertsContainer = document.getElementById('proximityAlerts');
        const alertId = `alert-${utility.id}`;

        const alertDiv = document.createElement('div');
        alertDiv.id = alertId;
        alertDiv.className = `proximity-alert ${utility.type}`;
        alertDiv.innerHTML = `
            <div class="alert-content">
                <div class="alert-header">
                    <div class="alert-icon-container ${utility.type}">
                        <i class="${getUtilityIcon(utility.type)}" aria-hidden="true"></i>
                    </div>
                    <button class="alert-close" onclick="dismissProximityAlert('${utility.id}')" aria-label="Dismiss alert">
                        <i class="fas fa-times" aria-hidden="true"></i>
                    </button>
                    </div>
                
                <div class="alert-utility-info">
                    <h3 class="alert-utility-type">${utility.type}</h3>
                    <p class="alert-line-type">${utility.lineType} Line</p>
                </div>
                
                <div class="alert-distance-banner">
                    <span class="distance-value">${Math.round(distance / 0.3048)}</span>
                    <span class="distance-unit">FEET AWAY</span>
            </div>
                
                <div class="alert-details">
                    <div class="detail-item">
                        <span class="detail-label">Size</span>
                        <span class="detail-value">${utility.size ? utility.size + '"' : 'N/A'}</span>
                </div>
                    <div class="detail-item">
                        <span class="detail-label">Depth</span>
                        <span class="detail-value">${utility.depth ? utility.depth + "'" : 'N/A'}</span>
                </div>
                    <div class="detail-item">
                        <span class="detail-label">Material</span>
                        <span class="detail-value">${utility.material || 'N/A'}</span>
                </div>
                    <div class="detail-item">
                        <span class="detail-label">Condition</span>
                        <span class="detail-value">${utility.condition || 'N/A'}</span>
                    </div>
                </div>
            </div>
        `;

        alertsContainer.appendChild(alertDiv);

        // Limit to 5 alerts
        while (alertsContainer.children.length > 5) {
            const firstChild = alertsContainer.firstChild;
            const utilityId = firstChild.id.replace('alert-', '');
            AppState.alertTimeouts.set(utilityId, Date.now());
            alertsContainer.removeChild(firstChild);
        }

        // Haptic feedback for new alert
        hapticFeedback(200);
    }

    function updateProximityAlert(utility, distance) {
        // Don't update alerts if they're hidden
        if (!AppState.proximityAlertsVisible) {
            return;
        }
        
        const alertElement = document.getElementById(`alert-${utility.id}`);
        if (alertElement) {
            const distanceValue = alertElement.querySelector('.distance-value');
            if (distanceValue) {
                distanceValue.textContent = Math.round(distance / 0.3048);
            }
        }
    }

    function removeProximityAlert(utilityId) {
        const alert = document.getElementById(`alert-${utilityId}`);
        if (alert) {
            alert.remove();
        }
    }

    function dismissProximityAlert(utilityId) {
        const alert = document.getElementById(`alert-${utilityId}`);
        if (alert) {
            alert.remove();
            AppState.dismissedAlerts.set(utilityId, Date.now());
            AppState.alertTimeouts.delete(utilityId);
            hapticFeedback(30);
        }
    }

    window.dismissProximityAlert = dismissProximityAlert;

    function clearProximityAlerts() {
        const alertsContainer = document.getElementById('proximityAlerts');
        alertsContainer.innerHTML = '';
        AppState.dismissedAlerts.clear();
        AppState.alertTimeouts.clear();
    }

    function toggleProximityAlerts() {
        AppState.proximityAlertsVisible = !AppState.proximityAlertsVisible;
        const alertsContainer = document.getElementById('proximityAlerts');
        const toggleBtn = document.getElementById('alertToggleBtn');
        const toggleIcon = toggleBtn.querySelector('i');
        
        if (AppState.proximityAlertsVisible) {
            alertsContainer.classList.remove('hidden');
            toggleBtn.classList.remove('alerts-hidden');
            toggleIcon.className = 'fas fa-eye';
            toggleBtn.title = 'Hide proximity alerts';
        } else {
            alertsContainer.classList.add('hidden');
            toggleBtn.classList.add('alerts-hidden');
            toggleIcon.className = 'fas fa-eye-slash';
            toggleBtn.title = 'Show proximity alerts';
        }
        
        hapticFeedback(30);
    }

    function enhanceUtilityVisibilityForExcavation() {
        // Force all utilities to be fully visible and enhanced during excavation
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                utility.lineLayer.setStyle({
                    opacity: 1.0, // Full opacity regardless of zoom
                    weight: utility.lineType === 'main' ? 12 : 10, // Thicker lines
                    className: `utility-line ${utility.type} ${utility.lineType} excavation-enhanced`
                });
                
                // Add glow effect
                utility.lineLayer.getElement()?.classList.add('excavation-enhanced');
            }
            
            // Enhanced connection markers
            if (utility.connectionMarkers) {
                utility.connectionMarkers.forEach(marker => {
                    if (marker._icon) {
                        marker._icon.style.opacity = '1.0';
                        marker._icon.style.transform = 'scale(1.3)';
                        marker._icon.style.filter = 'drop-shadow(0 0 12px currentColor)';
                    }
                });
            }
        });
        
        // Enhanced structures
        AppState.structures.forEach(structure => {
            if (structure.marker && structure.marker._icon) {
                structure.marker._icon.style.opacity = '1.0';
                structure.marker._icon.style.transform = 'scale(1.4)';
                structure.marker._icon.style.filter = 'drop-shadow(0 0 16px currentColor)';
            }
        });
    }

    function resetUtilityVisibilityFromExcavation() {
        // Reset utilities to normal zoom-based visibility
        const currentZoom = AppState.map.getZoom();
        const zoomOpacity = calculateZoomOpacity(currentZoom);
        
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                utility.lineLayer.setStyle({
                    opacity: zoomOpacity,
                    weight: utility.lineType === 'main' ? 8 : 6, // Normal thickness
                    className: `utility-line ${utility.type} ${utility.lineType}`
                });
                
                // Remove glow effect
                utility.lineLayer.getElement()?.classList.remove('excavation-enhanced');
            }
            
            // Reset connection markers
            if (utility.connectionMarkers) {
                utility.connectionMarkers.forEach(marker => {
                    if (marker._icon) {
                        marker._icon.style.opacity = zoomOpacity;
                        marker._icon.style.transform = 'scale(1)';
                        marker._icon.style.filter = '';
                    }
                });
            }
        });
        
        // Reset structures
        AppState.structures.forEach(structure => {
            if (structure.marker && structure.marker._icon) {
                structure.marker._icon.style.opacity = zoomOpacity;
                structure.marker._icon.style.transform = 'scale(1)';
                structure.marker._icon.style.filter = '';
            }
        });
    }

    // Measurement Tools
    function toggleMeasureMode(mode) {
        if (AppState.measureMode === mode) {
            // Cancel measurement
            clearMeasurement();
            AppState.measureMode = null;
            document.getElementById('measureDistanceBtn').classList.remove('active');
            document.getElementById('measureAreaBtn').classList.remove('active');
        } else {
            // Start new measurement
            clearMeasurement();
            AppState.measureMode = mode;
            AppState.measurePoints = [];
            
            if (mode === 'distance') {
                document.getElementById('measureDistanceBtn').classList.add('active');
                document.getElementById('measureAreaBtn').classList.remove('active');
                showToast('Click points to measure distance', 'info');
            } else {
                document.getElementById('measureAreaBtn').classList.add('active');
                document.getElementById('measureDistanceBtn').classList.remove('active');
                showToast('Click points to measure area', 'info');
            }
        }
        hapticFeedback(30);
    }

    function addMeasurePoint(latlng) {
        AppState.measurePoints.push(latlng);
        
        // Add marker
        const marker = L.circleMarker(latlng, {
            radius: 6,
            fillColor: '#667eea',
            fillOpacity: 1,
            color: 'white',
            weight: 2
        }).addTo(AppState.map);
        
        AppState.measureMarkers.push(marker);
        
        // Update measurement display
        updateMeasurement();
        
        hapticFeedback(30);
    }

    function updateMeasurement() {
        if (AppState.measureMode === 'distance') {
            // Clear previous line
            if (AppState.measureLine) {
                AppState.map.removeLayer(AppState.measureLine);
            }
            
            if (AppState.measurePoints.length > 1) {
                // Draw line
                AppState.measureLine = L.polyline(AppState.measurePoints, {
                    color: '#667eea',
                    weight: 3,
                    dashArray: '5, 10'
                }).addTo(AppState.map);
                
                // Calculate total distance
                let totalDistance = 0;
                for (let i = 1; i < AppState.measurePoints.length; i++) {
                    totalDistance += AppState.measurePoints[i - 1].distanceTo(AppState.measurePoints[i]);
                }
                
                // Convert to feet
                const distanceFeet = Math.round(totalDistance * 3.28084);
                
                // Show distance
                showMeasurementDisplay(`Distance: ${distanceFeet}'`);
            }
        } else if (AppState.measureMode === 'area') {
            // Clear previous polygon
            if (AppState.measurePolygon) {
                AppState.map.removeLayer(AppState.measurePolygon);
            }
            
            if (AppState.measurePoints.length > 2) {
                // Draw polygon
                AppState.measurePolygon = L.polygon(AppState.measurePoints, {
                    color: '#667eea',
                    weight: 3,
                    fillOpacity: 0.2,
                    dashArray: '5, 10'
                }).addTo(AppState.map);
                
                // Calculate area
                const area = L.GeometryUtil.geodesicArea(AppState.measurePoints);
                const areaFeet = Math.round(area * 10.764); // Convert to square feet
                
                // Show area
                showMeasurementDisplay(`Area: ${areaFeet.toLocaleString()} sq ft`);
            }
        }
    }

    function showMeasurementDisplay(text) {
        // Remove previous display
        const existingDisplay = document.querySelector('.measurement-display');
        if (existingDisplay) {
            existingDisplay.remove();
        }
        
        // Create new display
        const display = document.createElement('div');
        display.className = 'measurement-display';
        display.textContent = text;
        
        // Position at last point
        const lastPoint = AppState.measurePoints[AppState.measurePoints.length - 1];
        const point = AppState.map.latLngToContainerPoint(lastPoint);
        
        display.style.left = `${point.x}px`;
        display.style.top = `${point.y - 40}px`;
        
        document.querySelector('.app-container').appendChild(display);
    }

    function clearMeasurement() {
        // Clear markers
        AppState.measureMarkers.forEach(marker => {
            AppState.map.removeLayer(marker);
        });
        AppState.measureMarkers = [];
        
        // Clear lines/polygons
        if (AppState.measureLine) {
            AppState.map.removeLayer(AppState.measureLine);
            AppState.measureLine = null;
        }
        if (AppState.measurePolygon) {
            AppState.map.removeLayer(AppState.measurePolygon);
            AppState.measurePolygon = null;
        }
        
        // Clear display
        const display = document.querySelector('.measurement-display');
        if (display) {
            display.remove();
        }
        
        AppState.measurePoints = [];
    }

    // Settings
    function openSettings() {
        document.getElementById('settingsPanel').classList.add('active');
    }

    function closeSettings() {
        document.getElementById('settingsPanel').classList.remove('active');
    }

    function toggleLayersPanel() {
        openSettings();
    }

    function setTheme(theme) {
        AppState.theme = theme;
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        
        const darkModeToggle = document.getElementById('darkModeToggle');
        if (theme === 'dark') {
            darkModeToggle.classList.add('active');
            if (AppState.currentMapStyle === 'streets') {
                changeMapStyle('dark');
            }
        } else {
            darkModeToggle.classList.remove('active');
            if (AppState.currentMapStyle === 'dark') {
                changeMapStyle('streets');
            }
        }
    }

    function toggleDarkMode() {
        const newTheme = AppState.theme === 'light' ? 'dark' : 'light';
        setTheme(newTheme);
        hapticFeedback(30);
    }

    function changeMapStyle(style) {
        // Update active button
        document.querySelectorAll('.map-style-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.style === style);
        });

        // Change map tiles
        AppState.map.eachLayer(layer => {
            if (layer instanceof L.TileLayer) {
                AppState.map.removeLayer(layer);
            }
        });

        L.tileLayer(AppState.mapStyles[style], {
            maxZoom: 22,
            maxNativeZoom: 19
        }).addTo(AppState.map);

        AppState.currentMapStyle = style;
        hapticFeedback(30);
    }

    function toggleUtilityVisibility(toggle) {
        const utility = toggle.dataset.utility;
        const isActive = toggle.classList.toggle('active');
        AppState.layers.visibility[utility] = isActive;

        // Show/hide layers
        if (isActive) {
            AppState.map.addLayer(AppState.layers.utilities[utility]);
            AppState.map.addLayer(AppState.layers.structures[utility]);
        } else {
            AppState.map.removeLayer(AppState.layers.utilities[utility]);
            AppState.map.removeLayer(AppState.layers.structures[utility]);
        }
        hapticFeedback(30);
    }

    function toggleLineTypeVisibility(toggle) {
        const lineType = toggle.dataset.linetype;
        const isActive = toggle.classList.toggle('active');
        AppState.layers.visibility[lineType] = isActive;

        // Update utility visibility
        updateUtilityVisibility();
        hapticFeedback(30);
    }

    function updateUtilityVisibility() {
        const currentZoom = AppState.map.getZoom();
        const zoomOpacity = calculateZoomOpacity(currentZoom);
        
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                const shouldShow = AppState.layers.visibility[utility.type] && 
                                 AppState.layers.visibility[utility.lineType];
                
                if (shouldShow) {
                    // Apply zoom-based opacity when visible
                    const isHighlighted = utility.lineLayer.options.className && 
                                        utility.lineLayer.options.className.includes('highlighted');
                    const isBeingRefined = AppState.refineMode && 
                                         AppState.selectedUtilityData && 
                                         utility.id === AppState.selectedUtilityData.id;
                    const finalOpacity = (isHighlighted || isBeingRefined) ? 1.0 : zoomOpacity;
                    
                    utility.lineLayer.setStyle({ opacity: finalOpacity });
                } else {
                    // Completely hidden when type is disabled
                    utility.lineLayer.setStyle({ opacity: 0 });
                }
            }
        });
    }

    // Cloud Sync functions
    function toggleCloudSync() {
        const toggle = document.getElementById('cloudSyncToggle');
        const isActive = toggle.classList.toggle('active');
        
        if (isActive) {
            enableCloudSync();
        } else {
            disableCloudSync();
        }
        
        localStorage.setItem('cloudSyncEnabled', isActive);
        hapticFeedback(30);
    }

    function enableCloudSync() {
        AppState.cloudSync.enabled = true;
        document.getElementById('cloudSyncToggle').classList.add('active');
        
        // Initialize cloud sync (implement actual cloud service)
        initializeCloudSync();
        syncToCloud();
    }

    function disableCloudSync() {
        AppState.cloudSync.enabled = false;
        document.getElementById('cloudSyncToggle').classList.remove('active');
    }

    function initializeCloudSync() {
        // This would connect to your actual cloud service
        // For now, we'll use a mock implementation
        AppState.cloudSync.userId = localStorage.getItem('userId') || generateId();
        localStorage.setItem('userId', AppState.cloudSync.userId);
    }

    function syncToCloud() {
        if (!AppState.cloudSync.enabled) return;
        
        showSyncStatus();
        
        // Mock cloud sync - replace with actual API calls
        setTimeout(() => {
            AppState.cloudSync.lastSync = new Date().toISOString();
            hideSyncStatus();
            console.log('Data synced to cloud');
        }, 1000);
    }

    function showSyncStatus() {
        document.getElementById('syncStatus').classList.add('show');
    }

    function hideSyncStatus() {
        setTimeout(() => {
            document.getElementById('syncStatus').classList.remove('show');
        }, 2000);
    }

    // Utility functions
    function generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    async function saveUtilities() {
        if (!AppState.currentUser) {
            console.warn(' No user logged in, cannot save utilities');
            return;
        }
        
        console.log(' Saving utilities to Firestore...');
        
        try {
            // Save only new local utilities as pending changes
            for (const utility of AppState.utilities) {
                if (utility.isLocal && !utility.pendingId && !utility.isApproved) {
                    console.log(' Creating pending change for utility:', utility.id);
                    
                    // Create pending change document
                    const pendingChange = {
                        type: 'utility',
                        action: 'add',
                        data: {
                            id: utility.id,
                            type: utility.type,
                            lineType: utility.lineType,
                            points: utility.points.map(p => ({ lat: p.lat, lng: p.lng })),
                            size: utility.size || '',
                            depth: utility.depth || '',
                            material: utility.material || '',
                            condition: utility.condition || '',
                            curbDistance: utility.curbDistance || '',
                            dateAdded: utility.dateAdded,
                            connections: utility.connections || [],
                            notes: utility.notes || []
                        },
                        userId: AppState.currentUser.uid,
                        userEmail: AppState.currentUser.email,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    const docRef = await db.collection('pendingChanges').add(pendingChange);
                    utility.pendingId = docRef.id;
                    
                    // Visual feedback - make line dashed to show it's pending
                    if (utility.lineLayer) {
                        utility.lineLayer.setStyle({
                            dashArray: '10, 5',
                            opacity: 0.6
                        });
                        
                        // Add pending class
                        const currentClasses = utility.lineLayer.options.className || '';
                        if (!currentClasses.includes('pending')) {
                            utility.lineLayer.setStyle({
                                className: currentClasses + ' pending'
                            });
                        }
                    }
                    
                    showToast('Change submitted for admin approval', 'info');
                    console.log(' Pending change created with ID:', docRef.id);
                }
            }
            
            console.log(' All new utilities submitted for approval');
        } catch (error) {
            console.error(' Error saving utilities:', error);
            showToast('Error submitting changes', 'error');
        }
    }

    async function loadUtilities() {
        if (!AppState.currentUser) {
            console.log(' No user logged in, skipping utilities load');
            return;
        }
        
        try {
            console.log(' Loading utilities from Firestore...');
            const snapshot = await AppState.safeCollection('utilities').get();
            
            if (snapshot.empty) {
                console.log(' No utilities found (this is normal for new setups)');
                return; // Don't show error for empty collection
            }
            
            let loadedCount = 0;
            snapshot.forEach((doc) => {
                const utilityData = doc.data();
                
                // Skip placeholder documents
                if (utilityData.isPlaceholder) {
                    console.log(' Skipping placeholder utility:', doc.id);
                    return;
                }
                
                // Validate required data exists
                if (!utilityData.points || !Array.isArray(utilityData.points)) {
                    console.warn(' Skipping utility with invalid points:', doc.id);
                    return;
                }
                
                try {
                    // Safely convert points with validation
                    utilityData.points = utilityData.points.map(p => {
                        if (p && typeof p.lat === 'number' && typeof p.lng === 'number') {
                            return L.latLng(p.lat, p.lng);
                        } else {
                            console.warn(' Invalid point in utility:', p);
                            return null;
                        }
                    }).filter(p => p !== null); // Remove invalid points
                    
                    // Only add if we have at least 2 valid points
                    if (utilityData.points.length >= 2) {
                        utilityData.isApproved = true;
                        
                        // Avoid duplicates
                        if (!AppState.utilities.find(u => u.id === utilityData.id)) {
                            AppState.utilities.push(utilityData);
                            createUtilityLine(utilityData);
                            loadedCount++;
                        }
                    } else {
                        console.warn(' Skipping utility with insufficient points:', doc.id);
                    }
                } catch (pointError) {
                    console.error(' Error processing utility points:', doc.id, pointError);
                }
            });
            
            console.log(` Loaded ${loadedCount} valid utilities from Firestore`);
            if (loadedCount > 0) {
                showToast(`Loaded ${loadedCount} utilities from shared map`, 'success');
            }
        } catch (error) {
            console.error(' Error loading utilities:', error);
            // Only show error if it's a real permission issue
            if (error.code === 'permission-denied') {
                showToast('Permission denied loading utilities', 'error');
            }
            // Don't show error for missing collections or other normal cases
        }
    }

    async function loadStructures() {
        if (!AppState.currentUser) {
            console.log(' No user logged in, skipping structures load');
            return;
        }
        
        try {
            console.log(' Loading structures from Firestore...');
            const snapshot = await AppState.safeCollection('structures').get();
            
            if (snapshot.empty) {
                console.log(' No structures found (this is normal for new setups)');
                return; // Don't show error for empty collection
            }
            
            let loadedCount = 0;
            snapshot.forEach((doc) => {
                const structureData = doc.data();
                
                // Skip placeholder documents
                if (structureData.isPlaceholder) {
                    console.log(' Skipping placeholder structure:', doc.id);
                    return;
                }
                
                // Validate required data exists
                if (!structureData.latlng) {
                    console.warn(' Skipping structure with no location:', doc.id);
                    return;
                }
                
                try {
                    // Safely convert latlng with validation
                    if (structureData.latlng.lat !== undefined && 
                        structureData.latlng.lng !== undefined &&
                        typeof structureData.latlng.lat === 'number' &&
                        typeof structureData.latlng.lng === 'number') {
                        
                        structureData.latlng = L.latLng(
                            structureData.latlng.lat, 
                            structureData.latlng.lng
                        );
                        structureData.isApproved = true;
                        
                        // Avoid duplicates
                        if (!AppState.structures.find(s => s.id === structureData.id)) {
                            AppState.structures.push(structureData);
                            createStructureMarker(structureData);
                            loadedCount++;
                        }
                    } else {
                        console.warn(' Invalid latlng in structure:', doc.id, structureData.latlng);
                    }
                } catch (latlngError) {
                    console.error(' Error processing structure location:', doc.id, latlngError);
                }
            });
            
            console.log(` Loaded ${loadedCount} valid structures from Firestore`);
        } catch (error) {
            console.error(' Error loading structures:', error);
            // Only show error if it's a real permission issue
            if (error.code === 'permission-denied') {
                showToast('Permission denied loading structures', 'error');
            }
            // Don't show error for missing collections
        }
    }

    async function saveStructures() {
        if (!AppState.currentUser) {
            console.warn(' No user logged in, cannot save structures');
            return;
        }
        
        try {
            // Save only pending/local structures to Firebase
            for (const structure of AppState.structures) {
                if (structure.isLocal && !structure.pendingId && !structure.isApproved) {
                    console.log(' Creating pending change for structure:', structure.id);
                    
                    // Create pending change document
                    const pendingChange = {
                        type: 'structure',
                        action: 'add',
                        data: {
                            id: structure.id,
                            type: structure.type,
                            utilityType: structure.utilityType,
                            latlng: {
                                lat: structure.latlng.lat,
                                lng: structure.latlng.lng
                            },
                            dateAdded: structure.dateAdded
                        },
                        userId: AppState.currentUser.uid,
                        userEmail: AppState.currentUser.email,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    const docRef = await db.collection('pendingChanges').add(pendingChange);
                    structure.pendingId = docRef.id;
                    
                    // Mark as pending on map with visual indicator
                    if (structure.marker && structure.marker._icon) {
                        structure.marker._icon.classList.add('pending');
                    }
                    
                    showToast('Structure submitted for admin approval', 'info');
                    console.log(' Pending structure change created:', docRef.id);
                }
            }
        } catch (error) {
            console.error(' Error saving structures:', error);
            showToast('Error submitting structure changes', 'error');
        }
    }



    // ========== ADMIN PANEL FUNCTIONS ==========

    async function loadPendingChanges() {
        if (AppState.userRole !== 'admin') {
            console.warn(' Only admins can load pending changes');
            return;
        }
        
        console.log(' Loading pending changes...');
        try {
            const snapshot = await AppState.safeCollection('pendingChanges')
                .orderBy('timestamp', 'desc')
                .get();
            
            console.log(` Found ${snapshot.docs.length} pending changes`);
            updatePendingChangesList(snapshot.docs);
        } catch (error) {
            console.error(' Error loading pending changes:', error);
            const listEl = document.getElementById('pendingChangesList');
            if (listEl) {
                if (error.code === 'failed-precondition') {
                    listEl.innerHTML = '<p style="color: var(--text-tertiary);"> No pending changes yet</p>';
                } else {
                    listEl.innerHTML = '<p style="color: var(--danger-color);">Error loading pending changes</p>';
                }
            }
        }
    }

    function updatePendingChangesList(docs) {
        const listEl = document.getElementById('pendingChangesList');
        listEl.innerHTML = '';
        
        if (docs.length === 0) {
            listEl.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;"> No pending changes</p>';
            return;
        }
        
        docs.forEach((doc) => {
            const change = doc.data();
            const pendingEl = document.createElement('div');
            pendingEl.className = 'pending-item';
            
            // Format timestamp
            let timeStr = 'Just now';
            if (change.timestamp && change.timestamp.toDate) {
                const timeAgo = Date.now() - change.timestamp.toDate().getTime();
                const minutes = Math.floor(timeAgo / 60000);
                const hours = Math.floor(timeAgo / 3600000);
                const days = Math.floor(timeAgo / 86400000);
                
                if (days > 0) timeStr = `${days} day${days > 1 ? 's' : ''} ago`;
                else if (hours > 0) timeStr = `${hours} hour${hours > 1 ? 's' : ''} ago`;
                else if (minutes > 0) timeStr = `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
            }
            
            // Create detailed description
            let details = '';
            if (change.type === 'utility') {
                details = `${capitalizeFirst(change.data.type)} ${change.data.lineType} line`;
                if (change.data.size) details += ` (${change.data.size}")`;
                if (change.data.material) details += ` - ${change.data.material}`;
            } else if (change.type === 'structure') {
                details = getStructureName(change.data.type);
            }
            
            pendingEl.innerHTML = `
                <div class="pending-header">
                    <span class="pending-type">
                        <i class="fas ${getChangeIcon(change.type, change.action)}"></i>
                        ${capitalizeFirst(change.action)} ${capitalizeFirst(change.type)}
                    </span>
                    <span class="pending-user">${change.userEmail}</span>
                </div>
                <div class="pending-timestamp">${timeStr}</div>
                <div class="pending-details">${details}</div>
                <div class="pending-actions">
                    <button class="approve-btn" onclick="approveChange('${doc.id}')">
                        <i class="fas fa-check"></i> Approve
                    </button>
                    <button class="reject-btn" onclick="rejectChange('${doc.id}')">
                        <i class="fas fa-times"></i> Reject
                    </button>
                </div>
            `;
            listEl.appendChild(pendingEl);
        });
    }

    function getChangeIcon(type, action) {
        const icons = {
            utility: {
                add: 'fa-plus-circle',
                edit: 'fa-edit',
                delete: 'fa-trash'
            },
            structure: {
                add: 'fa-plus-circle',
                edit: 'fa-edit',
                delete: 'fa-trash'
            }
        };
        return icons[type]?.[action] || 'fa-question-circle';
    }

    async function approveChange(changeId) {
        if (AppState.userRole !== 'admin') {
            showToast('Only admins can approve changes', 'error');
            return;
        }
        
        console.log(' Approving change:', changeId);
        
        try {
            const changeDoc = await db.collection('pendingChanges').doc(changeId).get();
            if (!changeDoc.exists) {
                showToast('Change not found', 'error');
                return;
            }
            
            const change = changeDoc.data();
            
            if (change.type === 'utility' && change.action === 'add') {
                // Add to approved utilities collection
                await db.collection('utilities').doc(change.data.id).set(change.data);
                console.log(' Utility approved and added to database');
            } else if (change.type === 'structure' && change.action === 'add') {
                // Add to approved structures collection
                await db.collection('structures').doc(change.data.id).set(change.data);
                console.log(' Structure approved and added to database');
            }
            
            // Delete the pending change
            await db.collection('pendingChanges').doc(changeId).delete();
            
            showToast(`${capitalizeFirst(change.type)} approved successfully!`, 'success');
            hapticFeedback(100);
            
        } catch (error) {
            console.error(' Error approving change:', error);
            showToast('Error approving change', 'error');
        }
    }

    async function rejectChange(changeId) {
        if (AppState.userRole !== 'admin') {
            showToast('Only admins can reject changes', 'error');
            return;
        }
        
        console.log(' Rejecting change:', changeId);
        
        try {
            const changeDoc = await db.collection('pendingChanges').doc(changeId).get();
            if (!changeDoc.exists) {
                showToast('Change not found', 'error');
                return;
            }
            
            const change = changeDoc.data();
            
            // Delete the pending change
            await db.collection('pendingChanges').doc(changeId).delete();
            
            showToast(`${capitalizeFirst(change.type)} change rejected`, 'info');
            hapticFeedback(50);
            
        } catch (error) {
            console.error(' Error rejecting change:', error);
            showToast('Error rejecting change', 'error');
        }
    }

    async function loadUsers() {
        if (AppState.userRole !== 'admin') {
            console.warn(' Only admins can load users');
            return;
        }
        
        console.log(' Loading users...');
        try {
            const snapshot = await AppState.safeCollection('users').orderBy('createdAt', 'desc').get();
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '';
            
            if (snapshot.empty) {
                usersList.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">No users found</p>';
                return;
            }
            
            snapshot.forEach((doc) => {
                const user = doc.data();
                const userEl = document.createElement('div');
                userEl.className = 'user-item';
                userEl.innerHTML = `
                    <div class="user-info">
                        <div class="user-email">${user.email}</div>
                        <div class="user-role ${user.role}">${user.role}</div>
                    </div>
                    ${user.role === 'pending' ? 
                        `<button class="approve-user-btn" onclick="approveUser('${doc.id}')">
                            <i class="fas fa-check"></i> Approve
                        </button>` : ''}
                `;
                usersList.appendChild(userEl);
            });
            
            console.log(` Loaded ${snapshot.size} users`);
        } catch (error) {
            console.error(' Error loading users:', error);
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '<p style="color: var(--danger-color);">Error loading users</p>';
        }
    }

    async function approveUser(userId) {
        if (AppState.userRole !== 'admin') {
            showToast('Only admins can approve users', 'error');
            return;
        }
        
        console.log(' Approving user:', userId);
        
        try {
            await db.collection('users').doc(userId).update({ 
                role: 'user',
                approvedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            showToast('User approved successfully!', 'success');
            hapticFeedback(100);
            
            // Refresh user list
            loadUsers();
            
        } catch (error) {
            console.error(' Error approving user:', error);
            showToast('Error approving user', 'error');
        }
    }

    function openAdminPanel() {
        if (AppState.userRole !== 'admin') {
            showToast('Admin access required', 'error');
            return;
        }
        
        console.log(' Opening admin panel');
        document.getElementById('adminPanel').classList.add('active');
        
        // Load fresh data
        loadPendingChanges();
        loadUsers();
    }

    function closeAdminPanel() {
        document.getElementById('adminPanel').classList.remove('active');
    }

    function signOut() {
        if (confirm('Are you sure you want to sign out?')) {
            console.log(' Signing out user');
            auth.signOut().then(() => {
                // Clear app state
                AppState.currentUser = null;
                AppState.userRole = null;
                AppState.utilities = [];
                AppState.structures = [];
                
                // Clear map
                if (AppState.map) {
                    AppState.map.eachLayer((layer) => {
                        if (layer !== AppState.map._layers[Object.keys(AppState.map._layers)[0]]) {
                            AppState.map.removeLayer(layer);
                        }
                    });
                }
                
                // Remove role badge and admin button
                const badge = document.querySelector('.role-badge');
                const adminBtn = document.querySelector('.admin-btn');
                if (badge) badge.remove();
                if (adminBtn) adminBtn.remove();
                
                showToast('Signed out successfully', 'success');
                
                // Reload page to reset state
                setTimeout(() => {
                    location.reload();
                }, 1000);
            }).catch((error) => {
                console.error(' Sign out error:', error);
                showToast('Error signing out', 'error');
            });
        }
    }

    // Make admin functions available globally
    window.approveChange = approveChange;
    window.rejectChange = rejectChange;
    window.approveUser = approveUser;
    window.openAdminPanel = openAdminPanel;
    window.closeAdminPanel = closeAdminPanel;
    window.signOut = signOut;

    function showToast(message, type = 'info') {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            success: 'fa-check-circle',
            error: 'fa-exclamation-circle',
            warning: 'fa-exclamation-triangle',
            info: 'fa-info-circle'
        };
        
        toast.innerHTML = `
            <i class="fas ${icons[type]}"></i>
            <span>${message}</span>
        `;
        
        container.appendChild(toast);
        
        setTimeout(() => toast.classList.add('show'), 10);
        
        // Adjust timeout based on message length
        const timeout = type === 'info' && message.length > 50 ? 5000 : 3000;
        
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, timeout);
    }

    // Initialize GeometryUtil for area calculations
    L.GeometryUtil = L.extend(L.GeometryUtil || {}, {
        geodesicArea: function (latLngs) {
            const R = 6378137; // Earth's radius in meters
            let area = 0;
            const len = latLngs.length;
            let x1, y1, x2, y2;
            
            for (let i = 0; i < len; i++) {
                x1 = latLngs[i].lng * Math.PI / 180;
                y1 = latLngs[i].lat * Math.PI / 180;
                x2 = latLngs[(i + 1) % len].lng * Math.PI / 180;
                y2 = latLngs[(i + 1) % len].lat * Math.PI / 180;
                
                area += (x2 - x1) * (Math.sin(y1) + Math.sin(y2));
            }
            
            area = Math.abs(area * R * R / 2);
            return area;
        }
    });
    
    // Debug function to test refine workflow
    function testRefineWorkflow() {
        console.log(' Testing refine workflow...');
        
        // Step 1: Create test utility if none exist
        if (AppState.utilities.length === 0) {
            console.log(' Creating test utility...');
            createTestUtilityForRefining();
            return;
        }
        
        // Step 2: Open info modal for first utility
        const testUtility = AppState.utilities[0];
        console.log(' Opening modal for:', testUtility.id);
        showInfoModal(testUtility);
        
        // Step 3: After a short delay, start refining
        setTimeout(() => {
            console.log(' Starting refine mode...');
            startRefineLocation();
        }, 1000);
    }
    
    // Make it available globally for testing
    window.testRefineWorkflow = testRefineWorkflow;
    
    // Test structure functionality
    function testStructureButton() {
        console.log(' Testing structure button functionality...');
        
        // Check if button exists
        const structureBtn = document.getElementById('addStructureBtn');
        if (!structureBtn) {
            console.error(' Structure button not found');
            return;
        }
        
        // Check if menu exists
        const structureMenu = document.getElementById('structureMenu');
        if (!structureMenu) {
            console.error(' Structure menu not found');
            return;
        }
        
        console.log(' Structure button and menu found');
        console.log(' Button position:', structureBtn.getBoundingClientRect());
        console.log(' Menu position:', structureMenu.getBoundingClientRect());
        
        // Simulate clicking the button
        console.log(' Opening menu...');
        toggleStructureMenu();
        
        setTimeout(() => {
            const isVisible = structureMenu.classList.contains('active');
            const computedStyle = window.getComputedStyle(structureMenu);
            console.log(' Menu active:', isVisible);
            console.log(' Menu display:', computedStyle.display);
            console.log(' Menu visibility:', computedStyle.visibility);
            console.log(' Menu bounds after open:', structureMenu.getBoundingClientRect());
            
            if (isVisible && computedStyle.display === 'grid') {
                console.log(' Menu is properly visible!');
                showToast(' Structure menu test passed!', 'success');
            } else {
                console.error(' Menu is not visible properly');
                showToast(' Structure menu test failed', 'error');
            }
            
            // Close after 3 seconds
            setTimeout(() => {
                console.log(' Closing menu...');
                toggleStructureMenu();
            }, 3000);
            
        }, 500);
        
        console.log(' Structure test initiated');
    }
    
    // Make it available globally for testing
    window.testStructureButton = testStructureButton;
    
    // Test zoom fading functionality
    function testZoomFading() {
        console.log(' Testing zoom-based fading...');
        
        if (AppState.utilities.length === 0) {
            console.log(' Creating test utility for zoom testing...');
            createTestUtilityForRefining();
        }
        
        const startZoom = AppState.map.getZoom();
        console.log(` Starting zoom level: ${startZoom}`);
        
        showToast(' Testing zoom fading - watch utilities fade as we zoom out!', 'info');
        
        // Zoom out gradually to show aggressive fading effect
        let currentZoom = Math.min(startZoom, 20); // Start from max zoom 20
        const zoomOut = () => {
            if (currentZoom > 10) {
                currentZoom -= 1;
                AppState.map.setZoom(currentZoom);
                const opacity = calculateZoomOpacity(currentZoom);
                console.log(` Zoom ${currentZoom}: Opacity ${opacity.toFixed(2)}`);
                showToast(`Zoom ${currentZoom}: ${Math.round(opacity * 100)}% opacity`, 'info');
                setTimeout(zoomOut, 1200);
            } else {
                // Zoom back in
                console.log(' Zooming back in...');
                setTimeout(() => {
                    const zoomIn = () => {
                        if (currentZoom < startZoom) {
                            currentZoom += 1;
                            AppState.map.setZoom(currentZoom);
                            const opacity = calculateZoomOpacity(currentZoom);
                            console.log(` Zoom ${currentZoom}: Opacity ${opacity.toFixed(2)}`);
                            setTimeout(zoomIn, 500);
                        } else {
                            console.log(' Zoom fading test completed!');
                            showToast(' Zoom fading test completed!', 'success');
                        }
                    };
                    zoomIn();
                }, 1000);
            }
        };
        
        setTimeout(zoomOut, 1000);
    }
    
    // Make it available globally for testing
    window.testZoomFading = testZoomFading;
    
    // Test mobile touch functionality
    function testMobileTouch() {
        console.log(' Testing mobile touch functionality...');
        
        // Check if we're on a touch device
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        console.log(' Touch device detected:', isTouchDevice);
        
        if (!isTouchDevice) {
            showToast(' No touch support detected - test may not be accurate', 'warning');
        }
        
        // Create a test utility if none exist
        if (AppState.utilities.length === 0) {
            console.log(' Creating test utility for touch testing...');
            createTestUtilityForRefining();
            
            setTimeout(() => {
                console.log(' Test utility created');
                showToast(' Touch test: Try pressing and holding the blue line for 0.5 seconds', 'info');
                
                // Check if events are bound
                const testUtility = AppState.utilities[0];
                if (testUtility && testUtility.lineLayer) {
                    console.log(' Testing event listeners on utility line...');
                    const events = testUtility.lineLayer._events;
                    if (events) {
                        console.log(' Registered events:', Object.keys(events));
                        console.log('  - touchstart:', !!events.touchstart);
                        console.log('  - touchmove:', !!events.touchmove);
                        console.log('  - touchend:', !!events.touchend);
                        console.log('  - mousedown:', !!events.mousedown);
                    }
                }
            }, 1000);
            
            return;
        }
        
        // Test existing utility
        const testUtility = AppState.utilities[0];
        console.log(' Testing touch events on utility:', testUtility.id);
        
        // Show info about the utility
        showToast(' Touch test: Try pressing and holding the utility line for 0.5 seconds', 'info');
        
        // Zoom to the utility for better testing
        if (testUtility.points && testUtility.points.length > 0) {
            const bounds = L.latLngBounds(testUtility.points);
            AppState.map.fitBounds(bounds, { padding: [100, 100] });
        }
        
        // Check event listeners
        if (testUtility.lineLayer && testUtility.lineLayer._events) {
            const events = testUtility.lineLayer._events;
            console.log(' Touch events registered:', {
                touchstart: !!events.touchstart,
                touchmove: !!events.touchmove, 
                touchend: !!events.touchend,
                mousedown: !!events.mousedown
            });
            
            if (events.touchstart) {
                console.log(' Touch events are properly registered');
                showToast(' Touch events are registered - try the long press now!', 'success');
            } else {
                console.error(' Touch events not found');
                showToast(' Touch events not registered properly', 'error');
            }
        }
    }
    
    // Make it available globally for testing
    window.testMobileTouch = testMobileTouch;
    
    // Debug function for account status
    async function debugAccountStatus() {
        if (!auth.currentUser) {
            console.log(' No user logged in');
            return;
        }
        
        console.log(' Account Status Debug:');
        console.log('');
        console.log(' Firebase Auth User:');
        console.log('  UID:', auth.currentUser.uid);
        console.log('  Email:', auth.currentUser.email);
        console.log('  Display Name:', auth.currentUser.displayName);
        console.log('');
        
        try {
            const userDoc = await db.collection('users').doc(auth.currentUser.uid).get();
            if (userDoc.exists) {
                console.log(' Firestore User Document:');
                const userData = userDoc.data();
                console.log('  Role:', userData.role);
                console.log('  Created:', userData.createdAt?.toDate());
                console.log('  Promoted to Admin:', userData.promotedToAdmin?.toDate());
                console.log('  Document Data:', userData);
            } else {
                console.log(' No Firestore User Document Found');
                console.log('  This is the problem! User exists in Auth but not in Firestore.');
                console.log('  Try signing out and signing back in to create the document.');
            }
        } catch (error) {
            console.error(' Error fetching user document:', error);
        }
        
        try {
            const adminSnapshot = await db.collection('users').where('role', '==', 'admin').get();
            console.log('');
            console.log(' Admin Users in System:');
            if (adminSnapshot.empty) {
                console.log('  No admin users found - next user will become admin');
            } else {
                adminSnapshot.forEach(doc => {
                    const data = doc.data();
                    console.log(`  - ${data.email} (${doc.id})`);
                });
            }
        } catch (error) {
            console.error(' Error fetching admin users:', error);
        }
        
        console.log('');
    }
    
    // Make debug function available globally
    window.debugAccountStatus = debugAccountStatus;
    
    // Cleanup function for bad Firestore data
    async function cleanupBadData() {
        if (AppState.userRole !== 'admin') {
            console.log(' Only admins can clean up data');
            showToast('Admin access required', 'error');
            return;
        }
        
        console.log(' Starting cleanup of bad Firestore data...');
        let deletedUtilities = 0;
        let deletedStructures = 0;
        
        try {
            // Clean utilities collection
            console.log(' Checking utilities collection...');
            const utilitiesSnapshot = await AppState.safeCollection('utilities').get();
            
            for (const doc of utilitiesSnapshot.docs) {
                const data = doc.data();
                let shouldDelete = false;
                let reason = '';
                
                if (data.isPlaceholder) {
                    shouldDelete = true;
                    reason = 'placeholder document';
                } else if (!data.points || !Array.isArray(data.points)) {
                    shouldDelete = true;
                    reason = 'missing or invalid points array';
                } else if (data.points.length < 2) {
                    shouldDelete = true;
                    reason = 'insufficient points';
                } else {
                    // Check if points have valid lat/lng
                    const invalidPoints = data.points.filter(p => 
                        !p || typeof p.lat !== 'number' || typeof p.lng !== 'number'
                    );
                    if (invalidPoints.length > 0) {
                        shouldDelete = true;
                        reason = 'invalid point coordinates';
                    }
                }
                
                if (shouldDelete) {
                    console.log(` Deleting bad utility ${doc.id}: ${reason}`);
                    await doc.ref.delete();
                    deletedUtilities++;
                }
            }
            
            // Clean structures collection
            console.log(' Checking structures collection...');
            const structuresSnapshot = await AppState.safeCollection('structures').get();
            
            for (const doc of structuresSnapshot.docs) {
                const data = doc.data();
                let shouldDelete = false;
                let reason = '';
                
                if (data.isPlaceholder) {
                    shouldDelete = true;
                    reason = 'placeholder document';
                } else if (!data.latlng) {
                    shouldDelete = true;
                    reason = 'missing latlng';
                } else if (typeof data.latlng.lat !== 'number' || typeof data.latlng.lng !== 'number') {
                    shouldDelete = true;
                    reason = 'invalid latlng coordinates';
                }
                
                if (shouldDelete) {
                    console.log(` Deleting bad structure ${doc.id}: ${reason}`);
                    await doc.ref.delete();
                    deletedStructures++;
                }
            }
            
            // Clean pending changes collection
            console.log(' Checking pendingChanges collection...');
            const pendingSnapshot = await AppState.safeCollection('pendingChanges').get();
            let deletedPending = 0;
            
            for (const doc of pendingSnapshot.docs) {
                const data = doc.data();
                let shouldDelete = false;
                let reason = '';
                
                if (data.isPlaceholder) {
                    shouldDelete = true;
                    reason = 'placeholder document';
                } else if (data.type === 'utility' && data.data) {
                    if (!data.data.points || !Array.isArray(data.data.points)) {
                        shouldDelete = true;
                        reason = 'invalid utility data';
                    }
                } else if (data.type === 'structure' && data.data) {
                    if (!data.data.latlng) {
                        shouldDelete = true;
                        reason = 'invalid structure data';
                    }
                }
                
                if (shouldDelete) {
                    console.log(` Deleting bad pending change ${doc.id}: ${reason}`);
                    await doc.ref.delete();
                    deletedPending++;
                }
            }
            
            console.log(` Cleanup complete!`);
            console.log(`   Deleted ${deletedUtilities} bad utilities`);
            console.log(`   Deleted ${deletedStructures} bad structures`);
            console.log(`   Deleted ${deletedPending} bad pending changes`);
            
            const totalDeleted = deletedUtilities + deletedStructures + deletedPending;
            if (totalDeleted > 0) {
                showToast(`Cleanup complete! Deleted ${totalDeleted} corrupted documents`, 'success');
                
                // Reload the app to refresh data
                setTimeout(() => {
                    console.log(' Reloading app to refresh data...');
                    location.reload();
                }, 2000);
            } else {
                showToast('No corrupted data found - database is clean!', 'info');
            }
            
        } catch (error) {
            console.error(' Error during cleanup:', error);
            showToast('Error during cleanup - check console', 'error');
        }
    }
    
    // Make cleanup function available globally for admin use
    window.cleanupBadData = cleanupBadData;
    
    // Premium GPS Debug System
    function debugLocation() {
        const gps = AppState.gps;
        console.log(' Premium GPS Debug Info:');
        console.log('');
        console.log(' Location State:');
        console.log('  Raw Position:', gps.lastPosition);
        console.log('  Filtered Position:', gps.filteredPosition);
        console.log('  App User Location:', AppState.userLocation);
        console.log('');
        console.log(' GPS Quality:');
        console.log('  Quality Level:', gps.quality);
        console.log('  Last Accuracy:', gps.lastAccuracy?.toFixed(1), 'm');
        console.log('  Is Moving:', gps.isMoving);
        console.log('  Movement Speed:', gps.movementSpeed?.toFixed(2), 'm/s');
        console.log('');
        console.log(' Direction State:');
        console.log('  Raw Heading:', gps.lastHeading?.toFixed(1), '');
        console.log('  Filtered Heading:', gps.filteredHeading?.toFixed(1), '');
        console.log('  Heading History:', gps.headingHistory?.map(h => h.toFixed(1)));
        console.log('');
        console.log(' Position History:');
        gps.positionHistory?.forEach((pos, i) => {
            console.log(`  ${i}: ${pos.lat.toFixed(6)}, ${pos.lng.toFixed(6)} (${new Date(pos.timestamp).toLocaleTimeString()})`);
        });
        console.log('');
        console.log(' Marker Info:');
        console.log('  Marker exists:', !!AppState.userMarker);
        if (AppState.userMarker) {
            console.log('  Marker position:', AppState.userMarker.getLatLng());
            const element = AppState.userMarker.getElement();
            if (element) {
                console.log('  Element transform:', element.style.transform);
                const container = element.querySelector('.location-container');
                if (container) {
                    console.log('  GPS Quality attr:', container.getAttribute('data-gps-quality'));
                    console.log('  Moving attr:', container.getAttribute('data-moving'));
                    console.log('  Heading attr:', container.getAttribute('data-heading'));
                }
            }
        }
        console.log('');
        console.log(' Map State:');
        console.log('  Center:', AppState.map.getCenter());
        console.log('  Zoom:', AppState.map.getZoom());
        console.log('');
        
        // Force a premium location update
        if (navigator.geolocation) {
            console.log(' Requesting fresh premium location...');
            navigator.geolocation.getCurrentPosition(
                position => {
                    console.log(' Fresh GPS data received');
                    updateUserLocation(position);
                    // Debug the processing
                    setTimeout(() => {
                        console.log(' Post-processing GPS state:', {
                            quality: AppState.gps.quality,
                            isMoving: AppState.gps.isMoving,
                            speed: AppState.gps.movementSpeed
                        });
                    }, 100);
                },
                error => console.error(' Fresh location error:', error),
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }
    }
    
    // Test Premium GPS System
    function testPremiumGPS() {
        console.log(' Testing Premium GPS System...');
        
        if (!navigator.geolocation) {
            console.error(' Geolocation not supported');
            showToast('Geolocation not supported', 'error');
            return;
        }
        
        showToast(' Testing premium GPS - check console for details', 'info');
        
        let testCount = 0;
        const maxTests = 5;
        
        function runTest() {
            testCount++;
            console.log(` GPS Test ${testCount}/${maxTests}`);
            
            navigator.geolocation.getCurrentPosition(
                position => {
                    console.log(` Test ${testCount} - Raw GPS:`, {
                        lat: position.coords.latitude.toFixed(6),
                        lng: position.coords.longitude.toFixed(6),
                        accuracy: position.coords.accuracy.toFixed(1),
                        speed: position.coords.speed
                    });
                    
                    updateUserLocation(position);
                    
                    setTimeout(() => {
                        console.log(` Test ${testCount} - Processed:`, {
                            quality: AppState.gps.quality,
                            isMoving: AppState.gps.isMoving,
                            speed: AppState.gps.movementSpeed?.toFixed(2),
                            filteredLat: AppState.gps.filteredPosition?.lat.toFixed(6),
                            filteredLng: AppState.gps.filteredPosition?.lng.toFixed(6)
                        });
                        
                        if (testCount < maxTests) {
                            setTimeout(runTest, 2000); // Test every 2 seconds
                        } else {
                            console.log(' Premium GPS test completed!');
                            showToast('Premium GPS test completed! Check console for results.', 'success');
                        }
                    }, 500);
                },
                error => {
                    console.error(` Test ${testCount} failed:`, error);
                    if (testCount < maxTests) {
                        setTimeout(runTest, 2000);
                    }
                },
                { enableHighAccuracy: true, timeout: 15000, maximumAge: 1000 }
            );
        }
        
        runTest();
    }
    
    // Quick Demo of Premium GPS Features
    function demoPremiumGPS() {
        console.log(' Premium GPS Demo Starting...');
        showToast(' Premium GPS Demo - Watch the console!', 'success');
        
        if (!navigator.geolocation) {
            showToast(' Geolocation not available', 'error');
            return;
        }
        
        console.log(' Premium GPS Features:');
        console.log('   Advanced coordinate filtering');
        console.log('   Movement detection & adaptive smoothing');
        console.log('   Sophisticated compass heading filters');
        console.log('   Quality-based visual indicators');
        console.log('   Smooth animations for all updates');
        console.log('   Multi-layer accuracy visualization');
        
        // Get location and show the filtering in action
        navigator.geolocation.getCurrentPosition(
            position => {
                console.log(' Raw GPS received - processing through premium filters...');
                updateUserLocation(position);
                
                setTimeout(() => {
                    debugLocation();
                    showToast(' Premium GPS demo complete! Check console for details.', 'success');
                    
                    // Show visual feedback about quality
                    const quality = AppState.gps.quality;
                    const qualityEmoji = {
                        'excellent': '',
                        'good': '', 
                        'fair': '',
                        'poor': ''
                    };
                    
                    showToast(`${qualityEmoji[quality]} GPS Quality: ${quality.toUpperCase()}`, 'info');
                }, 1000);
            },
            error => {
                console.error(' Demo failed:', error);
                showToast(' GPS demo failed - check permissions', 'error');
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
    }

    window.debugLocation = debugLocation;
    window.testPremiumGPS = testPremiumGPS;
    window.demoPremiumGPS = demoPremiumGPS;
    
    // Enhanced cleanup function for memory management
    function cleanup() {
        console.log('Cleaning up UtiliTrack resources...');
        
        // Location tracking cleanup
        if (AppState.watchId) {
            navigator.geolocation.clearWatch(AppState.watchId);
            AppState.watchId = null;
        }
        
        // Excavation mode cleanup
        if (AppState.proximityInterval) {
            clearInterval(AppState.proximityInterval);
            AppState.proximityInterval = null;
        }
        
        // Clear all alert timeouts
        AppState.alertTimeouts.forEach((timeout, utilityId) => {
            if (timeout && typeof timeout === 'number') {
                clearTimeout(timeout);
            }
        });
        AppState.alertTimeouts.clear();
        
        // Clear refine markers if any exist
        if (AppState.refineMarkers && AppState.refineMarkers.length > 0) {
            AppState.refineMarkers.forEach(marker => {
                try {
                    if (AppState.map && AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                } catch (error) {
                    console.error('Error removing refine marker during cleanup:', error);
                }
            });
            AppState.refineMarkers = [];
        }
        
        // Clear refine mode state
        AppState.refineMode = false;
        
        // Reset premium GPS state
        if (AppState.gps) {
            AppState.gps.lastPosition = null;
            AppState.gps.filteredPosition = null;
            AppState.gps.lastHeading = null;
            AppState.gps.filteredHeading = null;
            AppState.gps.headingHistory = [];
            AppState.gps.positionHistory = [];
        }
        
        // Run all stored cleanup functions
        if (AppState.cleanupFunctions) {
            AppState.cleanupFunctions.forEach(fn => {
                try {
                    fn();
                } catch (error) {
                    console.error('Error in cleanup function:', error);
                }
            });
        }
        
        console.log('UtiliTrack cleanup completed');
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', cleanup);
    window.addEventListener('pagehide', cleanup);
</script>

</body>
</html>
