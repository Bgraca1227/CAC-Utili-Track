<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>CAC Utili-Track</title>

    <!-- Favicon and App Icons -->
    <!-- Basic Favicon -->
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">

    <!-- Apple Touch Icons (for iOS home screen) -->
    <link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <!-- Android Chrome Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="android-chrome-512x512.png">

    <!-- Microsoft Tiles -->
    <meta name="msapplication-TileColor" content="#0a0a0f">
    <meta name="msapplication-TileImage" content="ms-icon-144x144.png">
    <meta name="msapplication-square70x70logo" content="ms-icon-70x70.png">
    <meta name="msapplication-square150x150logo" content="ms-icon-150x150.png">
    <meta name="msapplication-square310x310logo" content="ms-icon-310x310.png">

    <!-- Web App Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Theme Color -->
    <meta name="theme-color" content="#4a90e2">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="background-color" content="#0a0a0f">

    <!-- iOS Specific Meta Tags for Better Home Screen Experience -->
    <meta name="apple-mobile-web-app-title" content="CAC Utili-Track">
    <meta name="application-name" content="CAC Utili-Track">

<!-- Firebase Scripts -->
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

<script>
// Firebase configuration
const firebaseConfig = {
    apiKey: "AIzaSyAa5gWHbC_9t_DaW0-ZfN9uG6mxkJj5u9w",
    authDomain: "cac-utilitrack.firebaseapp.com",
    projectId: "cac-utilitrack",
    storageBucket: "cac-utilitrack.firebasestorage.app",
    messagingSenderId: "1070773430788",
    appId: "1:1070773430788:web:a02272d5037e4ced9fa351"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
</script>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
<!-- Font Awesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
<!-- Google Fonts -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Space+Grotesk:wght@300;400;500;600;700&display=swap">

<style>
    :root {
        --vh: 1vh;
        /* Premium Color Palette */
        --bg-primary: #0a0a0f;
        --bg-secondary: #12121a;
        --bg-tertiary: #1a1a25;
        --bg-glass: rgba(18, 18, 26, 0.85);
        --bg-glass-light: rgba(255, 255, 255, 0.05);
        
        --text-primary: #ffffff;
        --text-secondary: #a0a0b8;
        --text-tertiary: #6b6b80;
        
        --border-color: rgba(255, 255, 255, 0.1);
        --border-active: rgba(255, 255, 255, 0.2);
        
        /* Premium Shadows */
        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
        --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);
        --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
        --shadow-xl: 0 12px 48px rgba(0, 0, 0, 0.6);
        --shadow-glow: 0 0 40px rgba(102, 126, 234, 0.5);
        
        /* Utility Colors - Premium Vibrant */
        --water-color: #00b4d8;
        --gas-color: #ffd60a;
        --electric-color: #ff006e;
        --sewer-color: #a8763e;
        --telecom-color: #b565d8;
        
        /* UI Accent Colors */
        --danger-color: #ff0054;
        --success-color: #00f5a0;
        --warning-color: #ffd60a;
        --info-color: #00b4d8;
        
        /* Premium Gradients */
        --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        --gradient-danger: linear-gradient(135deg, #ff0054 0%, #ff006e 100%);
        --gradient-success: linear-gradient(135deg, #00f5a0 0%, #00d084 100%);
        --gradient-premium: linear-gradient(180deg, #0a0a0f 0%, #1a1a25 100%);
        --gradient-glass: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
        --gradient-gold: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
        
        /* Spacing */
        --spacing-xs: 4px;
        --spacing-sm: 8px;
        --spacing-md: 16px;
        --spacing-lg: 24px;
        --spacing-xl: 32px;
        --spacing-2xl: 48px;
        
        /* Border Radius */
        --radius-sm: 8px;
        --radius-md: 12px;
        --radius-lg: 16px;
        --radius-xl: 24px;
        --radius-2xl: 32px;
        --radius-full: 9999px;
        
        /* Transitions */
        --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
        --transition-normal: 300ms cubic-bezier(0.4, 0, 0.2, 1);
        --transition-slow: 500ms cubic-bezier(0.4, 0, 0.2, 1);
        --transition-spring: 500ms cubic-bezier(0.34, 1.56, 0.64, 1);
        --transition-bounce: 600ms cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    /* Light Mode */
    [data-theme="light"] {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-tertiary: #e9ecef;
        --bg-glass: rgba(255, 255, 255, 0.85);
        --bg-glass-light: rgba(0, 0, 0, 0.05);
        --text-primary: #1a1d21;
        --text-secondary: #6c757d;
        --text-tertiary: #adb5bd;
        --border-color: rgba(0, 0, 0, 0.1);
        --border-active: rgba(0, 0, 0, 0.2);
        --gradient-premium: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
    }
    
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    
    html {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        height: 100vh;
        height: -webkit-fill-available;
        overflow: hidden;
        overscroll-behavior: none;
        -webkit-overflow-scrolling: touch;
        background-color: #0a0a0f;
        margin: 0;
        padding: 0;
        /* Add padding to extend into safe areas */
        padding-bottom: env(safe-area-inset-bottom);
    }

    body {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        height: 100vh;
        height: -webkit-fill-available;
        margin: 0;
        padding: 0;
        overflow: hidden;
        overscroll-behavior: none;
        -webkit-overflow-scrolling: touch;
        font-family: 'Inter', -apple-system, sans-serif;
        background-color: #0a0a0f;
        color: var(--text-primary);
        touch-action: none;
        -webkit-text-size-adjust: 100%;
        -webkit-user-select: none;
        user-select: none;
        /* Extend into bottom safe area */
        padding-bottom: env(safe-area-inset-bottom);
    }

    /* Prevent any element from causing overflow */
    * {
        max-width: 100vw !important;
    }
    
    /* Prevent all zooming */
    input, select, textarea {
        font-size: 16px !important;
        touch-action: manipulation;
    }
    
    /* App Container */
    .app-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        /* Use padding instead of negative bottom */
        bottom: 0;
        width: 100vw;
        height: 100vh;
        height: -webkit-fill-available;
        overflow: hidden;
        background: #0a0a0f;
        margin: 0;
        padding: 0;
        padding-bottom: env(safe-area-inset-bottom, 0);
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
    }
    
    /* Map Container */
    #map {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        /* Use full height with padding for safe area */
        height: 100vh;
        height: -webkit-fill-available;
        z-index: 1;
        background: #0a0a0f;
        margin: 0;
        padding: 0;
        padding-bottom: env(safe-area-inset-bottom, 0);
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
    }
    
    /* ========== TRIPLE AAA QUALITY SPLASH SCREEN ========== */
    .splash-screen {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #0a0a0f 0%, #1a1a25 50%, #0f0c1a 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        opacity: 1;
        transition: all 2s cubic-bezier(0.23, 1, 0.32, 1);
        overflow: hidden;
    }
    
    .splash-screen.hide {
        opacity: 0;
        transform: scale(1.1);
        filter: blur(20px);
        pointer-events: none;
    }
    
    /* Dynamic Geometric Background */
    .splash-background {
        position: absolute;
        inset: 0;
        overflow: hidden;
    }
    
    .geometric-layer {
        position: absolute;
        inset: 0;
        opacity: 0.8;
    }
    
    .geo-shape {
        position: absolute;
        background: linear-gradient(45deg, transparent, rgba(102, 126, 234, 0.1));
        border: 1px solid rgba(102, 126, 234, 0.2);
        border-radius: 20% 80% 60% 40% / 40% 60% 80% 20%;
        animation: morphShape 8s ease-in-out infinite;
        filter: blur(1px);
    }
    
    .geo-shape:nth-child(1) {
        width: 300px;
        height: 300px;
        top: 10%;
        left: -10%;
        animation-delay: 0s;
        background: linear-gradient(45deg, transparent, rgba(255, 0, 110, 0.08));
        border-color: rgba(255, 0, 110, 0.15);
    }
    
    .geo-shape:nth-child(2) {
        width: 400px;
        height: 400px;
        top: 30%;
        right: -15%;
        animation-delay: 2s;
        background: linear-gradient(45deg, transparent, rgba(0, 245, 160, 0.06));
        border-color: rgba(0, 245, 160, 0.12);
    }
    
    .geo-shape:nth-child(3) {
        width: 250px;
        height: 250px;
        bottom: 20%;
        left: 20%;
        animation-delay: 4s;
        background: linear-gradient(45deg, transparent, rgba(255, 214, 10, 0.07));
        border-color: rgba(255, 214, 10, 0.14);
    }
    
    .geo-shape:nth-child(4) {
        width: 350px;
        height: 350px;
        bottom: 10%;
        right: 10%;
        animation-delay: 6s;
        background: linear-gradient(45deg, transparent, rgba(181, 101, 216, 0.05));
        border-color: rgba(181, 101, 216, 0.1);
    }
    
    @keyframes morphShape {
        0%, 100% {
            transform: rotate(0deg) scale(1);
            border-radius: 20% 80% 60% 40% / 40% 60% 80% 20%;
            opacity: 0.6;
        }
        25% {
            transform: rotate(90deg) scale(1.1);
            border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%;
            opacity: 0.8;
        }
        50% {
            transform: rotate(180deg) scale(0.9);
            border-radius: 80% 20% 50% 50% / 50% 80% 20% 50%;
            opacity: 0.4;
        }
        75% {
            transform: rotate(270deg) scale(1.05);
            border-radius: 40% 60% 70% 30% / 70% 40% 60% 30%;
            opacity: 0.7;
        }
    }
    
    /* Advanced Particle System */
    .splash-particles {
        position: absolute;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
    }
    
    .neural-particle {
        position: absolute;
        width: 2px;
        height: 2px;
        background: #ffffff;
        border-radius: 50%;
        opacity: 0;
        box-shadow: 0 0 10px currentColor;
        animation: neuralFlow 12s linear infinite;
    }
    
    .neural-particle:nth-child(1) { 
        color: #667eea; 
        animation-delay: 0s; 
        left: 0%; 
        animation-duration: 15s;
    }
    .neural-particle:nth-child(2) { 
        color: #ff006e; 
        animation-delay: 2s; 
        left: 10%; 
        animation-duration: 18s;
    }
    .neural-particle:nth-child(3) { 
        color: #00f5a0; 
        animation-delay: 4s; 
        left: 20%; 
        animation-duration: 12s;
    }
    .neural-particle:nth-child(4) { 
        color: #ffd60a; 
        animation-delay: 6s; 
        left: 30%; 
        animation-duration: 20s;
    }
    .neural-particle:nth-child(5) { 
        color: #b565d8; 
        animation-delay: 8s; 
        left: 40%; 
        animation-duration: 14s;
    }
    .neural-particle:nth-child(6) { 
        color: #00b4d8; 
        animation-delay: 1s; 
        left: 50%; 
        animation-duration: 16s;
    }
    .neural-particle:nth-child(7) { 
        color: #ff6b35; 
        animation-delay: 3s; 
        left: 60%; 
        animation-duration: 13s;
    }
    .neural-particle:nth-child(8) { 
        color: #4ecdc4; 
        animation-delay: 5s; 
        left: 70%; 
        animation-duration: 17s;
    }
    .neural-particle:nth-child(9) { 
        color: #ffe66d; 
        animation-delay: 7s; 
        left: 80%; 
        animation-duration: 19s;
    }
    .neural-particle:nth-child(10) { 
        color: #a8e6cf; 
        animation-delay: 9s; 
        left: 90%; 
        animation-duration: 11s;
    }
    
    @keyframes neuralFlow {
        0% {
            transform: translateY(100vh) translateX(0) scale(0);
            opacity: 0;
        }
        5% {
            opacity: 1;
            transform: translateY(95vh) translateX(0) scale(1);
        }
        50% {
            transform: translateY(50vh) translateX(100px) scale(1.5);
            opacity: 0.8;
        }
        95% {
            opacity: 1;
            transform: translateY(5vh) translateX(-50px) scale(1);
        }
        100% {
            transform: translateY(-5vh) translateX(0) scale(0);
            opacity: 0;
        }
    }
    
    /* Ultra Modern Logo System */
    .splash-logo-container {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        animation: logoMasterEntrance 3s cubic-bezier(0.23, 1, 0.32, 1);
        margin-bottom: 60px;
    }
    
    @keyframes logoMasterEntrance {
        0% {
            transform: scale(0.3) rotateY(180deg);
            opacity: 0;
            filter: blur(20px);
        }
        60% {
            transform: scale(1.1) rotateY(-10deg);
            opacity: 1;
            filter: blur(0px);
        }
        100% {
            transform: scale(1) rotateY(0deg);
            opacity: 1;
            filter: blur(0px);
        }
    }
    
    /* Hexagonal Tech Symbol */
    .logo-hexagon {
        position: relative;
        width: 160px;
        height: 160px;
        margin-bottom: 40px;
        animation: hexRotate 20s linear infinite;
    }
    
    @keyframes hexRotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    .hex-core {
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, 
            rgba(102, 126, 234, 0.1) 0%, 
            rgba(255, 0, 110, 0.15) 50%, 
            rgba(0, 245, 160, 0.1) 100%);
        clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
        border: 2px solid rgba(102, 126, 234, 0.3);
        animation: hexPulse 4s ease-in-out infinite;
        backdrop-filter: blur(10px);
    }
    
    @keyframes hexPulse {
        0%, 100% {
            transform: scale(1);
            border-color: rgba(102, 126, 234, 0.3);
            background: linear-gradient(135deg, 
                rgba(102, 126, 234, 0.1) 0%, 
                rgba(255, 0, 110, 0.15) 50%, 
                rgba(0, 245, 160, 0.1) 100%);
        }
        50% {
            transform: scale(1.05);
            border-color: rgba(0, 245, 160, 0.5);
            background: linear-gradient(135deg, 
                rgba(0, 245, 160, 0.15) 0%, 
                rgba(102, 126, 234, 0.2) 50%, 
                rgba(255, 0, 110, 0.1) 100%);
        }
    }
    
    .hex-inner {
        position: absolute;
        inset: 12px;
        clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
        background: rgba(10, 10, 15, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        animation: hexInnerFloat 6s ease-in-out infinite;
    }
    
    @keyframes hexInnerFloat {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-8px); }
    }
    
    .hex-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 8px;
        width: 80px;
        height: 80px;
    }
    
    .hex-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea, #764ba2);
        animation: dotSequence 3s ease-in-out infinite;
        opacity: 0.3;
        box-shadow: 0 0 15px currentColor;
    }
    
    .hex-dot:nth-child(1) { animation-delay: 0s; color: #00b4d8; }
    .hex-dot:nth-child(2) { animation-delay: 0.1s; color: #ffd60a; }
    .hex-dot:nth-child(3) { animation-delay: 0.2s; color: #ff006e; }
    .hex-dot:nth-child(4) { animation-delay: 0.3s; color: #a8763e; }
    .hex-dot:nth-child(5) { animation-delay: 0.4s; color: #667eea; }
    .hex-dot:nth-child(6) { animation-delay: 0.5s; color: #b565d8; }
    .hex-dot:nth-child(7) { animation-delay: 0.6s; color: #00f5a0; }
    .hex-dot:nth-child(8) { animation-delay: 0.7s; color: #ff6b35; }
    .hex-dot:nth-child(9) { animation-delay: 0.8s; color: #4ecdc4; }
    
    @keyframes dotSequence {
        0%, 80% { 
            opacity: 0.3; 
            transform: scale(1); 
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        10%, 30% { 
            opacity: 1; 
            transform: scale(1.4); 
            background: linear-gradient(135deg, currentColor, #ffffff);
            box-shadow: 0 0 25px currentColor;
        }
    }
    
    /* Premium Typography System */
    .splash-title {
        font-family: 'Space Grotesk', sans-serif;
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(135deg, 
            #ffffff 0%, 
            #667eea 20%, 
            #ff006e 40%, 
            #00f5a0 60%, 
            #ffd60a 80%, 
            #ffffff 100%);
        background-size: 400% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: -1px;
        margin-bottom: 16px;
        animation: titleFlow 6s ease-in-out infinite;
        text-align: center;
        position: relative;
        opacity: 0;
        transform: translateY(30px);
        animation: titleEntrance 2s ease-out 1s forwards, titleFlow 6s ease-in-out 3s infinite;
    }
    
    @keyframes titleEntrance {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    @keyframes titleFlow {
        0%, 100% { background-position: 0% center; }
        50% { background-position: 100% center; }
    }
    
    .splash-subtitle {
        font-family: 'Inter', sans-serif;
        font-size: 14px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.6);
        letter-spacing: 3px;
        text-transform: uppercase;
        text-align: center;
        opacity: 0;
        transform: translateY(20px);
        animation: subtitleEntrance 1.5s ease-out 2s forwards;
        position: relative;
    }
    
    @keyframes subtitleEntrance {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* Advanced Loading System */
    .splash-loading {
        position: absolute;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
    }
    
    .loading-bar-container {
        width: 300px;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
        position: relative;
        border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .loading-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, 
            #667eea 0%, 
            #ff006e 25%, 
            #00f5a0 50%, 
            #ffd60a 75%, 
            #b565d8 100%);
        transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        border-radius: 2px;
        box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
    }
    
    .loading-bar::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(255, 255, 255, 0.4) 50%, 
            transparent 100%);
        animation: loadingShine 2s ease-in-out infinite;
    }
    
    @keyframes loadingShine {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }
    
         .loading-text {
         font-family: 'Inter', sans-serif;
         font-size: 12px;
         font-weight: 500;
         color: rgba(255, 255, 255, 0.7);
         letter-spacing: 1px;
         text-align: center;
         transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
         opacity: 1;
     }
     
     .loading-percentage {
         font-family: 'Space Grotesk', sans-serif;
         font-size: 16px;
         font-weight: 700;
         color: #ffffff;
         margin-top: 12px;
         letter-spacing: 2px;
         transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
         transform: scale(1);
     }
    
    /* Premium Top Bar */
    .top-bar {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        padding: var(--spacing-md);
        padding-top: calc(env(safe-area-inset-top, 0) + var(--spacing-md));
        z-index: 100;
        pointer-events: none;
    }
    
    .top-bar > * {
        pointer-events: auto;
    }

    .top-bar-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        max-width: 100%;
        gap: var(--spacing-md);
    }

    /* Search Container */
    .search-container {
        display: flex;
        align-items: center;
    }

    .search-btn {
        width: 48px;
        height: 48px;
        border: none;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-xl);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-lg);
        transition: all var(--transition-normal);
        border: 1px solid var(--border-color);
        color: var(--text-primary);
    }

    .search-btn:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-xl);
        background: var(--bg-tertiary);
    }

    .search-btn:active {
        transform: scale(0.95);
    }

    .search-btn i {
        font-size: 20px;
    }

    /* Search Modal */
    .search-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        z-index: 9999;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity var(--transition-normal);
        padding: calc(env(safe-area-inset-top, 0) + 20px) var(--spacing-lg) var(--spacing-lg);
        padding-top: calc(env(safe-area-inset-top, 0) + 20px);
    }

    .search-modal.active {
        opacity: 1;
        pointer-events: auto;
    }

    .search-modal-content {
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-xl);
        width: 100%;
        max-width: 500px;
        max-height: 50vh;
        overflow: hidden;
        border: 1px solid var(--border-color);
        transform: scale(0.9);
        transition: transform var(--transition-spring);
    }

    .search-modal.active .search-modal-content {
        transform: scale(1);
    }

    .search-header {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .search-header h3 {
        font-size: 20px;
        font-weight: 700;
        margin: 0;
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    .search-close {
        width: 32px;
        height: 32px;
        border: none;
        background: var(--bg-glass-light);
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
        color: var(--text-primary);
    }

    .search-close:hover {
        background: var(--bg-tertiary);
        transform: scale(1.1);
    }

    .search-body {
        padding: var(--spacing-lg);
    }

    .search-input-container {
        display: flex;
        gap: var(--spacing-sm);
        margin-bottom: var(--spacing-lg);
    }

    .search-input {
        flex: 1;
        padding: var(--spacing-md) var(--spacing-lg);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-glass-light);
        color: var(--text-primary);
        font-size: 16px;
        font-weight: 500;
        transition: all var(--transition-normal);
    }

    .search-input:focus {
        outline: none;
        border-color: #667eea;
        background: var(--bg-secondary);
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }

    .search-submit {
        padding: var(--spacing-md) var(--spacing-lg);
        border: none;
        background: var(--gradient-primary);
        color: white;
        border-radius: var(--radius-md);
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
        box-shadow: var(--shadow-md);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    .search-submit:hover {
        transform: translateY(-1px);
        box-shadow: var(--shadow-lg);
    }

    .search-submit:active {
        transform: scale(0.95);
    }

    .search-results {
        max-height: 200px;
        overflow-y: auto;
        border-radius: var(--radius-md);
        border: 1px solid var(--border-color);
        background: var(--bg-glass-light);
    }

    .search-result-item {
        padding: var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    .search-result-item:last-child {
        border-bottom: none;
    }

    .search-result-item:hover {
        background: var(--bg-tertiary);
    }

    .search-result-icon {
        width: 32px;
        height: 32px;
        border-radius: var(--radius-md);
        background: var(--gradient-primary);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 14px;
        flex-shrink: 0;
    }

    .search-result-content {
        flex: 1;
    }

    .search-result-title {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 2px;
    }

    .search-result-subtitle {
        font-size: 12px;
        color: var(--text-secondary);
    }

    .search-loading {
        padding: var(--spacing-lg);
        text-align: center;
        color: var(--text-secondary);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
    }

    .search-loading i {
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    /* Standalone mode specific search modal positioning */
    @media all and (display-mode: standalone) {
        .search-modal {
            padding-top: calc(env(safe-area-inset-top, 20px) + 10px);
        }
        
        .search-modal-content {
            max-height: 45vh;
        }
    }

    /* Mobile keyboard handling for search modal */
    @media (max-height: 600px) {
        .search-modal {
            padding-top: calc(env(safe-area-inset-top, 0) + 10px);
        }
        
        .search-modal-content {
            max-height: 40vh;
        }
        
        .search-results {
            max-height: 120px;
        }
    }

    @media (max-height: 500px) {
        .search-modal {
            padding-top: calc(env(safe-area-inset-top, 0) + 5px);
        }
        
        .search-modal-content {
            max-height: 35vh;
        }
        
        .search-results {
            max-height: 100px;
        }
    }

    /* Standalone mode keyboard handling */
    @media all and (display-mode: standalone) and (max-height: 600px) {
        .search-modal {
            padding-top: calc(env(safe-area-inset-top, 20px) + 5px);
        }
        
        .search-modal-content {
            max-height: 35vh;
        }
    }

    @media all and (display-mode: standalone) and (max-height: 500px) {
        .search-modal {
            padding-top: calc(env(safe-area-inset-top, 20px) + 2px);
        }
        
        .search-modal-content {
            max-height: 30vh;
        }
    }
    
    /* Utility Selector - Premium Glass Design */
    .utility-selector {
        display: flex;
        gap: 2px;
        justify-content: center;
        margin: 0 auto 0 80px;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-2xl);
        padding: 6px;
        box-shadow: var(--shadow-lg), inset 0 1px 0 var(--border-color);
        max-width: fit-content;
        border: 1px solid var(--border-color);
        position: relative;
    }
    
    .utility-selector::before {
        content: '';
        position: absolute;
        inset: -1px;
        background: var(--gradient-primary);
        border-radius: inherit;
        opacity: 0;
        filter: blur(20px);
        transition: opacity var(--transition-normal);
        z-index: -1;
    }
    
    .utility-selector:hover::before {
        opacity: 0.3;
    }
    
    .utility-btn {
        width: 48px;
        height: 48px;
        border: none;
        background: transparent;
        border-radius: var(--radius-xl);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
        position: relative;
        overflow: hidden;
    }
    
    .utility-btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at center, currentColor, transparent);
        opacity: 0;
        transition: opacity var(--transition-fast);
    }
    
    .utility-btn.active::before {
        opacity: 0.2;
    }
    
    .utility-btn::after {
        content: '';
        position: absolute;
        inset: -50%;
        background: radial-gradient(circle at center, currentColor, transparent);
        opacity: 0;
        transform: scale(0);
        transition: all var(--transition-spring);
    }
    
    .utility-btn.active::after {
        opacity: 0.1;
        transform: scale(1);
    }
    
    .utility-btn:active {
        transform: scale(0.92);
    }
    
    .utility-btn i {
        font-size: 22px;
        color: var(--text-tertiary);
        position: relative;
        z-index: 1;
        transition: all var(--transition-normal);
    }
    
    .utility-btn.active i {
        color: currentColor;
        transform: scale(1.15);
        filter: drop-shadow(0 0 8px currentColor);
    }
    
    .utility-btn.water { color: var(--water-color); }
    .utility-btn.gas { color: var(--gas-color); }
    .utility-btn.electric { color: var(--electric-color); }
    .utility-btn.sewer { color: var(--sewer-color); }
    .utility-btn.telecom { color: var(--telecom-color); }
    
    /* Premium Bottom Controls */
    .bottom-controls {
        position: absolute;
        /* Use fixed positioning from viewport bottom with extra spacing */
        bottom: calc(env(safe-area-inset-bottom, 0) + 60px);
        left: var(--spacing-md);
        right: var(--spacing-md);
        /* Add extra padding to ensure buttons aren't cut off */
        padding-bottom: var(--spacing-xl);
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        z-index: 100;
        pointer-events: none;
        gap: var(--spacing-md);
    }
    
    .bottom-controls > * {
        pointer-events: auto;
    }
    
    /* Control Groups */
    .control-group {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
    }
    
    .control-group.center {
        position: relative;
    }
    
    /* Premium Control Buttons */
    .control-btn {
        width: 56px;
        height: 56px;
        border: none;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-lg);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-lg);
        transition: all var(--transition-normal);
        position: relative;
        overflow: hidden;
        border: 1px solid var(--border-color);
    }
    
    .control-btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: var(--gradient-glass);
        opacity: 0;
        transition: opacity var(--transition-normal);
    }
    
    .control-btn:hover::before {
        opacity: 1;
    }
    
    .control-btn:active {
        transform: scale(0.92);
        box-shadow: var(--shadow-md);
    }
    
    .control-btn:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-xl);
    }
    
    .control-btn::after {
        content: '';
        position: absolute;
        inset: -2px;
        background: inherit;
        border-radius: inherit;
        opacity: 0;
        filter: blur(10px);
        transition: opacity var(--transition-normal);
        z-index: -1;
    }
    
    .control-btn.active::after {
        opacity: 0.3;
    }
    
    .control-btn.active {
        background: var(--gradient-primary);
        border-color: transparent;
    }
    
    .control-btn i {
        font-size: 24px;
        color: var(--text-primary);
        transition: all var(--transition-normal);
        z-index: 1;
    }
    
    .control-btn.active i {
        color: white;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }
    
    /* Main Action Button Group */
    .main-action-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-sm);
        position: relative;
    }
    
    /* Line Type Toggle - Premium Floating Design */
    .line-type-toggle {
        display: flex;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-full);
        padding: 4px;
        box-shadow: var(--shadow-lg);
        border: 1px solid var(--border-color);
        order: 2;
        margin-top: var(--spacing-xs);
    }
    
    .line-type-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        border: none;
        background: transparent;
        border-radius: var(--radius-full);
        font-size: 13px;
        font-weight: 600;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all var(--transition-normal);
        white-space: nowrap;
        position: relative;
    }
    
    .line-type-btn.active {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    /* Main Draw Button - Premium Animated */
    .main-action-btn {
        width: 72px;
        height: 72px;
        border: none;
        background: var(--gradient-primary);
        border-radius: var(--radius-2xl);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-xl), 0 0 40px rgba(102, 126, 234, 0.3);
        transition: all var(--transition-spring);
        position: relative;
        overflow: hidden;
        order: 1;
    }
    
    .main-action-btn::before {
        content: '';
        position: absolute;
        inset: -2px;
        background: var(--gradient-primary);
        border-radius: inherit;
        opacity: 0;
        filter: blur(15px);
        transition: opacity var(--transition-normal);
    }
    
    .main-action-btn:hover::before {
        opacity: 0.5;
    }
    
    .main-action-btn:active {
        transform: scale(0.92);
        box-shadow: var(--shadow-lg);
    }
    
    .main-action-btn.active {
        animation: drawPulse 2s ease-in-out infinite;
    }
    
    @keyframes drawPulse {
        0%, 100% { 
            box-shadow: var(--shadow-xl), 0 0 40px rgba(102, 126, 234, 0.3);
        }
        50% { 
            box-shadow: var(--shadow-xl), 0 0 60px rgba(102, 126, 234, 0.6);
        }
    }
    
    .main-action-btn i {
        font-size: 32px;
        color: white;
        z-index: 1;
    }
    
    /* Excavation Button - Premium Danger Style */
    .excavation-btn {
        background: var(--gradient-danger) !important;
        position: relative;
        overflow: visible !important;
    }
    
    .excavation-btn::after {
        content: '';
        position: absolute;
        inset: -20px;
        background: var(--gradient-danger);
        border-radius: 50%;
        opacity: 0;
        filter: blur(20px);
        animation: none;
        transition: all var(--transition-normal);
        z-index: -1;
    }
    
    .excavation-btn.active::after {
        animation: excavationPulse 2s ease-in-out infinite;
    }
    
    @keyframes excavationPulse {
        0%, 100% { 
            opacity: 0;
            transform: scale(0.8);
        }
        50% { 
            opacity: 0.5;
            transform: scale(1.2);
        }
    }
    
    .excavation-btn i {
        color: white !important;
    }
    
    /* Right Side Controls */
    .right-controls {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
        position: absolute;
        right: var(--spacing-md);
        top: 45%;
        transform: translateY(-50%);
        z-index: 100;
    }
    
    /* Orientation Permission Button - iOS Standalone Mode */
    .orientation-permission-btn {
        width: 56px;
        height: 56px;
        background: var(--gradient-primary);
        border: none;
        border-radius: var(--radius-lg);
        display: none; /* Hidden by default */
        align-items: center;
        justify-content: center;
        box-shadow: var(--shadow-lg), 0 0 20px rgba(102, 126, 234, 0.4);
        cursor: pointer;
        transition: all var(--transition-spring);
        animation: orientationPulse 2s ease-in-out infinite;
        margin-bottom: var(--spacing-sm);
    }
    
    .orientation-permission-btn.show {
        display: flex;
    }
    
    @keyframes orientationPulse {
        0%, 100% {
            box-shadow: var(--shadow-lg), 0 0 20px rgba(102, 126, 234, 0.4);
        }
        50% {
            box-shadow: var(--shadow-xl), 0 0 30px rgba(102, 126, 234, 0.7);
        }
    }
    
    .orientation-permission-btn:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: var(--shadow-xl), 0 0 25px rgba(102, 126, 234, 0.6);
    }
    
    .orientation-permission-btn:active {
        transform: scale(0.95);
    }
    
    .orientation-permission-btn i {
        font-size: 24px;
        color: white;
    }
    
    /* Measurement Tools */
    .measurement-tools {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
        position: absolute;
        left: var(--spacing-md);
        top: 45%;
        transform: translateY(-50%);
        z-index: 100;
    }
    
    .measurement-btn {
        width: 52px;
        height: 52px;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-md);
        transition: all var(--transition-normal);
    }
    
    .measurement-btn.active {
        background: var(--gradient-primary);
        border-color: transparent;
    }
    
    .measurement-btn i {
        font-size: 22px;
        color: var(--text-primary);
    }
    
    .measurement-btn.active i {
        color: white;
    }
    
    /* Ultra Premium GPS Location System */
    .user-location-marker {
        pointer-events: none;
        z-index: 1000 !important;
        transform-origin: center center;
        will-change: transform;
        opacity: 1.0 !important; /* Always visible regardless of zoom */
        visibility: visible !important; /* Force visibility */
        display: block !important; /* Force display */
    }
    
    /* Ensure all child elements of location marker are visible */
    .user-location-marker * {
        opacity: inherit !important;
        visibility: visible !important;
    }
    
    /* Specific targeting for location container */
    .location-container {
        opacity: 1.0 !important;
        visibility: visible !important;
        display: flex !important;
    }
    
    .location-container {
        position: relative;
        width: 56px;
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    /* Multi-Layer Accuracy System */
    .location-accuracy {
        position: absolute;
        inset: -20px;
        border-radius: 50%;
        background: radial-gradient(circle at center, 
            rgba(0, 245, 160, 0.12) 0%, 
            rgba(0, 245, 160, 0.06) 40%,
            rgba(0, 245, 160, 0.02) 70%,
            transparent 100%);
        border: 2px solid rgba(0, 245, 160, 0.3);
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        animation: accuracyPulse 6s ease-in-out infinite;
    }
    
    .location-accuracy::before {
        content: '';
        position: absolute;
        inset: 8px;
        border-radius: 50%;
        border: 1px solid rgba(0, 245, 160, 0.15);
        animation: accuracyPulseInner 4s ease-in-out infinite;
    }
    
    @keyframes accuracyPulse {
        0%, 100% { 
            transform: scale(0.85); 
            opacity: 0.7; 
        }
        50% { 
            transform: scale(1.15); 
            opacity: 0.4; 
        }
    }
    
    @keyframes accuracyPulseInner {
        0%, 100% { 
            transform: scale(1.2); 
            opacity: 0.3; 
        }
        50% { 
            transform: scale(0.8); 
            opacity: 0.8; 
        }
    }
    
    /* Premium GPS Signal Indicator */
    .location-signal {
        position: absolute;
        inset: -30px;
        border-radius: 50%;
        border: 1px solid rgba(0, 245, 160, 0.2);
        animation: signalWave 3s ease-out infinite;
        opacity: 0;
    }
    
    .location-signal:nth-child(2) { animation-delay: 0.8s; }
    .location-signal:nth-child(3) { animation-delay: 1.6s; }
    
    @keyframes signalWave {
        0% {
            transform: scale(0.3);
            opacity: 0.8;
        }
        70% {
            opacity: 0.2;
        }
        100% {
            transform: scale(1.8);
            opacity: 0;
        }
    }
    
    /* Ultra Smooth Direction Arrow */
    .location-arrow {
        position: relative;
        width: 36px;
        height: 36px;
        transform-origin: center center;
        transition: transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        z-index: 3;
        filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.3));
    }
    
    .location-arrow::before {
        content: '';
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 14px solid transparent;
        border-right: 14px solid transparent;
        border-bottom: 32px solid #ffffff;
        filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.2));
    }
    
    .location-arrow::after {
        content: '';
        position: absolute;
        top: 3px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 11px solid transparent;
        border-right: 11px solid transparent;
        border-bottom: 26px solid rgba(0, 245, 160, 1);
    }
    
    /* Premium Center Dot with Status */
    .location-center {
        position: absolute;
        bottom: 6px;
        left: 50%;
        transform: translateX(-50%);
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ffffff 0%, #f0fff0 100%);
        border: 3px solid rgba(0, 245, 160, 1);
        box-shadow: 
            0 0 16px rgba(0, 245, 160, 0.6),
            inset 0 1px 2px rgba(255, 255, 255, 0.8);
        z-index: 4;
        transition: all 0.3s ease;
    }
    
    /* GPS Quality States */
    .location-container[data-gps-quality="excellent"] .location-accuracy {
        border-color: rgba(0, 245, 160, 0.5);
        background: radial-gradient(circle at center, 
            rgba(0, 245, 160, 0.15) 0%, 
            rgba(0, 245, 160, 0.08) 40%,
            transparent 70%);
    }
    
    .location-container[data-gps-quality="good"] .location-accuracy {
        border-color: rgba(154, 245, 0, 0.4);
        background: radial-gradient(circle at center, 
            rgba(154, 245, 0, 0.12) 0%, 
            rgba(154, 245, 0, 0.06) 40%,
            transparent 70%);
    }
    
    .location-container[data-gps-quality="fair"] .location-accuracy {
        border-color: rgba(255, 214, 10, 0.4);
        background: radial-gradient(circle at center, 
            rgba(255, 214, 10, 0.12) 0%, 
            rgba(255, 214, 10, 0.06) 40%,
            transparent 70%);
    }
    
    .location-container[data-gps-quality="poor"] .location-accuracy {
        border-color: rgba(255, 69, 0, 0.4);
        background: radial-gradient(circle at center, 
            rgba(255, 69, 0, 0.12) 0%, 
            rgba(255, 69, 0, 0.06) 40%,
            transparent 70%);
    }
    
    /* Smooth Movement States */
    .location-container[data-moving="true"] .location-center {
        animation: movingPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes movingPulse {
        0%, 100% { 
            transform: translateX(-50%) scale(1);
            box-shadow: 0 0 16px rgba(0, 245, 160, 0.6);
        }
        50% { 
            transform: translateX(-50%) scale(1.2);
            box-shadow: 0 0 24px rgba(0, 245, 160, 0.8);
        }
    }
    
    /* Drawing UI - Premium Floating */
    .drawing-ui {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + 80px);
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-lg);
        box-shadow: var(--shadow-xl);
        z-index: 200;
        display: none;
        text-align: center;
        min-width: 280px;
        border: 1px solid var(--border-color);
    }
    
    .drawing-ui.active {
        display: block;
        animation: slideInDown var(--transition-bounce) ease-out;
    }
    
    @keyframes slideInDown {
        from {
            opacity: 0;
            transform: translate(-50%, -30px);
        }
        to {
            opacity: 1;
            transform: translate(-50%, 0);
        }
    }
    
    .drawing-ui h3 {
        font-size: 18px;
        font-weight: 700;
        margin-bottom: var(--spacing-sm);
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .drawing-ui p {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        font-weight: 500;
    }
    
    .drawing-actions {
        display: flex;
        gap: var(--spacing-sm);
        justify-content: center;
    }
    
    .drawing-btn {
        padding: var(--spacing-sm) var(--spacing-lg);
        border: none;
        border-radius: var(--radius-md);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
    }
    
    .drawing-btn.primary {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    .drawing-btn.secondary {
        background: var(--bg-glass-light);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
    }
    
    .drawing-btn:active {
        transform: scale(0.95);
    }
    
    /* Refine Mode Overlay */
    .refine-overlay {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + 80px);
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-md) var(--spacing-lg);
        box-shadow: var(--shadow-xl);
        z-index: 250;
        display: none;
        text-align: center;
        border: 1px solid var(--border-color);
    }
    
    .refine-overlay.active {
        display: block;
        animation: slideInDown var(--transition-bounce) ease-out;
    }
    
    .refine-overlay span {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
        margin-right: var(--spacing-md);
    }
    
    /* Utility Info Modal - Premium Glass */
    .info-modal {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0) + 120px);
        left: var(--spacing-md);
        right: var(--spacing-md);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-2xl);
        box-shadow: var(--shadow-xl);
        z-index: 300;
        transform: translateY(calc(100% + env(safe-area-inset-bottom, 0) + 120px));
        transition: transform var(--transition-spring);
        max-height: calc(75vh - env(safe-area-inset-bottom, 0));
        overflow: hidden;
        display: flex;
        flex-direction: column;
        border: 1px solid var(--border-color);
    }
    
    .info-modal.active {
        transform: translateY(0);
    }
    
    .modal-handle {
        width: 48px;
        height: 5px;
        background: var(--text-tertiary);
        border-radius: var(--radius-full);
        margin: var(--spacing-sm) auto;
        opacity: 0.5;
    }
    
    .modal-header {
        padding: 0 var(--spacing-lg) var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .modal-title {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        font-size: 20px;
        font-weight: 700;
    }
    
    .modal-title i {
        font-size: 24px;
        filter: drop-shadow(0 0 8px currentColor);
    }
    
    .modal-close {
        width: 40px;
        height: 40px;
        border: none;
        background: var(--bg-glass-light);
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
    }
    
    .modal-close:active {
        transform: scale(0.9);
    }
    
    .modal-body {
        padding: var(--spacing-lg);
        overflow-y: auto;
        flex: 1;
    }
    
    .info-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-lg);
        margin-bottom: var(--spacing-lg);
    }
    
    .info-item {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
    }
    
    .info-label {
        font-size: 12px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .info-value {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
    }
    
    .modal-actions {
        display: flex;
        gap: var(--spacing-sm);
        padding-top: var(--spacing-lg);
        border-top: 1px solid var(--border-color);
    }
    
    .modal-btn {
        flex: 1;
        padding: var(--spacing-md);
        border: none;
        border-radius: var(--radius-md);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
    }
    
    .modal-btn.primary {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    .modal-btn.danger {
        background: var(--gradient-danger);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    .modal-btn:active {
        transform: scale(0.95);
    }
    
    /* Edit Form */
    .edit-form {
        display: none;
    }
    
    .edit-form.active {
        display: block;
    }
    
    .form-group {
        margin-bottom: var(--spacing-lg);
    }
    
    .form-label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-sm);
    }
    
    .form-input {
        width: 100%;
        padding: var(--spacing-md);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-glass-light);
        color: var(--text-primary);
        font-size: 16px;
        font-weight: 500;
        transition: all var(--transition-normal);
    }
    
    .form-input:focus {
        outline: none;
        border-color: #667eea;
        background: var(--bg-secondary);
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }
    
    .form-select {
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236c757d' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 16px center;
        padding-right: 40px;
    }
    
    /* Premium Minimalist Excavation Mode */
    .excavation-overlay {
        position: fixed;
        inset: 0;
        background: 
            radial-gradient(circle at center, rgba(255, 107, 53, 0.04) 0%, transparent 50%),
            linear-gradient(180deg, rgba(255, 255, 255, 0.01) 0%, rgba(0, 0, 0, 0.02) 100%);
        backdrop-filter: blur(0.5px) saturate(105%);
        -webkit-backdrop-filter: blur(0.5px) saturate(105%);
        z-index: 400;
        opacity: 0;
        pointer-events: none;
        transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
    }
    
    .excavation-overlay.active {
        opacity: 1;
        pointer-events: auto;
    }
    
    .excavation-overlay::before {
        content: '';
        position: absolute;
        inset: 0;
        background: 
            radial-gradient(800px circle at var(--mouse-x, 50%) var(--mouse-y, 50%), 
                rgba(255, 107, 53, 0.06) 0%, 
                transparent 40%);
        transition: opacity 0.4s ease;
        opacity: 0;
    }
    
    .excavation-overlay:hover::before {
        opacity: 1;
    }
    
    /* Premium Minimalist Radar Effect */
    .excavation-radar {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 600px;
        height: 600px;
        pointer-events: none;
        opacity: 0.7;
    }
    
    .radar-ring {
        position: absolute;
        inset: 0;
        border: 0.5px solid rgba(255, 107, 53, 0.4);
        border-radius: 50%;
        opacity: 0;
        animation: premiumRadarPulse 6s cubic-bezier(0.23, 1, 0.32, 1) infinite;
    }
    
    .radar-ring:nth-child(2) {
        animation-delay: 2s;
        border-color: rgba(255, 107, 53, 0.3);
    }
    
    .radar-ring:nth-child(3) {
        animation-delay: 4s;
        border-color: rgba(255, 107, 53, 0.2);
    }
    
    @keyframes premiumRadarPulse {
        0% {
            transform: scale(0.1);
            opacity: 0;
            border-width: 0.5px;
        }
        20% {
            opacity: 0.6;
            border-width: 1px;
        }
        50% {
            opacity: 0.4;
            border-width: 0.5px;
        }
        80% {
            opacity: 0.1;
            border-width: 0.25px;
        }
        100% {
            transform: scale(1);
            opacity: 0;
            border-width: 0px;
        }
    }
    
    /* Premium Minimalist Header */
    .excavation-header {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + 24px);
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 120px);
        max-width: 380px;
        padding: 16px 24px;
        background: rgba(255, 255, 255, 0.75);
        backdrop-filter: blur(24px) saturate(180%);
        -webkit-backdrop-filter: blur(24px) saturate(180%);
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.6);
        box-shadow: 
            0 16px 64px rgba(0, 0, 0, 0.15),
            0 4px 16px rgba(0, 0, 0, 0.1),
            inset 0 1px 0 rgba(255, 255, 255, 0.8);
        color: rgba(0, 0, 0, 0.87);
        z-index: 1600;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1);
    }
    
    .excavation-header:hover {
        background: rgba(255, 255, 255, 0.85);
        border-color: rgba(255, 107, 53, 0.4);
        transform: translateX(-50%) translateY(-2px);
        box-shadow: 
            0 20px 80px rgba(0, 0, 0, 0.18),
            0 8px 32px rgba(0, 0, 0, 0.12),
            inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }
    
    .excavation-info {
        flex: 1;
        text-align: center;
    }
    
    .excavation-info h2 {
        font-size: 16px;
        font-weight: 700;
        margin: 0 0 4px 0;
        color: rgba(0, 0, 0, 0.95);
        letter-spacing: -0.2px;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
    }
    
    .excavation-info p {
        font-size: 13px;
        font-weight: 500;
        margin: 0;
        color: rgba(0, 0, 0, 0.75);
        letter-spacing: -0.1px;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.6);
    }
    
    .excavation-toggle {
        width: 36px;
        height: 36px;
        background: rgba(0, 0, 0, 0.04);
        border: none;
        border-radius: 12px;
        color: rgba(0, 0, 0, 0.6);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        font-size: 14px;
        flex-shrink: 0;
        position: relative;
        overflow: hidden;
    }
    
    .excavation-toggle::before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, rgba(255, 107, 53, 0.1), rgba(255, 107, 53, 0.05));
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .excavation-toggle:hover {
        background: rgba(0, 0, 0, 0.06);
        color: rgba(0, 0, 0, 0.8);
        transform: scale(1.05);
    }
    
    .excavation-toggle:hover::before {
        opacity: 1;
    }
    
    .excavation-toggle:active {
        transform: scale(0.95);
    }
    
    .excavation-toggle.alerts-hidden {
        background: rgba(255, 107, 53, 0.1);
        color: rgba(255, 107, 53, 0.8);
    }
    
    .excavation-toggle.alerts-hidden:hover {
        background: rgba(255, 107, 53, 0.15);
        color: rgba(255, 107, 53, 1);
    }
    

    
    .excavation-header h2 {
        font-size: 18px;
        font-weight: 800;
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 1px;
        text-shadow: 0 0 15px rgba(255, 0, 84, 0.8);
        background: linear-gradient(135deg, #ffffff 0%, #ff0054 50%, #ffffff 100%);
        background-size: 200% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: headerShimmer 3s ease-in-out infinite;
    }
    
    @keyframes headerShimmer {
        0%, 100% { background-position: 200% center; }
        50% { background-position: 0% center; }
    }
    
    .excavation-header p {
        font-size: 12px;
        opacity: 0.9;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.8);
    }
    
    /* Enhanced Utility Visibility During Excavation */
    .utility-line.excavation-enhanced {
        filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 3px 16px rgba(0, 0, 0, 0.8)) !important;
        animation: excavationUtilityPulse 2.5s ease-in-out infinite;
    }
    
    .excavation-overlay.active ~ .app-container .structure-marker {
        filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.6));
        transform: scale(1.2);
        animation: excavationStructurePulse 1.5s ease-in-out infinite;
    }
    
    @keyframes excavationUtilityPulse {
        0%, 100% {
            filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 3px 16px rgba(0, 0, 0, 0.8));
        }
        50% {
            filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 5px 24px rgba(0, 0, 0, 0.9));
        }
    }
    
    @keyframes excavationStructurePulse {
        0%, 100% {
            filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.6));
            transform: scale(1.2);
        }
        50% {
            filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 6px 24px rgba(0, 0, 0, 0.8));
            transform: scale(1.3);
        }
    }
    
    @keyframes depthPulse {
        0%, 100% {
            opacity: 1;
            transform: scale(1);
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
        }
        50% {
            opacity: 0.9;
            transform: scale(1.02);
            box-shadow: 0 4px 16px rgba(255, 107, 53, 0.6);
        }
    }
    
    /* Premium Minimalist Proximity Alerts - Square Grid Layout */
    .proximity-alerts {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + 120px);
        left: 24px;
        right: 24px;
        bottom: calc(env(safe-area-inset-bottom, 0) + 120px);
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 16px;
        z-index: 402;
        overflow-y: auto;
        pointer-events: none;
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1);
        padding: 8px;
        scrollbar-width: none;
        -ms-overflow-style: none;
        grid-auto-rows: minmax(200px, auto);
    }
    
    .proximity-alerts::-webkit-scrollbar {
        display: none;
    }
    
    .proximity-alerts.hidden {
        opacity: 0;
        transform: translateY(-24px) scale(0.96);
        pointer-events: none;
    }
    
    .proximity-alerts > * {
        pointer-events: auto;
    }
    
    .proximity-alert {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: 20px;
        box-shadow: 
            0 8px 32px rgba(0, 0, 0, 0.06),
            0 2px 8px rgba(0, 0, 0, 0.04),
            inset 0 1px 0 rgba(255, 255, 255, 0.8);
        overflow: hidden;
        animation: premiumAlertSlideIn 0.8s cubic-bezier(0.23, 1, 0.32, 1);
        position: relative;
        border: 0.5px solid rgba(255, 255, 255, 0.2);
        transform-origin: center;
        transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        aspect-ratio: 1;
        min-height: 200px;
        max-height: 200px;
        display: flex;
        flex-direction: column;
    }
    
    .proximity-alert:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 
            0 16px 64px rgba(0, 0, 0, 0.12),
            0 4px 16px rgba(0, 0, 0, 0.08),
            inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }
    
    .proximity-alert.water::before { 
        background: linear-gradient(135deg, rgba(0, 180, 216, 0.1), rgba(0, 180, 216, 0.05));
    }
    .proximity-alert.gas::before { 
        background: linear-gradient(135deg, rgba(255, 214, 10, 0.1), rgba(255, 214, 10, 0.05));
    }
    .proximity-alert.electric::before { 
        background: linear-gradient(135deg, rgba(255, 0, 110, 0.1), rgba(255, 0, 110, 0.05));
    }
    .proximity-alert.sewer::before { 
        background: linear-gradient(135deg, rgba(168, 118, 62, 0.1), rgba(168, 118, 62, 0.05));
    }
    .proximity-alert.telecom::before { 
        background: linear-gradient(135deg, rgba(181, 101, 216, 0.1), rgba(181, 101, 216, 0.05));
    }
    
    .proximity-alert::before {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 20px;
        opacity: 0.6;
        pointer-events: none;
    }
    
    @keyframes premiumAlertSlideIn {
        0% {
            opacity: 0;
            transform: translateY(-32px) scale(0.9);
            filter: blur(4px);
        }
        50% {
            opacity: 0.7;
            transform: translateY(-8px) scale(0.95);
            filter: blur(1px);
        }
        100% {
            opacity: 1;
            transform: translateY(0) scale(1);
            filter: blur(0px);
        }
    }
    
    .alert-content {
        padding: 16px;
        position: relative;
        z-index: 1;
        display: flex;
        flex-direction: column;
        gap: 12px;
        height: 100%;
        justify-content: space-between;
    }
    
    .alert-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 0;
    }
    
    .alert-icon-container {
        width: 32px;
        height: 32px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        position: relative;
        overflow: hidden;
    }
    
    .alert-icon-container.water { 
        background: rgba(0, 180, 216, 0.08);
        color: rgba(0, 180, 216, 0.8);
    }
    .alert-icon-container.gas { 
        background: rgba(255, 214, 10, 0.08);
        color: rgba(255, 214, 10, 0.8);
    }
    .alert-icon-container.electric { 
        background: rgba(255, 0, 110, 0.08);
        color: rgba(255, 0, 110, 0.8);
    }
    .alert-icon-container.sewer { 
        background: rgba(168, 118, 62, 0.08);
        color: rgba(168, 118, 62, 0.8);
    }
    .alert-icon-container.telecom { 
        background: rgba(181, 101, 216, 0.08);
        color: rgba(181, 101, 216, 0.8);
    }
    
    .alert-icon-container i {
        font-size: 16px;
        z-index: 1;
    }
    
    .alert-close {
        width: 28px;
        height: 28px;
        border: none;
        background: rgba(0, 0, 0, 0.03);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        color: rgba(0, 0, 0, 0.4);
        font-size: 11px;
        flex-shrink: 0;
    }
    
    .alert-close:hover {
        background: rgba(0, 0, 0, 0.06);
        color: rgba(0, 0, 0, 0.6);
        transform: scale(1.05);
    }
    
    .alert-close:active {
        transform: scale(0.95);
    }
    
    .alert-utility-info {
        text-align: left;
        margin-bottom: 0;
    }
    
    .alert-utility-type {
        font-size: 18px;
        font-weight: 600;
        color: rgba(0, 0, 0, 0.87);
        text-transform: capitalize;
        letter-spacing: -0.3px;
        margin: 0 0 4px 0;
        line-height: 1.2;
    }
    
    .alert-line-type {
        font-size: 13px;
        color: rgba(0, 0, 0, 0.6);
        font-weight: 500;
        margin: 0;
        text-transform: capitalize;
        letter-spacing: -0.1px;
    }
    
    .alert-distance-banner {
        text-align: center;
        margin-bottom: 0;
        padding: 12px 16px;
        border-radius: 12px;
        background: linear-gradient(135deg, rgba(255, 107, 53, 0.08), rgba(255, 107, 53, 0.04));
        border: 0.5px solid rgba(255, 107, 53, 0.12);
    }
    
    .distance-value {
        display: block;
        font-size: 24px;
        font-weight: 700;
        line-height: 1;
        color: rgba(255, 107, 53, 0.9);
        margin-bottom: 4px;
        letter-spacing: -0.5px;
    }
    
    .distance-unit {
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 0.5px;
        text-transform: uppercase;
        color: rgba(255, 107, 53, 0.7);
    }
    
    .alert-details {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
    }
    
    .detail-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.02);
        border-radius: 8px;
        border: 0.5px solid rgba(0, 0, 0, 0.06);
    }
    
    .detail-label {
        font-size: 11px;
        font-weight: 500;
        color: rgba(0, 0, 0, 0.5);
        text-transform: uppercase;
        letter-spacing: 0.3px;
        margin: 0;
    }
    
    .detail-value {
        font-size: 13px;
        font-weight: 600;
        color: rgba(0, 0, 0, 0.8);
        letter-spacing: -0.1px;
        margin: 0;
    }
    
    /* Exit Excavation Button */
    .exit-excavation {
        position: absolute;
        bottom: calc(env(safe-area-inset-bottom, 0) + 150px);
        left: 50%;
        transform: translateX(-50%);
        padding: var(--spacing-md) var(--spacing-xl);
        background: white;
        color: var(--danger-color);
        border: none;
        border-radius: var(--radius-full);
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: var(--shadow-xl);
        transition: all var(--transition-spring);
        z-index: 403;
    }
    
    .exit-excavation:active {
        transform: translateX(-50%) scale(0.95);
    }
    
    /* Settings Panel - Premium Slide */
    .settings-panel {
        position: fixed;
        top: 0;
        right: -100%;
        bottom: 0;
        width: 85%;
        max-width: 380px;
        background: var(--bg-primary);
        box-shadow: -8px 0 32px var(--shadow-xl);
        z-index: 500;
        transition: right var(--transition-spring);
        overflow-y: auto;
        padding-top: env(safe-area-inset-top, 0);
        padding-bottom: calc(env(safe-area-inset-bottom, 0) + var(--spacing-xl));
    }
    
    .settings-panel.active {
        right: 0;
    }
    
    .settings-header {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .settings-header h2 {
        font-size: 24px;
        font-weight: 800;
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .settings-section {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
    }
    
    .settings-section h3 {
        font-size: 12px;
        font-weight: 700;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    /* Premium Toggle Switch */
    .toggle-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--spacing-md);
    }
    
    .toggle-label {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        font-size: 14px;
        font-weight: 600;
    }
    
    .toggle-switch {
        position: relative;
        width: 56px;
        height: 32px;
        border: none;
        background: var(--bg-tertiary);
        border-radius: var(--radius-full);
        cursor: pointer;
        transition: all var(--transition-normal);
    }
    
    .toggle-switch.active {
        background: var(--gradient-success);
    }
    
    .toggle-switch::after {
        content: '';
        position: absolute;
        top: 4px;
        left: 4px;
        width: 24px;
        height: 24px;
        background: white;
        border-radius: var(--radius-full);
        transition: all var(--transition-spring);
        box-shadow: var(--shadow-sm);
    }
    
    .toggle-switch.active::after {
        transform: translateX(24px);
    }
    
    /* Map Style Selector */
    .map-styles {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-sm);
        max-height: 300px;
        overflow-y: auto;
    }
    
    .map-style-btn {
        padding: var(--spacing-md);
        border: 2px solid var(--border-color);
        background: var(--bg-secondary);
        border-radius: var(--radius-md);
        cursor: pointer;
        transition: all var(--transition-normal);
        text-align: center;
        font-size: 14px;
        font-weight: 600;
    }
    
    .map-style-btn.active {
        border-color: transparent;
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    /* Utility Line Styles */
    .utility-line {
        stroke-width: 3; /* Made thinner and fixed */
        stroke-linecap: round;
        stroke-linejoin: round;
        fill: none;
        cursor: pointer;
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
        transition: all var(--transition-normal), opacity 0.3s ease-in-out;
        touch-action: manipulation;
        -webkit-touch-callout: default;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        pointer-events: auto; /* Visual line receives events for easier selection */
    }
    
    .utility-line.main {
        stroke-width: 4; /* Slightly thicker for main lines */
    }
    
    /* Invisible touch targets for easier utility selection */
    .utility-touch-target {
        stroke-width: 50; /* Large fixed touch area */
        stroke-linecap: round;
        stroke-linejoin: round;
        fill: none;
        cursor: pointer;
        opacity: 0;
        pointer-events: auto;
        touch-action: manipulation;
    }
    
    .utility-line:hover {
        filter: drop-shadow(0 4px 16px rgba(0, 0, 0, 0.4)) drop-shadow(0 0 12px currentColor);
        stroke-width: 5 !important; /* Slightly thicker on hover */
    }
    
    .utility-line.main:hover {
        stroke-width: 6 !important; /* Slightly thicker for main lines on hover */
    }
    
    .utility-line.service {
        stroke-dasharray: 8, 4; /* Smaller dash pattern */
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
    }
    
    .utility-line.water { 
        stroke: var(--water-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(0, 180, 216, 0.3));
    }
    .utility-line.gas { 
        stroke: var(--gas-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(255, 214, 10, 0.3));
    }
    .utility-line.electric { 
        stroke: var(--electric-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(255, 0, 110, 0.3));
    }
    .utility-line.sewer { 
        stroke: var(--sewer-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(168, 118, 62, 0.3));
    }
    .utility-line.telecom { 
        stroke: var(--telecom-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(181, 101, 216, 0.3));
    }
    
    .utility-line.drawing {
        opacity: 0.7;
        animation: drawingPulse 1.5s ease-in-out infinite;
    }
    
    .utility-line.highlighted {
        filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.5));
        stroke-width: 12 !important;
        opacity: 1 !important;
        animation: highlightGlow 2s ease-in-out infinite;
    }
    
    .utility-line.pressing {
        filter: drop-shadow(0 0 15px currentColor) drop-shadow(0 2px 12px rgba(0, 0, 0, 0.6));
        animation: pressingPulse 0.3s ease-in-out;
    }
    
    @keyframes drawingPulse {
        0%, 100% { 
            opacity: 0.5; 
            stroke-width: 6;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
        }
        50% { 
            opacity: 1; 
            stroke-width: 8;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.4)) drop-shadow(0 0 12px currentColor);
        }
    }
    
    @keyframes highlightGlow {
        0%, 100% { 
            filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.5));
        }
        50% { 
            filter: drop-shadow(0 0 30px currentColor) drop-shadow(0 6px 20px rgba(0, 0, 0, 0.6));
        }
    }
    
    @keyframes pressingPulse {
        0% { 
            filter: drop-shadow(0 0 8px currentColor) drop-shadow(0 2px 8px rgba(0, 0, 0, 0.4));
        }
        100% { 
            filter: drop-shadow(0 0 15px currentColor) drop-shadow(0 2px 12px rgba(0, 0, 0, 0.6));
        }
    }
    
    /* Connection Markers */
    .connection-marker {
        fill: white;
        stroke-width: 3;
        cursor: pointer;
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.4));
        transition: opacity 0.3s ease-in-out;
    }
    
    .connection-marker.t-junction {
        r: 10;
    }
    
    .connection-marker.endpoint {
        r: 8;
    }
    
    .connection-marker.structure {
        r: 12;
    }
    
    .connection-marker.water { stroke: var(--water-color); }
    .connection-marker.gas { stroke: var(--gas-color); }
    .connection-marker.electric { stroke: var(--electric-color); }
    .connection-marker.sewer { stroke: var(--sewer-color); }
    .connection-marker.telecom { stroke: var(--telecom-color); }
    
    /* Refine Points - Enhanced for Leaflet CircleMarkers */
    .leaflet-interactive {
        cursor: pointer;
    }
    
    .leaflet-interactive[style*="cursor: move"] {
        cursor: move !important;
    }
    
    /* Ensure refine markers are always visible and interactive */
    .leaflet-zoom-animated .leaflet-interactive {
        pointer-events: auto !important;
    }
    
    /* Legacy CSS for any SVG-based refine points */
    /* Premium Refine Mode Styles - Completely Redesigned */
    .refine-marker {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
    }
    
    .refine-point {
        width: 40px;
        height: 40px;
        background: linear-gradient(135deg, #ffffff 0%, #f0f8ff 100%);
        border: 4px solid #667eea;
        border-radius: 50%;
        cursor: move !important;
        box-shadow: 
            0 8px 32px rgba(102, 126, 234, 0.4), 
            0 0 0 2px rgba(255, 255, 255, 0.9),
            inset 0 2px 4px rgba(255, 255, 255, 0.5);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        z-index: 10000 !important;
        display: flex !important;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: #667eea;
        font-size: 16px;
        pointer-events: auto !important;
        user-select: none;
        animation: refinePointPulse 3s ease-in-out infinite;
    }
    
    .refine-point:before {
        content: '';
        position: absolute;
        inset: -6px;
        border-radius: 50%;
        background: conic-gradient(from 0deg, transparent, rgba(102, 126, 234, 0.3), transparent);
        animation: refinePointSpin 4s linear infinite;
        z-index: -1;
    }
    
    .refine-point.dragging {
        transform: scale(1.3) !important;
        border-color: #00f5a0;
        background: linear-gradient(135deg, #f0fff0 0%, #e6ffe6 100%);
        color: #00f5a0;
        box-shadow: 
            0 12px 48px rgba(0, 245, 160, 0.6), 
            0 0 0 3px rgba(255, 255, 255, 1),
            inset 0 2px 4px rgba(255, 255, 255, 0.7);
    }
    
    .refine-point.intermediate {
        animation: intermediateGlow 2s ease-in-out infinite;
        opacity: 0.8;
        border-width: 3px;
    }
    
    .refine-point.intermediate:hover {
        transform: scale(1.2) !important;
        opacity: 1;
        box-shadow: 
            0 6px 24px rgba(77, 148, 255, 0.6), 
            0 0 0 2px rgba(255, 255, 255, 1),
            inset 0 2px 4px rgba(255, 255, 255, 0.6);
    }
    
    @keyframes intermediateGlow {
        0%, 100% {
            box-shadow: 
                0 4px 16px rgba(77, 148, 255, 0.3), 
                0 0 0 1px rgba(255, 255, 255, 0.8),
                inset 0 2px 4px rgba(255, 255, 255, 0.4);
        }
        50% {
            box-shadow: 
                0 6px 20px rgba(77, 148, 255, 0.5), 
                0 0 0 2px rgba(255, 255, 255, 0.9),
                inset 0 2px 4px rgba(255, 255, 255, 0.5);
        }
    }
    
    @keyframes refinePointPulse {
        0%, 100% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.05);
            opacity: 0.95;
        }
    }
    
    @keyframes refinePointSpin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    /* Connection Dialog - Premium */
    .connection-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.9);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-xl);
        box-shadow: var(--shadow-xl);
        z-index: 600;
        min-width: 320px;
        opacity: 0;
        pointer-events: none;
        transition: all var(--transition-spring);
        border: 1px solid var(--border-color);
    }
    
    .connection-dialog.active {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        pointer-events: auto;
    }
    
    .connection-dialog h3 {
        font-size: 20px;
        font-weight: 700;
        margin-bottom: var(--spacing-md);
        text-align: center;
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .connection-dialog p {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        text-align: center;
        line-height: 1.5;
    }
    
    .connection-actions {
        display: flex;
        gap: var(--spacing-sm);
        justify-content: center;
    }
    
    /* Structure Markers - Premium Icons */
    .structure-marker {
        width: 48px;
        height: 48px;
        background: var(--bg-glass);
        backdrop-filter: blur(20px);
        border: 3px solid;
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        box-shadow: var(--shadow-lg);
        cursor: pointer;
        transition: all var(--transition-spring), opacity 0.3s ease-in-out;
    }
    
    .structure-marker.water { 
        border-color: var(--water-color); 
        color: var(--water-color); 
    }
    .structure-marker.gas { 
        border-color: var(--gas-color); 
        color: var(--gas-color); 
    }
    .structure-marker.electric { 
        border-color: var(--electric-color); 
        color: var(--electric-color); 
    }
    .structure-marker.sewer { 
        border-color: var(--sewer-color); 
        color: var(--sewer-color); 
    }
    .structure-marker.telecom { 
        border-color: var(--telecom-color); 
        color: var(--telecom-color); 
    }
    
    .structure-marker:hover {
        transform: scale(1.1);
        box-shadow: var(--shadow-xl), 0 0 20px currentColor;
    }
    
    /* Structure Container */
    .structure-container {
        position: absolute;
        right: var(--spacing-md);
        /* Adjust bottom position to account for safe area and new bottom controls height */
        bottom: calc(env(safe-area-inset-bottom, 0) + 250px);
        z-index: 95;
    }
    
    /* Add Structure Button - Compact Premium Design */
    .add-structure-btn {
        position: relative;
        width: 48px;
        height: 48px;
        background: var(--gradient-success);
        border: none;
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--shadow-lg), 0 0 20px rgba(0, 245, 160, 0.4);
        cursor: pointer;
        transition: all var(--transition-spring);
    }
    
    .add-structure-btn:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: var(--shadow-xl), 0 0 25px rgba(0, 245, 160, 0.5);
    }
    
    .add-structure-btn:active {
        transform: scale(0.9);
    }
    
    .add-structure-btn i {
        font-size: 20px;
        color: white;
    }
    
    .add-structure-btn.active {
        background: var(--gradient-warning);
        animation: structurePlacementPulse 2s ease-in-out infinite;
    }
    
    @keyframes structurePlacementPulse {
        0%, 100% { 
            box-shadow: var(--shadow-lg), 0 0 20px rgba(255, 214, 10, 0.4);
        }
        50% { 
            box-shadow: var(--shadow-xl), 0 0 30px rgba(255, 214, 10, 0.7);
        }
    }
    
    /* Structure Menu - Compact Premium Grid */
    .structure-menu {
        position: absolute;
        bottom: 60px;
        right: 0;
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-xl);
        padding: var(--spacing-md);
        display: none;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-sm);
        width: 280px;
        border: 1px solid var(--border-color);
        z-index: 1000;
        max-height: 350px;
        overflow-y: auto;
    }
    
    .structure-menu.active {
        display: grid !important;
        animation: menuPopIn var(--transition-bounce) ease-out;
    }
    
    @keyframes menuPopIn {
        from {
            opacity: 0;
            transform: scale(0.8) translateY(20px);
        }
        to {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
    }
    
    .structure-type-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-xs);
        padding: var(--spacing-sm);
        background: var(--bg-glass-light);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        cursor: pointer;
        transition: all var(--transition-normal);
        min-height: 60px;
    }
    
    .structure-type-btn:hover {
        background: var(--bg-tertiary);
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
    }
    
    .structure-type-btn:active {
        transform: scale(0.95);
    }
    
    .structure-type-btn i {
        font-size: 22px;
    }
    
    .structure-type-btn span {
        font-size: 10px;
        font-weight: 600;
        text-align: center;
        line-height: 1.2;
    }
    
    /* Toast Notifications - Premium */
    .toast-container {
        position: fixed;
        top: calc(env(safe-area-inset-top, 0) + var(--spacing-md));
        left: var(--spacing-md);
        right: var(--spacing-md);
        z-index: 1000;
        pointer-events: none;
    }
    
    .toast {
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-md);
        padding: var(--spacing-md) var(--spacing-lg);
        box-shadow: var(--shadow-xl);
        margin-bottom: var(--spacing-sm);
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
        opacity: 0;
        transform: translateY(-20px) scale(0.9);
        transition: all var(--transition-spring);
        pointer-events: auto;
        border: 1px solid var(--border-color);
    }
    
    .toast.show {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    
    .toast i {
        font-size: 24px;
        filter: drop-shadow(0 0 8px currentColor);
    }
    
    .toast span {
        font-weight: 600;
        font-size: 14px;
    }
    
    .toast.success i { color: var(--success-color); }
    .toast.error i { color: var(--danger-color); }
    .toast.warning i { color: var(--warning-color); }
    .toast.info i { color: var(--info-color); }
    
    /* Measurement Display */
    .measurement-display {
        position: absolute;
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-md);
        padding: var(--spacing-sm) var(--spacing-md);
        box-shadow: var(--shadow-lg);
        font-size: 14px;
        font-weight: 700;
        pointer-events: none;
        z-index: 200;
        border: 1px solid var(--border-color);
        color: var(--text-primary);
    }
    
    /* Notes Section */
    .notes-section {
        margin-top: var(--spacing-lg);
        padding-top: var(--spacing-lg);
        border-top: 1px solid var(--border-color);
    }
    
    .notes-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--spacing-md);
    }
    
    .notes-title {
        font-size: 16px;
        font-weight: 600;
    }
    
    .add-note-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        background: var(--bg-glass-light);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
        transition: all var(--transition-normal);
    }
    
    .add-note-btn:active {
        transform: scale(0.95);
    }
    
    .notes-list {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
    }
    
    .note-item {
        background: var(--bg-glass-light);
        padding: var(--spacing-md);
        border-radius: var(--radius-md);
        position: relative;
        border: 1px solid var(--border-color);
    }
    
    .note-text {
        font-size: 14px;
        line-height: 1.5;
        margin-bottom: var(--spacing-xs);
    }
    
    .note-date {
        font-size: 12px;
        color: var(--text-tertiary);
    }
    
    .note-delete {
        position: absolute;
        top: var(--spacing-sm);
        right: var(--spacing-sm);
        width: 24px;
        height: 24px;
        background: transparent;
        border: none;
        cursor: pointer;
        color: var(--text-tertiary);
        transition: all var(--transition-normal);
    }
    
    .note-delete:hover {
        color: var(--danger-color);
    }
    
    /* Cloud Sync Status */
    .sync-status {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0) + 130px);
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-full);
        padding: var(--spacing-sm) var(--spacing-lg);
        box-shadow: var(--shadow-md);
        font-size: 12px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        opacity: 0;
        pointer-events: none;
        transition: all var(--transition-normal);
        border: 1px solid var(--border-color);
    }
    
    .sync-status.show {
        opacity: 1;
    }
    
    .sync-status i {
        font-size: 14px;
        color: var(--info-color);
        animation: syncSpin 2s linear infinite;
    }
    
    @keyframes syncSpin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    /* Note Input Modal */
    .note-input-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 650;
        opacity: 0;
        pointer-events: none;
        transition: opacity var(--transition-normal);
        padding: var(--spacing-lg);
    }
    
    .note-input-modal.active {
        opacity: 1;
        pointer-events: auto;
    }
    
    .note-input-content {
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-xl);
        box-shadow: var(--shadow-xl);
        width: 100%;
        max-width: 400px;
        border: 1px solid var(--border-color);
    }
    
    .note-input-header {
        font-size: 18px;
        font-weight: 700;
        margin-bottom: var(--spacing-lg);
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .note-textarea {
        width: 100%;
        min-height: 120px;
        padding: var(--spacing-md);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-glass-light);
        color: var(--text-primary);
        font-size: 14px;
        font-family: inherit;
        resize: vertical;
        transition: all var(--transition-normal);
    }
    
    .note-textarea:focus {
        outline: none;
        border-color: #667eea;
        background: var(--bg-secondary);
    }
    
    .note-input-actions {
        display: flex;
        gap: var(--spacing-sm);
        margin-top: var(--spacing-lg);
    }
    
    /* Responsive adjustments for square grid layout */
    @media (min-width: 1200px) {
        .proximity-alerts {
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
        }
        
        .proximity-alert {
            min-height: 220px;
            max-height: 220px;
        }
        
        .alert-content {
            padding: 18px;
        }
    }
    
    @media (min-width: 768px) and (max-width: 1199px) {
        .proximity-alerts {
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }
        
        .proximity-alert {
            min-height: 200px;
            max-height: 200px;
        }
        
        .bottom-controls {
            max-width: 640px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .structure-menu {
            width: 360px;
        }
    }
    
    @media (min-width: 480px) and (max-width: 767px) {
        .proximity-alerts {
            grid-template-columns: repeat(2, 1fr);
            gap: 14px;
            padding: 6px;
        }
        
        .proximity-alert {
            min-height: 180px;
            max-height: 180px;
        }
        
        .alert-content {
            padding: 14px;
            gap: 10px;
        }
        
        .alert-utility-type {
            font-size: 13px;
        }
        
        .distance-value {
            font-size: 16px;
        }
    }
    
    @media (max-width: 479px) {
        .proximity-alerts {
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            padding: 4px;
        }
        
        .proximity-alert {
            min-height: 160px;
            max-height: 160px;
        }
        
        .alert-content {
            padding: 12px;
            gap: 8px;
        }
        
        .alert-utility-type {
            font-size: 12px;
        }
        
        .distance-value {
            font-size: 14px;
        }
        
        .distance-unit {
            font-size: 10px;
        }
        
                 .alert-depth-banner {
             font-size: 11px !important;
             padding: 6px 8px !important;
         }
         
         .excavation-header {
             width: calc(100% - 100px);
             max-width: 300px;
             padding: 14px 20px;
         }
         
         .excavation-info h2 {
             font-size: 14px;
         }
         
         .excavation-info p {
             font-size: 12px;
         }
    }
    
    /* Prevent selection and zoom */
    * {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }

    /*********************************
    * USER PROFILE & EXPERIENCE SYSTEM
    *********************************/
    .user-profile-widget {
        position: fixed;
        top: calc(env(safe-area-inset-top, 0) + 12px);
        left: 20px;
        z-index: 1500;
        display: flex;
        align-items: center;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 35px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
        overflow: hidden;
        width: 70px;
        height: 70px;
        padding: 0;
    }

    .user-profile-widget.expanded {
        width: 300px;
        padding: 10px 18px 10px 10px;
        gap: 14px;
    }

    .user-profile-widget:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 30px rgba(0, 0, 0, 0.15);
    }

    .profile-avatar-container {
        position: relative;
        width: 50px;
        height: 50px;
        margin: 10px;
        flex-shrink: 0;
    }

    .user-profile-widget.expanded .profile-avatar-container {
        margin: 0;
        width: 56px;
        height: 56px;
    }

    .profile-avatar {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        position: relative;
        overflow: hidden;
        animation: avatarGlow 3s ease-in-out infinite;
    }

    @keyframes avatarGlow {
        0%, 100% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.4); }
        50% { box-shadow: 0 0 0 8px rgba(102, 126, 234, 0); }
    }

    .avatar-svg {
        width: 70%;
        height: 70%;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        transition: transform 0.3s ease;
    }

    .profile-avatar:hover .avatar-svg {
        transform: scale(1.1) rotate(5deg);
    }

    .exp-ring {
        position: absolute;
        top: -3px;
        left: -3px;
        right: -3px;
        bottom: -3px;
        border-radius: 50%;
        pointer-events: none;
    }

    .exp-ring svg {
        width: 100%;
        height: 100%;
        transform: rotate(-90deg);
    }

    .exp-ring-bg {
        fill: none;
        stroke: rgba(0, 0, 0, 0.1);
        stroke-width: 2;
    }

    .exp-ring-fill {
        fill: none;
        stroke: url(#expGradient);
        stroke-width: 2;
        stroke-linecap: round;
        transition: stroke-dasharray 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .level-badge {
        position: absolute;
        bottom: -8px;
        right: -8px;
        width: 24px;
        height: 24px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: 700;
        color: white;
        border: 2px solid white;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .user-profile-widget.expanded .level-badge {
        bottom: -6px;
        right: -6px;
        width: 26px;
        height: 26px;
        font-size: 13px;
    }

    .profile-info {
        display: none;
        flex-direction: column;
        gap: 2px;
        opacity: 0;
        transform: translateX(-20px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .user-profile-widget.expanded .profile-info {
        display: flex;
        opacity: 1;
        transform: translateX(0);
        transition-delay: 0.1s;
    }

    .profile-name {
        font-size: 13px;
        font-weight: 600;
        color: var(--text-primary);
        line-height: 1;
    }

    .profile-exp {
        font-size: 11px;
        color: var(--text-secondary);
        font-weight: 500;
    }

    .exp-progress {
        width: 100px;
        height: 4px;
        background: rgba(0, 0, 0, 0.08);
        border-radius: 2px;
        overflow: hidden;
        margin-top: 4px;
    }

    .exp-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 2px;
        transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
    }

    .exp-progress-bar::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }

    /*********************************
    * ACHIEVEMENT TOAST
    *********************************/
    .achievement-toast {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(20px);
        border-radius: 16px;
        padding: 16px 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        gap: 16px;
        z-index: 6000;
        transform: translateX(400px);
        transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        max-width: 320px;
        border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .achievement-toast.show {
        transform: translateX(0);
    }

    .achievement-icon {
        width: 48px;
        height: 48px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        flex-shrink: 0;
    }

    .achievement-icon svg {
        width: 28px;
        height: 28px;
        fill: white;
    }

    .achievement-icon::before {
        content: '';
        position: absolute;
        inset: -4px;
        border-radius: 16px;
        padding: 2px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
        mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        mask-composite: exclude;
        opacity: 0.5;
        animation: rotate 3s linear infinite;
    }

    @keyframes rotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    .achievement-content {
        flex: 1;
    }

    .achievement-title {
        font-size: 14px;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 2px;
    }

    .achievement-desc {
        font-size: 12px;
        color: var(--text-secondary);
        line-height: 1.4;
    }

    .achievement-exp {
        font-size: 11px;
        color: #667eea;
        font-weight: 600;
        margin-top: 4px;
    }

    .achievement-close {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-tertiary);
        transition: all 0.2s ease;
        cursor: pointer;
        flex-shrink: 0;
    }

    .achievement-close:hover {
        background: rgba(0, 0, 0, 0.05);
        color: var(--text-secondary);
    }

    /*********************************
    * AUDIT LOG PANEL
    *********************************/
    .audit-log-panel {
        position: fixed;
        top: 0;
        right: -400px;
        width: 400px;
        height: 100%;
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(10px);
        box-shadow: -2px 0 20px rgba(0, 0, 0, 0.1);
        z-index: 2500;
        transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
    }

    .audit-log-panel.show {
        right: 0;
    }

    .audit-log-header {
        padding: 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .audit-log-title {
        font-size: 18px;
        font-weight: 700;
        color: var(--text-primary);
    }

    .audit-log-close {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-tertiary);
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .audit-log-close:hover {
        background: var(--bg-tertiary);
        color: var(--text-secondary);
    }

    .audit-log-filters {
        padding: 16px 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        gap: 12px;
    }

    .audit-filter-btn {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 500;
        background: var(--bg-tertiary);
        color: var(--text-secondary);
        border: none;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .audit-filter-btn.active {
        background: var(--gradient-primary);
        color: white;
    }

    .audit-log-list {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        max-height: calc(100vh - 200px);
    }

    .audit-log-item {
        background: white;
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 12px;
        border: 1px solid var(--border-color);
        transition: all 0.2s ease;
    }

    .audit-log-item:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        transform: translateY(-1px);
    }

    .audit-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }

    .audit-action-badge {
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
    }

    .audit-action-badge.created {
        background: rgba(76, 175, 80, 0.1);
        color: #4caf50;
    }

    .audit-action-badge.edited {
        background: rgba(33, 150, 243, 0.1);
        color: #2196f3;
    }

    .audit-action-badge.deleted {
        background: rgba(244, 67, 54, 0.1);
        color: #f44336;
    }

    .audit-action-badge.refined {
        background: rgba(156, 39, 176, 0.1);
        color: #9c27b0;
    }

    .audit-timestamp {
        font-size: 11px;
        color: var(--text-tertiary);
    }

    .audit-user {
        font-size: 13px;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 4px;
    }

    .audit-details {
        font-size: 12px;
        color: var(--text-secondary);
        line-height: 1.5;
    }

    .audit-entity-type {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        background: var(--bg-tertiary);
        border-radius: 10px;
        font-size: 11px;
        margin-top: 8px;
    }

    /* Level up animation */
    .level-up-animation {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 7000;
        pointer-events: none;
    }

    .level-up-content {
        text-align: center;
        animation: levelUpBounce 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    @keyframes levelUpBounce {
        0% {
            transform: scale(0) rotate(-180deg);
            opacity: 0;
        }
        50% {
            transform: scale(1.2) rotate(10deg);
        }
        100% {
            transform: scale(1) rotate(0deg);
            opacity: 1;
        }
    }

    .level-up-icon {
        width: 120px;
        height: 120px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 20px;
        position: relative;
    }

    .level-up-icon::before {
        content: '';
        position: absolute;
        inset: -20px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(102, 126, 234, 0.2) 0%, transparent 70%);
        animation: levelUpPulse 1s ease-out;
    }

    @keyframes levelUpPulse {
        0% {
            transform: scale(0.5);
            opacity: 1;
        }
        100% {
            transform: scale(2);
            opacity: 0;
        }
    }

    .level-up-number {
        font-size: 48px;
        font-weight: 700;
        color: white;
        text-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .level-up-text {
        font-size: 24px;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 8px;
    }

    .level-up-subtext {
        font-size: 16px;
        color: var(--text-secondary);
    }

    /* Particles for level up */
    .level-particles {
        position: absolute;
        inset: 0;
        pointer-events: none;
    }

    .particle {
        position: absolute;
        width: 6px;
        height: 6px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 50%;
        animation: particleFloat 2s ease-out forwards;
    }

    @keyframes particleFloat {
        0% {
            transform: translate(0, 0) scale(1);
            opacity: 1;
        }
        100% {
            transform: translate(var(--tx), var(--ty)) scale(0);
            opacity: 0;
        }
    }

    /* Exp gain animation */
    .exp-gain-popup {
        position: absolute;
        font-size: 14px;
        font-weight: 700;
        color: #667eea;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        pointer-events: none;
        animation: expFloat 1.5s ease-out forwards;
    }

    @keyframes expFloat {
        0% {
            transform: translateY(0);
            opacity: 1;
        }
        100% {
            transform: translateY(-30px);
            opacity: 0;
        }
    }

    /* Mobile responsive */
    @media (max-width: 480px) {
        .user-profile-widget {
            top: calc(env(safe-area-inset-top, 0) + 15px);
            left: 15px;
            width: 60px;
            height: 60px;
        }
        
        .user-profile-widget.expanded {
            width: 260px;
            padding: 8px 14px 8px 8px;
        }
        
        .profile-avatar-container {
            width: 40px;
            height: 40px;
            margin: 10px;
        }
        
        .user-profile-widget.expanded .profile-avatar-container {
            width: 48px;
            height: 48px;
            margin: 0;
        }
        
        .level-badge {
            width: 20px;
            height: 20px;
            font-size: 10px;
            bottom: -6px;
            right: -6px;
        }
        
        .user-profile-widget.expanded .level-badge {
            width: 22px;
            height: 22px;
            font-size: 11px;
        }
        
        .profile-name {
            font-size: 12px;
        }
        
        .profile-exp {
            font-size: 10px;
        }
        
        .exp-progress {
            width: 80px;
        }
        
        .achievement-toast {
            right: 10px;
            max-width: calc(100vw - 20px);
        }
        
        .audit-log-panel {
            width: 100%;
            right: -100%;
        }
    }
    
    input, textarea {
        -webkit-user-select: text;
        -khtml-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
    }
    
    /* Enhanced touch interactions */
    button, .control-btn, .utility-btn {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    }
    
    /* Focus management for accessibility */
    button:focus-visible,
    .control-btn:focus-visible,
    .utility-btn:focus-visible {
        outline: 3px solid var(--info-color);
        outline-offset: 2px;
    }
    
    .form-input:focus-visible {
        outline: 3px solid var(--info-color);
        outline-offset: 2px;
    }
    
    /* Improve accessibility */
    @media (prefers-reduced-motion: reduce) {
        *, *::before, *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }
    
    /* High contrast mode support */
    @media (prefers-contrast: high) {
        :root {
            --border-color: rgba(255, 255, 255, 0.3);
            --text-secondary: #cccccc;
        }
    }
    
    /* Premium glassmorphism enhancement */
    @supports (backdrop-filter: blur(20px)) {
        .utility-selector,
        .control-btn,
        .info-modal,
        .settings-panel,
        .drawing-ui,
        .refine-overlay {
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
        }
    }

    /* Force black background on iOS standalone */
    @media all and (display-mode: standalone) {
        html, body {
            background-color: #0a0a0f !important;
            background: #0a0a0f !important;
            /* Ensure coverage of safe areas */
            padding-bottom: env(safe-area-inset-bottom) !important;
        }
        
        .app-container {
            background-color: #0a0a0f !important;
            background: #0a0a0f !important;
            /* Use padding instead of negative bottom */
            bottom: 0 !important;
            padding-bottom: env(safe-area-inset-bottom, 0) !important;
            height: 100vh !important;
        }
        
        #map {
            background-color: #0a0a0f !important;
            background: #0a0a0f !important;
            /* Use full height with padding */
            height: 100vh !important;
            padding-bottom: env(safe-area-inset-bottom, 0) !important;
        }
        
        /* Ensure no margins or padding that could show through */
        * {
            margin: 0;
            padding: 0;
        }
    }

    /* Prevent viewport manipulation in standalone mode */
    @media all and (display-mode: standalone) {
        html, body {
            position: fixed !important;
            overflow: hidden !important;
            transform: none !important;
            -webkit-transform: none !important;
            touch-action: pan-x pan-y !important;
        }
        
        .app-container {
            position: fixed !important;
            transform: translate3d(0, 0, 0) !important;
            -webkit-transform: translate3d(0, 0, 0) !important;
        }
        
        /* Allow pinch zoom on map */
        #map {
            touch-action: pan-x pan-y pinch-zoom !important;
        }
    }

    /* ========== LOGIN & ADMIN SYSTEM STYLES ========== */
    
    /* Login Screen */
    .login-screen {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #0a0a0f 0%, #1a1a25 50%, #0f0c1a 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 30000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease;
    }

    .login-screen.active {
        opacity: 1;
        pointer-events: auto;
    }

    .login-container {
        width: 90%;
        max-width: 400px;
        padding: var(--spacing-2xl);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-xl);
        text-align: center;
        border: 1px solid var(--border-color);
    }

    .login-logo {
        width: 80px;
        height: 80px;
        background: var(--gradient-primary);
        border-radius: var(--radius-xl);
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto var(--spacing-lg);
        box-shadow: var(--shadow-lg);
    }

    .login-logo i {
        font-size: 32px;
        color: white;
    }

    .login-title {
        font-family: 'Space Grotesk', sans-serif;
        font-size: 28px;
        font-weight: 900;
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: var(--spacing-sm);
    }

    .login-subtitle {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-2xl);
        font-weight: 500;
    }

    .login-form {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-lg);
    }

    .login-input {
        padding: var(--spacing-md) var(--spacing-lg);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-glass-light);
        color: var(--text-primary);
        font-size: 16px;
        font-weight: 500;
        transition: all var(--transition-normal);
    }

    .login-input:focus {
        outline: none;
        border-color: #667eea;
        background: var(--bg-secondary);
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }

    .login-btn {
        padding: var(--spacing-md) var(--spacing-lg);
        border: none;
        border-radius: var(--radius-md);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
    }

    .login-btn.primary {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }

    .login-btn.secondary {
        background: var(--bg-glass-light);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
    }

    .login-btn.google {
        background: #4285f4;
        color: white;
        box-shadow: var(--shadow-md);
    }

    .login-btn:active {
        transform: scale(0.95);
    }

    .login-divider {
        display: flex;
        align-items: center;
        text-align: center;
        color: var(--text-tertiary);
        font-size: 12px;
        font-weight: 600;
        margin: var(--spacing-md) 0;
    }

    .login-divider::before,
    .login-divider::after {
        content: '';
        flex: 1;
        height: 1px;
        background: var(--border-color);
    }

    .login-divider::before {
        margin-right: var(--spacing-md);
    }

    .login-divider::after {
        margin-left: var(--spacing-md);
    }

    .login-error {
        color: var(--danger-color);
        font-size: 14px;
        font-weight: 500;
        margin-top: var(--spacing-md);
        padding: var(--spacing-sm);
        background: rgba(255, 0, 84, 0.1);
        border-radius: var(--radius-sm);
        border: 1px solid rgba(255, 0, 84, 0.2);
        display: none;
    }

    .login-error.show {
        display: block;
    }

    .login-info {
        margin-top: var(--spacing-lg);
        font-size: 12px;
        color: var(--text-tertiary);
        padding: var(--spacing-sm);
        background: var(--bg-glass-light);
        border-radius: var(--radius-sm);
        border: 1px solid var(--border-color);
    }

    /* Admin Button */
    .admin-btn {
        position: fixed;
        top: calc(env(safe-area-inset-top, 0) + 80px);
        right: calc(var(--spacing-md) + 100px);
        width: 48px;
        height: 48px;
        background: var(--gradient-success);
        border: none;
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--shadow-lg), 0 0 20px rgba(0, 245, 160, 0.4);
        cursor: pointer;
        z-index: 999;
        transition: all var(--transition-spring);
    }

    .admin-btn:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: var(--shadow-xl), 0 0 30px rgba(0, 245, 160, 0.6);
    }

    .admin-btn i {
        font-size: 20px;
        color: white;
    }

    /* Role Badge */
    .role-badge {
        position: fixed;
        top: calc(env(safe-area-inset-top, 0) + 80px);
        right: var(--spacing-md);
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        padding: var(--spacing-sm) var(--spacing-md);
        border-radius: var(--radius-full);
        font-size: 12px;
        font-weight: 700;
        z-index: 1000;
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
        box-shadow: var(--shadow-lg);
        transition: all var(--transition-normal);
    }

    .role-badge.admin {
        border: 2px solid #00ff88;
        color: #00ff88;
        background: rgba(0, 0, 0, 0.8);
        text-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
    }

    .role-badge.user {
        border: 2px solid #00d4ff;
        color: #00d4ff;
        background: rgba(0, 0, 0, 0.8);
        text-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
    }

    .role-badge.supervisor {
        border: 2px solid #ffdd00;
        color: #ffdd00;
        background: rgba(0, 0, 0, 0.8);
        text-shadow: 0 0 8px rgba(255, 221, 0, 0.5);
    }

    .role-badge.pitman {
        border: 2px solid #ff8844;
        color: #ff8844;
        background: rgba(0, 0, 0, 0.8);
        text-shadow: 0 0 8px rgba(255, 136, 68, 0.5);
    }

    .role-badge.restricted {
        border: 2px solid #ff4466;
        color: #ff4466;
        background: rgba(0, 0, 0, 0.8);
        text-shadow: 0 0 8px rgba(255, 68, 102, 0.5);
    }

    /* Admin Panel */
    .admin-panel {
        position: fixed;
        top: 0;
        right: -100%;
        bottom: 0;
        width: 90%;
        max-width: 500px;
        background: var(--bg-primary);
        box-shadow: -8px 0 32px rgba(0, 0, 0, 0.4);
        z-index: 700;
        transition: right var(--transition-spring);
        overflow-y: auto;
        padding-top: env(safe-area-inset-top, 0);
        padding-bottom: calc(env(safe-area-inset-bottom, 0) + var(--spacing-lg));
        border-left: 1px solid var(--border-color);
    }

    .admin-panel.active {
        right: 0;
    }

    .admin-header {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
    }

    .admin-header h2 {
        font-size: 24px;
        font-weight: 800;
        background: var(--gradient-success);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    .admin-close {
        width: 40px;
        height: 40px;
        border: none;
        background: var(--bg-glass-light);
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
        color: var(--text-primary);
    }

    .admin-close:hover {
        background: var(--bg-tertiary);
        transform: scale(1.1);
    }

    .admin-section {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
    }

    .admin-section h3 {
        font-size: 14px;
        font-weight: 700;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    /* Pending Changes */
    .pending-list {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
        max-height: 400px;
        overflow-y: auto;
    }

    .pending-item {
        background: var(--bg-glass-light);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        padding: var(--spacing-lg);
        transition: all var(--transition-normal);
        position: relative;
        overflow: hidden;
    }

    .pending-item::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: var(--gradient-primary);
        opacity: 0.7;
    }

    .pending-item:hover {
        background: var(--bg-tertiary);
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
    }

    .pending-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: var(--spacing-sm);
        gap: var(--spacing-md);
    }

    .pending-type {
        font-weight: 700;
        color: var(--text-primary);
        font-size: 16px;
        line-height: 1.2;
    }

    .pending-user {
        font-size: 12px;
        color: var(--text-secondary);
        background: var(--bg-glass);
        padding: 4px 8px;
        border-radius: var(--radius-sm);
        white-space: nowrap;
    }

    .pending-details {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        line-height: 1.4;
    }

    .pending-timestamp {
        font-size: 11px;
        color: var(--text-tertiary);
        margin-bottom: var(--spacing-sm);
        font-style: italic;
    }

    .pending-actions {
        display: flex;
        gap: var(--spacing-sm);
    }

    .approve-btn, .reject-btn {
        flex: 1;
        padding: var(--spacing-sm) var(--spacing-md);
        border: none;
        border-radius: var(--radius-md);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-xs);
    }

    .approve-btn {
        background: var(--gradient-success);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .approve-btn:hover {
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
    }

    .reject-btn {
        background: var(--gradient-danger);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .reject-btn:hover {
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
    }

    /* User Management */
    .users-list {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
        max-height: 400px;
        overflow-y: auto;
    }

    .user-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--spacing-md);
        background: var(--bg-glass-light);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        transition: all var(--transition-normal);
    }

    .user-item:hover {
        background: var(--bg-tertiary);
    }

    .user-info {
        flex: 1;
    }

    .user-email {
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 2px;
    }

    .user-role {
        font-size: 12px;
        font-weight: 600;
        padding: 4px 8px;
        border-radius: var(--radius-sm);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .user-role.admin {
        background: rgba(0, 245, 160, 0.2);
        color: var(--success-color);
    }

    .user-role.user {
        background: rgba(0, 180, 216, 0.2);
        color: var(--info-color);
    }

    .user-role.supervisor {
        background: rgba(255, 214, 10, 0.2);
        color: var(--warning-color);
    }

    .user-role.pitman {
        background: rgba(255, 107, 53, 0.2);
        color: #ff6b35;
    }

    .user-role.restricted {
        background: rgba(255, 0, 84, 0.2);
        color: var(--danger-color);
    }

    .approve-user-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        background: var(--gradient-success);
        color: white;
        border: none;
        border-radius: var(--radius-sm);
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
    }

    .approve-user-btn:hover {
        transform: scale(1.05);
    }

    /* Pending utility lines on map */
    .utility-line.pending {
        opacity: 0.6 !important;
        stroke-dasharray: 10, 5 !important;
        filter: drop-shadow(0 0 8px rgba(255, 214, 10, 0.5)) !important;
    }

    .structure-marker.pending {
        opacity: 0.6 !important;
        border-style: dashed !important;
        filter: drop-shadow(0 0 8px rgba(255, 214, 10, 0.5)) !important;
    }

    /* Sign out button in settings */
    .signout-btn {
        width: 100%;
        padding: var(--spacing-md);
        background: var(--gradient-danger);
        color: white;
        border: none;
        border-radius: var(--radius-md);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        margin-top: var(--spacing-lg);
        margin-bottom: calc(env(safe-area-inset-bottom, 0) + var(--spacing-lg));
        transition: all var(--transition-normal);
    }

    .signout-btn:active {
        transform: scale(0.95);
    }
</style>

</head>
<body>
    <!-- Black background failsafe -->
    <div style="position: fixed; top: 0; left: 0; right: 0; bottom: calc(-1 * env(safe-area-inset-bottom, 0)); width: 100vw; height: calc(100vh + env(safe-area-inset-bottom, 0)); background-color: #0a0a0f; z-index: 0;"></div>
    
    <!-- ========== TRIPLE AAA QUALITY SPLASH SCREEN ========== -->
    <div class="splash-screen" id="splash">
        <!-- Dynamic Geometric Background -->
        <div class="splash-background">
            <div class="geometric-layer">
                <div class="geo-shape"></div>
                <div class="geo-shape"></div>
                <div class="geo-shape"></div>
                <div class="geo-shape"></div>
            </div>
        </div>
        
        <!-- Advanced Neural Particle System -->
        <div class="splash-particles">
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
            <div class="neural-particle"></div>
        </div>
        
        <!-- Ultra Modern Logo System -->
        <div class="splash-logo-container">
            <div class="logo-hexagon">
                <div class="hex-core"></div>
                <div class="hex-inner">
                    <div class="hex-grid">
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                        <div class="hex-dot"></div>
                    </div>
                </div>
            </div>
            
            <!-- Premium Typography -->
            <h1 class="splash-title">CAC UTILI-TRACK</h1>
            <p class="splash-subtitle">Advanced Utility Mapping</p>
        </div>
        
        <!-- Advanced Loading System -->
        <div class="splash-loading">
            <div class="loading-bar-container">
                <div class="loading-bar" id="loadingBar"></div>
            </div>
            <div class="loading-text" id="loadingText">Initializing Systems</div>
            <div class="loading-percentage" id="loadingPercentage">0%</div>
        </div>
    </div>

<!-- Login Screen -->
<div class="login-screen" id="loginScreen">
    <div class="login-container">
        <div class="login-logo">
            <i class="fas fa-map-marked-alt"></i>
        </div>
        <h1 class="login-title">CAC UTILI-TRACK</h1>
        <p class="login-subtitle">Shared Utility Mapping System</p>
        
        <div class="login-form">
            <input type="email" id="loginEmail" placeholder="Email address" class="login-input" required>
            <input type="password" id="loginPassword" placeholder="Password" class="login-input" required>
            
            <button class="login-btn primary" id="loginBtn">
                <i class="fas fa-sign-in-alt"></i>
                Sign In
            </button>
            <button class="login-btn secondary" id="signupBtn">
                <i class="fas fa-user-plus"></i>
                Request Access
            </button>
            
            <div class="login-divider">OR</div>
            
            <button class="login-btn google" id="googleBtn">
                <i class="fab fa-google"></i>
                Sign in with Google
            </button>
        </div>
        
        <div class="login-error" id="loginError"></div>
        <div class="login-info">
            <p><i class="fas fa-info-circle"></i> New users require admin approval</p>
        </div>
    </div>
</div>

<!-- Admin Panel -->
<div class="admin-panel" id="adminPanel">
    <div class="admin-header">
        <h2><i class="fas fa-user-shield"></i> Admin Panel</h2>
        <button class="admin-close" onclick="closeAdminPanel()">
            <i class="fas fa-times"></i>
        </button>
    </div>
    
    <div class="admin-section">
        <h3><i class="fas fa-clock"></i> Pending Changes</h3>
        <div id="pendingChangesList" class="pending-list">
            <p style="color: var(--text-tertiary); text-align: center;">Loading...</p>
        </div>
    </div>
    
    <div class="admin-section">
        <h3><i class="fas fa-users"></i> User Management</h3>
        <div id="usersList" class="users-list">
            <p style="color: var(--text-tertiary); text-align: center;">Loading...</p>
        </div>
        </div>
    </div>

<!-- Main App Container -->
<div class="app-container">
    <!-- Map -->
    <div id="map"></div>

    <!-- Top Bar -->
    <div class="top-bar">
        <div class="top-bar-content">
            <div class="utility-selector" role="toolbar" aria-label="Utility type selector">
                <button class="utility-btn water active" data-utility="water" aria-label="Select water utilities" aria-pressed="true">
                    <i class="fas fa-tint" aria-hidden="true"></i>
                </button>
                <button class="utility-btn gas" data-utility="gas" aria-label="Select gas utilities" aria-pressed="false">
                    <i class="fas fa-fire" aria-hidden="true"></i>
                </button>
                <button class="utility-btn electric" data-utility="electric" aria-label="Select electric utilities" aria-pressed="false">
                    <i class="fas fa-bolt" aria-hidden="true"></i>
                </button>
                <button class="utility-btn sewer" data-utility="sewer" aria-label="Select sewer utilities" aria-pressed="false">
                    <i class="fas fa-toilet" aria-hidden="true"></i>
                </button>
                <button class="utility-btn telecom" data-utility="telecom" aria-label="Select telecom utilities" aria-pressed="false">
                    <i class="fas fa-phone" aria-hidden="true"></i>
                </button>
            </div>
            
            <div class="search-container">
                <button class="search-btn" id="searchBtn" title="Search for address">
                    <i class="fas fa-search"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Search Modal -->
    <div class="search-modal" id="searchModal">
        <div class="search-modal-content">
            <div class="search-header">
                <h3>Search Address</h3>
                <button class="search-close" id="searchCloseBtn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="search-body">
                <div class="search-input-container">
                    <input type="text" class="search-input" id="searchInput" placeholder="Enter address, city, or landmark..." autocomplete="off">
                    <button class="search-submit" id="searchSubmitBtn">
                        <i class="fas fa-search"></i>
                    </button>
                </div>
                <div class="search-results" id="searchResults"></div>
            </div>
        </div>
    </div>

    <!-- Measurement Tools -->
    <div class="measurement-tools">
        <button class="measurement-btn" id="measureDistanceBtn" title="Measure Distance">
            <i class="fas fa-ruler"></i>
        </button>
        <button class="measurement-btn" id="measureAreaBtn" title="Measure Area">
            <i class="fas fa-vector-square"></i>
        </button>
    </div>

    <!-- Bottom Controls -->
    <div class="bottom-controls">
        <div class="control-group">
            <button class="control-btn" id="locateBtn">
                <i class="fas fa-location-crosshairs"></i>
            </button>
            <button class="control-btn" id="layersBtn">
                <i class="fas fa-layer-group"></i>
            </button>
        </div>

        <div class="control-group center">
            <div class="main-action-group">
                <button class="main-action-btn" id="drawBtn">
                    <i class="fas fa-pencil-alt"></i>
                </button>
                <div class="line-type-toggle">
                    <button class="line-type-btn active" data-type="service">Service</button>
                    <button class="line-type-btn" data-type="main">Main</button>
                </div>
            </div>
        </div>

        <div class="control-group">
            <button class="control-btn excavation-btn" id="excavationBtn">
                <i class="fas fa-hard-hat"></i>
            </button>
            <button class="control-btn" id="settingsBtn">
                <i class="fas fa-cog"></i>
            </button>
        </div>
    </div>

    <!-- Right Side Controls -->
    <div class="right-controls">
        <!-- Orientation Permission Button (iOS Standalone Mode Only) -->
        <button class="orientation-permission-btn" id="orientationPermissionBtn" title="Enable Compass Direction">
            <i class="fas fa-compass"></i>
        </button>
        <button class="control-btn" id="zoomInBtn">
            <i class="fas fa-plus"></i>
        </button>
        <button class="control-btn" id="zoomOutBtn">
            <i class="fas fa-minus"></i>
        </button>
    </div>

    <!-- Add Structure Button -->
    <div class="structure-container">
    <button class="add-structure-btn" id="addStructureBtn">
        <i class="fas fa-plus"></i>
        </button>
        <div class="structure-menu" id="structureMenu">
            <button class="structure-type-btn" data-structure="electricBox" data-utility="electric">
                <i class="fas fa-bolt"></i>
                <span>Elec Box</span>
            </button>
            <button class="structure-type-btn" data-structure="catchBasin" data-utility="sewer">
                <i class="fas fa-water"></i>
                <span>Catch Basin</span>
            </button>
            <button class="structure-type-btn" data-structure="sewerManhole" data-utility="sewer">
                <i class="fas fa-circle"></i>
                <span>Sewer MH</span>
            </button>
            <button class="structure-type-btn" data-structure="waterManhole" data-utility="water">
                <i class="fas fa-tint"></i>
                <span>Water MH</span>
            </button>
            <button class="structure-type-btn" data-structure="gasManhole" data-utility="gas">
                <i class="fas fa-fire"></i>
                <span>Gas MH</span>
            </button>
            <button class="structure-type-btn" data-structure="gasValve" data-utility="gas">
                <i class="fas fa-wrench"></i>
                <span>Gas Valve</span>
            </button>
            <button class="structure-type-btn" data-structure="hydrantValve" data-utility="water">
                <i class="fas fa-fire-extinguisher"></i>
                <span>Hydrant</span>
            </button>
            <button class="structure-type-btn" data-structure="telecomBox" data-utility="telecom">
                <i class="fas fa-network-wired"></i>
                <span>Telecom</span>
            </button>
        </div>
    </div>

    <!-- Drawing UI -->
    <div class="drawing-ui" id="drawingUI">
        <h3>Drawing Utility Line</h3>
        <p id="drawingStatus">Click points on the map</p>
        <div class="drawing-actions">
            <button class="drawing-btn secondary" id="cancelDrawBtn">Cancel</button>
            <button class="drawing-btn primary" id="finishDrawBtn" style="display: none;">Finish</button>
        </div>
    </div>

    <!-- Refine Mode Overlay -->
    <div class="refine-overlay" id="refineOverlay">
        <span>🎯 Drag points to refine location</span>
        <button class="drawing-btn primary" id="finishRefineBtn">
            <i class="fas fa-check"></i> Finish Refining
        </button>
    </div>

    <!-- Utility Info Modal -->
    <div class="info-modal" id="infoModal">
        <div class="modal-handle"></div>
        <div class="modal-header">
            <div class="modal-title">
                <i class="fas fa-tint" id="modalIcon"></i>
                <span id="modalTitle">Utility Information</span>
            </div>
            <button class="modal-close" id="closeModalBtn">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="modal-body">
            <!-- View Mode -->
            <div id="viewMode">
                <div class="info-grid">
                    <div class="info-item">
                        <span class="info-label">Type</span>
                        <span class="info-value" id="infoType">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Line Type</span>
                        <span class="info-value" id="infoLineType">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Size</span>
                        <span class="info-value" id="infoSize">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Depth</span>
                        <span class="info-value" id="infoDepth">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Material</span>
                        <span class="info-value" id="infoMaterial">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Condition</span>
                        <span class="info-value" id="infoCondition">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Distance from Curb</span>
                        <span class="info-value" id="infoCurbDistance">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Date Added</span>
                        <span class="info-value" id="infoDate">-</span>
                    </div>
                </div>
                
                <!-- Notes Section -->
                <div class="notes-section">
                    <div class="notes-header">
                        <h3 class="notes-title">Notes</h3>
                        <button class="add-note-btn" id="addNoteBtn">
                            <i class="fas fa-plus"></i>
                            Add Note
                        </button>
                    </div>
                    <div class="notes-list" id="notesList"></div>
                </div>
                
                <div class="modal-actions">
                    <button class="modal-btn primary" id="editBtn">
                        <i class="fas fa-edit"></i>
                        Edit
                    </button>
                    <button class="modal-btn primary" id="refineBtn">
                        <i class="fas fa-crosshairs"></i>
                        Refine Location
                    </button>
                    <button class="modal-btn danger" id="deleteBtn">
                        <i class="fas fa-trash"></i>
                        Delete
                    </button>
                </div>
            </div>

            <!-- Edit Mode -->
            <div class="edit-form" id="editMode">
                <div class="form-group">
                    <label class="form-label">Size (inches)</label>
                    <input type="number" class="form-input" id="editSize" placeholder="e.g., 4">
                </div>
                <div class="form-group">
                    <label class="form-label">Depth (feet)</label>
                    <input type="number" class="form-input" id="editDepth" placeholder="e.g., 3">
                </div>
                <div class="form-group">
                    <label class="form-label">Material</label>
                    <select class="form-input form-select" id="editMaterial">
                        <option value="">Not specified</option>
                        <option value="PVC">PVC</option>
                        <option value="Cast Iron">Cast Iron</option>
                        <option value="Copper">Copper</option>
                        <option value="Steel">Steel</option>
                        <option value="HDPE">HDPE</option>
                        <option value="Concrete">Concrete</option>
                        <option value="Clay">Clay</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Condition</label>
                    <select class="form-input form-select" id="editCondition">
                        <option value="">Not specified</option>
                        <option value="Excellent">Excellent</option>
                        <option value="Good">Good</option>
                        <option value="Fair">Fair</option>
                        <option value="Poor">Poor</option>
                        <option value="Critical">Critical</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Distance from Curb (feet)</label>
                    <input type="number" class="form-input" id="editCurbDistance" placeholder="e.g., 6">
                </div>
                <div class="modal-actions">
                    <button class="modal-btn secondary" id="cancelEditBtn">
                        Cancel
                    </button>
                    <button class="modal-btn primary" id="saveEditBtn">
                        <i class="fas fa-save"></i>
                        Save
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Excavation Mode Overlay -->
    <div class="excavation-overlay" id="excavationOverlay">
        <div class="excavation-radar">
            <div class="radar-ring"></div>
            <div class="radar-ring"></div>
            <div class="radar-ring"></div>
        </div>
        <div class="excavation-header">
            <div class="excavation-info">
            <h2>EXCAVATION MODE ACTIVE</h2>
                            <p>Monitoring utility proximity within 25 feet</p>
            </div>
            <button class="excavation-toggle" id="alertToggleBtn" title="Toggle proximity alerts">
                <i class="fas fa-eye"></i>
            </button>
        </div>
        <div class="proximity-alerts" id="proximityAlerts"></div>
        <button class="exit-excavation" id="exitExcavationBtn">Exit Excavation Mode</button>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <h2>Settings</h2>
            <button class="modal-close" id="closeSettingsBtn">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="settings-section">
            <h3>Appearance</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-moon"></i>
                        Dark Mode
                    </span>
                    <button class="toggle-switch active" id="darkModeToggle"></button>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h3>Map Style</h3>
            <div class="map-styles">
                <button class="map-style-btn active" data-style="streets">Streets</button>
                <button class="map-style-btn" data-style="satellite">Satellite</button>
                <button class="map-style-btn" data-style="satellite-hd">Satellite HD</button>
                <button class="map-style-btn" data-style="usgs-hybrid">USGS Hybrid</button>
                <button class="map-style-btn" data-style="infrastructure">Infrastructure</button>
                <button class="map-style-btn" data-style="satellite-clarity">Clarity</button>
                <button class="map-style-btn" data-style="terrain">Terrain</button>
                <button class="map-style-btn" data-style="dark">Dark</button>
            </div>
        </div>

        <div class="settings-section">
            <h3>Utility Visibility</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-tint" style="color: var(--water-color)"></i>
                        Water
                    </span>
                    <button class="toggle-switch active" data-utility="water"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-fire" style="color: var(--gas-color)"></i>
                        Gas
                    </span>
                    <button class="toggle-switch active" data-utility="gas"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-bolt" style="color: var(--electric-color)"></i>
                        Electric
                    </span>
                    <button class="toggle-switch active" data-utility="electric"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-toilet" style="color: var(--sewer-color)"></i>
                        Sewer
                    </span>
                    <button class="toggle-switch active" data-utility="sewer"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-phone" style="color: var(--telecom-color)"></i>
                        Telecom
                    </span>
                    <button class="toggle-switch active" data-utility="telecom"></button>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h3>Line Types</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-grip-lines"></i>
                        Main Lines
                    </span>
                    <button class="toggle-switch active" data-linetype="main"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-code-branch"></i>
                        Service Lines
                    </span>
                    <button class="toggle-switch active" data-linetype="service"></button>
                </div>
            </div>
        </div>
        
        <div class="settings-section">
            <h3>Cloud Sync</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-cloud"></i>
                        Enable Cloud Sync
                    </span>
                    <button class="toggle-switch" id="cloudSyncToggle"></button>
                </div>
            </div>
            <p style="margin-top: var(--spacing-sm); font-size: 12px; color: var(--text-tertiary);">
                Sync your data across devices
            </p>
        </div>
        
        <div class="settings-section">
            <h3>Account</h3>
            <button class="signout-btn" onclick="signOut()">
                <i class="fas fa-sign-out-alt"></i>
                Sign Out
            </button>
        </div>
    </div>

    <!-- Connection Dialog -->
    <div class="connection-dialog" id="connectionDialog">
        <h3>Connect Utilities?</h3>
        <p>The endpoints are close. Would you like to connect them?</p>
        <div class="connection-actions">
            <button class="drawing-btn secondary" id="noConnectBtn">No</button>
            <button class="drawing-btn primary" id="yesConnectBtn">Yes, Connect</button>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Sync Status -->
    <div class="sync-status" id="syncStatus">
        <i class="fas fa-sync"></i>
        <span>Syncing...</span>
    </div>
    
    <!-- Note Input Modal -->
    <div class="note-input-modal" id="noteInputModal">
        <div class="note-input-content">
            <h3 class="note-input-header">Add Note</h3>
            <textarea class="note-textarea" id="noteTextarea" placeholder="Enter your note..."></textarea>
            <div class="note-input-actions">
                <button class="modal-btn secondary" id="cancelNoteBtn">Cancel</button>
                <button class="modal-btn primary" id="saveNoteBtn">Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Leaflet JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

<script>
    // Premium App State
    const AppState = {
        map: null,
        theme: 'light',
        selectedUtility: 'water',
        lineType: 'service',
        isDrawing: false,
        drawingPoints: [],
        tempLine: null,
        utilities: [],
        structures: [],
        userLocation: null,
        userMarker: null,
        watchId: null,
        deviceOrientationHandler: null,
        // Firebase & User Management
        currentUser: null,
        userRole: null, // 'admin', 'user', or 'pending'
        pendingChanges: [],
        allUsers: [],
        realtimeListeners: [], // For cleanup
        // Premium GPS Tracking System
        gps: {
            lastPosition: null,
            filteredPosition: null,
            lastHeading: null,
            filteredHeading: null,
            lastAccuracy: null,
            lastUpdateTime: 0,
            isMoving: false,
            movementSpeed: 0,
            headingHistory: [],
            positionHistory: [],
            quality: 'unknown'
        },
        excavationMode: false,
        proximityAlerts: [],
        proximityAlertsVisible: true,
        selectedUtilityData: null,
        refineMode: false,
        refineMarkers: [],
        addingStructure: false,
        structureToAdd: null,
        measureMode: null,
        measurePoints: [],
        measureMarkers: [],
        measureLine: null,
        measurePolygon: null,
        layers: {
            utilities: {},
            structures: {},
            visibility: {
                water: true,
                gas: true,
                electric: true,
                sewer: true,
                telecom: true,
                main: true,
                service: true
            }
        },
        dismissedAlerts: new Map(),
        alertTimeouts: new Map(),
        connectionCandidate: null,
        mapStyles: {
            streets: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            satellite: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
            'satellite-hd': 'bing-satellite', // Special marker for Bing
            'usgs-hybrid': 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}',
            'infrastructure': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
            'satellite-clarity': 'https://clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
            terrain: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
            dark: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'
        },
        currentMapStyle: 'streets',
        cloudSync: {
            enabled: false,
            lastSync: null,
            apiUrl: 'https://api.cacutilitrack.com',
            userId: null,
            token: null
        },
        // Cached DOM elements for performance
        elements: {
            drawingUI: null,
            refineOverlay: null,
            infoModal: null,
            settingsPanel: null,
            proximityAlerts: null,
            toastContainer: null,
            syncStatus: null
        },
        // Cleanup functions for proper memory management
        cleanupFunctions: []
    };

    // iOS Standalone Mode Fix
    function fixiOSStandalone() {
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                            window.navigator.standalone === true;
        
        if (isIOS && isStandalone) {
            // Fix viewport height
            const setViewportHeight = () => {
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
                
                // Get safe area inset
                const safeAreaBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('env(safe-area-inset-bottom)') || '0');
                
                // Force the app container and map to use the full height including safe area
                const appContainer = document.querySelector('.app-container');
                const mapElement = document.getElementById('map');
                
                if (appContainer) {
                    appContainer.style.height = `${window.innerHeight + safeAreaBottom}px`;
                    appContainer.style.bottom = `-${safeAreaBottom}px`;
                }
                if (mapElement) {
                    mapElement.style.height = `${window.innerHeight + safeAreaBottom}px`;
                }
            };
            
            // Set initial height
            setViewportHeight();
            
            // Update on resize (orientation change)
            window.addEventListener('resize', setViewportHeight);
            window.addEventListener('orientationchange', setViewportHeight);
            
            // Ensure background color extends everywhere
            document.documentElement.style.backgroundColor = '#0a0a0f';
            document.body.style.backgroundColor = '#0a0a0f';
        }
    }

    // Initialize App
    document.addEventListener('DOMContentLoaded', () => {
        fixiOSStandalone();
        initializeApp();
    });

    function initializeApp() {
        // Enhanced mobile detection and optimization
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isAndroid = /Android/.test(navigator.userAgent);
        const isMobile = isIOS || isAndroid || window.innerWidth <= 768;
        
        if (isMobile) {
            document.body.style.height = '100%';
            document.body.style.position = 'fixed';
            document.body.style.overflow = 'hidden';
            document.body.style.width = '100%';
            document.body.style.top = '0';
            document.body.style.left = '0';
            document.documentElement.style.position = 'fixed';
            document.documentElement.style.height = '100%';
            document.documentElement.style.width = '100%';
            document.documentElement.style.overflow = 'hidden';
            
            // Prevent rubber band scrolling on iOS
            if (isIOS) {
                document.addEventListener('touchmove', function(e) {
                    if (e.target.closest('.modal-body, .settings-panel, .proximity-alerts')) {
                        return; // Allow scrolling in specific containers
                    }
                    e.preventDefault();
                }, { passive: false });
                
                // Prevent double-tap zoom
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function(e) {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
            }
        }

        // Check authentication state
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                console.log('🔐 User authenticated:', user.email);
                AppState.currentUser = user;
                
                try {
                    // Get user role from Firestore
                    const userDoc = await db.collection('users').doc(user.uid).get();
                    if (userDoc.exists) {
                        const userData = userDoc.data();
                        AppState.userRole = userData.role || 'pending';
                        
                        console.log('👤 User role from Firestore:', AppState.userRole);
                        
                        // Check if this is the first user and make them admin, or convert old pending users
                        if (AppState.userRole === 'pending' || !AppState.userRole) {
                            const isFirstAdmin = await checkAndMakeFirstAdmin(user.uid);
                            if (isFirstAdmin) {
                                AppState.userRole = 'admin';
                                console.log('👑 First user promoted to admin');
                                showToast('Welcome! You are now the system administrator.', 'success');
                            } else {
                                AppState.userRole = 'restricted';
                                console.log('🚫 User set as restricted');
                                showToast('Account created with restricted access. Please contact admin.', 'info');
                            }
                        }
                    } else {
                        console.warn('⚠️ User authenticated but no Firestore document found');
                        showLoginError('Account setup incomplete. Please contact admin.');
                        setTimeout(() => auth.signOut(), 2000);
                        return;
                    }
                    
                    // Check if user has restricted role
                    if (AppState.userRole === 'restricted') {
                        console.log('🚫 User has restricted role - no access to utilities');
                        document.getElementById('loginScreen').classList.remove('active');
                        showRestrictedScreen();
                        return;
                    }
                    
                    // Successfully authenticated with approved role
                    console.log('✅ User role verified:', AppState.userRole);
                    
                    // Hide login screen and show app
                    document.getElementById('loginScreen').classList.remove('active');
                    
                    // Show role badge and admin button if needed
                    showRoleBadge();
                    
                    // Initialize main app
                    initializeMainApp();
                    
                } catch (error) {
                    console.error('❌ Error checking user role:', error);
                    showLoginError('Error verifying account. Please try again.');
                    setTimeout(() => auth.signOut(), 2000);
                }
                
            } else {
                console.log('🔓 User not authenticated');
                
                // Cleanup any Firebase listeners
                cleanupRealtimeListeners();
                
                // Show login after splash completes
                setTimeout(() => {
                    document.getElementById('splash').classList.add('hide');
                    setTimeout(() => {
                        document.getElementById('splash').style.display = 'none';
                        document.getElementById('loginScreen').classList.add('active');
                    }, 2000);
                }, 3000);
                
                // Setup login handlers
                setupLoginHandlers();
            }
        });

        // ========== TRIPLE AAA QUALITY SPLASH SYSTEM ==========
        let progress = 0;
        const splashElement = document.getElementById('splash');
        const loadingBar = document.getElementById('loadingBar');
        const loadingText = document.getElementById('loadingText');
        const loadingPercentage = document.getElementById('loadingPercentage');
        
        // Ultra-sophisticated loading stages with technical descriptions
        const loadingStages = [
            { stage: 'Initializing Neural Networks', duration: 1200, progressJump: 18, color: '#667eea' },
            { stage: 'Calibrating GPS Matrix', duration: 900, progressJump: 22, color: '#ff006e' },
            { stage: 'Loading Quantum Processors', duration: 1100, progressJump: 20, color: '#00f5a0' },
            { stage: 'Optimizing Vector Graphics', duration: 800, progressJump: 25, color: '#ffd60a' },
            { stage: 'Finalizing Core Systems', duration: 600, progressJump: 15, color: '#b565d8' }
        ];
        
        let currentStage = 0;
        
        // Start neural particle animation with sophisticated timing
        setTimeout(() => {
            const particles = document.querySelectorAll('.neural-particle');
            particles.forEach((particle, index) => {
                setTimeout(() => {
                    particle.style.opacity = '1';
                    // Start the neural flow animation with randomized durations
                    const duration = 12 + Math.random() * 8; // 12-20 seconds
                    particle.style.animationDuration = `${duration}s`;
                }, index * 300 + Math.random() * 500);
            });
        }, 800);
        
        // Advanced loading system with smooth animations
        function updateTripleAProgress() {
            if (currentStage < loadingStages.length) {
                const stage = loadingStages[currentStage];
                
                // Update loading text with smooth transition
                loadingText.style.opacity = '0';
                setTimeout(() => {
                    loadingText.textContent = stage.stage;
                    loadingText.style.opacity = '1';
                }, 200);
                
                // Smooth progress increment with easing
                const startProgress = progress;
                const targetProgress = Math.min(progress + stage.progressJump, 100);
                const startTime = Date.now();
                
                function animateProgress() {
                    const elapsed = Date.now() - startTime;
                    const progressPercent = Math.min(elapsed / stage.duration, 1);
                    
                    // Use easeOutCubic for smooth progress animation
                    const eased = 1 - Math.pow(1 - progressPercent, 3);
                    progress = startProgress + (stage.progressJump * eased);
                    
                    // Update visual elements
                    loadingBar.style.width = `${progress}%`;
                    loadingPercentage.textContent = `${Math.round(progress)}%`;
                    
                    // Dynamic color shifting based on stage
                    loadingBar.style.boxShadow = `0 0 20px ${stage.color}30`;
                    
                    // Add subtle pulsing effect at milestones
                    if (Math.round(progress) % 25 === 0 && Math.round(progress) > 0) {
                        loadingPercentage.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            loadingPercentage.style.transform = 'scale(1)';
                        }, 200);
                    }
                    
                    if (progressPercent < 1) {
                        requestAnimationFrame(animateProgress);
                    } else {
                        progress = targetProgress;
                        
                        if (progress >= 100) {
                            // Ultra-premium completion sequence
                            completeSplashScreen();
                        } else {
                            currentStage++;
                            setTimeout(updateTripleAProgress, 300);
                        }
                    }
                }
                
                requestAnimationFrame(animateProgress);
            }
        }
        
        function completeSplashScreen() {
            // Final stage visual effects
            loadingText.style.opacity = '0';
            setTimeout(() => {
                loadingText.textContent = 'SYSTEM READY';
                loadingText.style.opacity = '1';
                loadingText.style.color = '#00f5a0';
                loadingText.style.fontWeight = '700';
                loadingText.style.letterSpacing = '2px';
            }, 200);
            
            loadingPercentage.textContent = 'READY';
            loadingPercentage.style.color = '#00f5a0';
            loadingPercentage.style.transform = 'scale(1.2)';
            
            // Advanced exit sequence with multiple effects
            setTimeout(() => {
                splashElement.style.transition = 'all 2s cubic-bezier(0.23, 1, 0.32, 1)';
                splashElement.style.transform = 'scale(1.1)';
                splashElement.style.filter = 'blur(20px)';
                
                setTimeout(() => {
                    splashElement.classList.add('hide');
                    
                    // Additional cleanup after transition
                    setTimeout(() => {
                        splashElement.style.display = 'none';
                    }, 2000);
                }, 500);
            }, 1200);
        }
        
        // Start the sophisticated loading sequence
        setTimeout(() => {
            updateTripleAProgress();
        }, 1500);
    }

    // Graceful Firestore collection handling - no placeholder documents needed
    function setupGracefulFirestoreHandling() {
        console.log('🔧 Setting up graceful Firestore collection handling...');
        
        // Override Firestore collection methods to handle missing collections gracefully
        const originalGet = db.collection;
        
        // Add global error handler for Firestore operations
        AppState.firestoreErrorHandler = (collectionName, operation, error) => {
            const isCollectionNotFound = error.code === 'not-found' || 
                                        error.code === 'failed-precondition' ||
                                        error.message.includes('Collection') ||
                                        error.message.includes('Missing or insufficient permissions');
            
            if (isCollectionNotFound) {
                console.log(`📝 Collection '${collectionName}' doesn't exist yet - this is normal for new systems`);
                return { empty: true, docs: [], size: 0 };
            } else {
                console.error(`❌ Real Firestore error in ${collectionName}.${operation}:`, error);
                throw error; // Re-throw real errors
            }
        };
        
        // Enhanced collection reference with built-in error handling
        AppState.safeCollection = (collectionName) => {
            const originalRef = db.collection(collectionName);
            
            // Override get method to handle missing collections
            const originalGetMethod = originalRef.get;
            originalRef.get = async function() {
                try {
                    const result = await originalGetMethod.call(this);
                    return result;
                } catch (error) {
                    return AppState.firestoreErrorHandler(collectionName, 'get', error);
                }
            };
            
            // Override onSnapshot to handle missing collections
            const originalOnSnapshot = originalRef.onSnapshot;
            originalRef.onSnapshot = function(successCallback, errorCallback) {
                const wrappedSuccessCallback = (snapshot) => {
                    successCallback(snapshot);
                };
                
                const wrappedErrorCallback = (error) => {
                    const isCollectionNotFound = error.code === 'not-found' || 
                                               error.code === 'failed-precondition';
                    
                    if (isCollectionNotFound) {
                        console.log(`📝 Real-time listener: Collection '${collectionName}' doesn't exist yet`);
                        // Create empty snapshot-like object
                        const emptySnapshot = {
                            empty: true,
                            docs: [],
                            size: 0,
                            docChanges: () => []
                        };
                        successCallback(emptySnapshot);
                    } else if (errorCallback) {
                        errorCallback(error);
                    } else {
                        console.error(`❌ Real-time listener error in ${collectionName}:`, error);
                    }
                };
                
                return originalOnSnapshot.call(this, wrappedSuccessCallback, wrappedErrorCallback);
            };
            
            return originalRef;
        };
        
        console.log('✅ Graceful Firestore handling setup complete');
    }

    // New function to initialize the main app after authentication
    function initializeMainApp() {
        console.log('🚀 Initializing main app for user:', AppState.currentUser.email);

        // Comprehensive iOS Standalone Fix - MUST BE FIRST
        const isiOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                            window.navigator.standalone === true;
        
        if (isiOSDevice) {
            // Prevent ALL scrolling and bouncing
            document.body.addEventListener('touchmove', function(e) {
                if (!e.target.closest('.modal-body, .settings-panel, .proximity-alerts, .notes-list')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Lock the viewport
            window.addEventListener('scroll', function() {
                window.scrollTo(0, 0);
            });
            
            // Prevent double-tap zoom everywhere (including map)
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(e) {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    // Prevent any default double-tap behavior
                    return false;
                }
                lastTouchEnd = now;
            }, { passive: false, capture: true });
            
            // Additional double-tap prevention on touchstart (but allow multi-touch for pinch zoom)
            let lastTouchStart = 0;
            document.addEventListener('touchstart', function(e) {
                // Only allow multi-touch on map for pinch zoom (not single finger double-tap)
                if (e.target.closest('#map') && e.touches.length > 1) {
                    return; // Allow pinch zoom gestures
                }
                
                const now = Date.now();
                if (now - lastTouchStart <= 300) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    return false;
                }
                lastTouchStart = now;
            }, { passive: false, capture: true });
            
            // Allow pinch zoom gestures on map only
            document.addEventListener('gesturestart', function(e) {
                if (!e.target.closest('#map')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('gesturechange', function(e) {
                if (!e.target.closest('#map')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('gestureend', function(e) {
                if (!e.target.closest('#map')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Prevent double-click zoom everywhere (including map)
            document.addEventListener('dblclick', function(e) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return false;
            }, { passive: false, capture: true });
            
            if (isStandalone) {
                // Force exact viewport dimensions
                const setRealViewportHeight = () => {
                    const height = window.innerHeight;
                    const safeBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('padding-bottom') || '0');
                    
                    document.documentElement.style.height = `${height}px`;
                    document.body.style.height = `${height}px`;
                    
                    const appContainer = document.querySelector('.app-container');
                    if (appContainer) {
                        appContainer.style.height = `${height + safeBottom}px`;
                        appContainer.style.bottom = `-${safeBottom}px`;
                    }
                    
                    const mapElement = document.getElementById('map');
                    if (mapElement) {
                        mapElement.style.height = `${height + safeBottom}px`;
                    }
                    
                    // Force background everywhere
                    document.documentElement.style.backgroundColor = '#0a0a0f';
                    document.body.style.backgroundColor = '#0a0a0f';
                    
                    // Hide any overflow
                    document.documentElement.style.overflow = 'hidden';
                    document.body.style.overflow = 'hidden';
                    
                    // Force position
                    window.scrollTo(0, 0);
                    
                    // Reset any transforms that might have been applied
                    document.body.style.transform = 'none';
                    document.documentElement.style.transform = 'none';
                };
                
                // Apply immediately
                setRealViewportHeight();
                
                // Reapply on any resize
                window.addEventListener('resize', () => {
                    setTimeout(setRealViewportHeight, 0);
                });
                
                window.addEventListener('orientationchange', () => {
                    setTimeout(setRealViewportHeight, 100);
                });
                
                // Force on visibility change
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        setTimeout(setRealViewportHeight, 100);
                    }
                });
                
                // Prevent viewport changes outside of map area
                document.addEventListener('touchmove', function(e) {
                    if (e.scale && e.scale !== 1 && !e.target.closest('#map')) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }
        }

        // Setup graceful Firestore collection handling
        setupGracefulFirestoreHandling();

        // Initialize core systems
        initializeMap();
        initializeDOMCache();
        initializeEventListeners();

        // Enhanced theme management - default to light mode
        const savedTheme = localStorage.getItem('theme') || 'light';
        setTheme(savedTheme);

        // Watch for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                setTheme(e.matches ? 'dark' : 'light');
            }
        });

        // Load data from Firestore
        loadUtilities();
        loadStructures();

        // Setup real-time sync for utilities and structures
        setupRealtimeSync();

        // Setup admin listeners if admin
        if (AppState.userRole === 'admin') {
            setupAdminListeners();
        }

        // Apply initial zoom-based opacity
        setTimeout(() => {
            handleZoomChange();
        }, 1000);

        // Start premium location tracking with enhanced permissions
        requestLocationPermissions();

        // Premium GPS system initialized
        console.log('🚀 CAC UTILI-TRACK SHARED MAP SYSTEM READY! 🚀');
        console.log('');
        console.log('🔥 NEW SHARED MAP FEATURES:');
        console.log('  ✅ Everyone sees the same map');
        console.log('  ✅ Admin approval system');
        console.log('  ✅ Real-time updates');
        console.log('  ✅ User role management');
        console.log('');
        console.log('👑 YOUR ROLE:', AppState.userRole?.toUpperCase() || 'UNKNOWN');
        if (AppState.userRole === 'admin') {
            console.log('  🎯 You can approve changes and manage users');
            console.log('  🎯 Click the admin button (⚙️) in the top right');
        } else if (AppState.userRole === 'restricted') {
            console.log('  🚫 Your account has restricted access');
            console.log('  🚫 Contact an administrator to gain access');
        } else {
            console.log('  📝 Direct save enabled - create utilities freely');
            console.log('  📝 No approval process required');
        }
        console.log('');
        console.log('🔧 DEBUG COMMANDS:');
        console.log('  - debugAccountStatus() : Check your account status');
        console.log('  - demoPremiumGPS() : Test GPS features');
        console.log('  - testMobileTouch() : Test mobile touch');
        console.log('');
        console.log('❓ HAVING ISSUES?');
        console.log('  1. Run: debugAccountStatus()');
        console.log('  2. Check your role and Firestore document');
        console.log('  3. Sign out and back in if needed');
        console.log('');

        // Enhanced keyboard handling for iOS
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        if (isIOS) {
            const viewport = document.querySelector('meta[name=viewport]');
            const viewportContent = 'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
            
            // Set and lock viewport
            viewport.setAttribute('content', viewportContent);
            
            // Prevent any changes
            const observer = new MutationObserver(() => {
                if (viewport.getAttribute('content') !== viewportContent) {
                    viewport.setAttribute('content', viewportContent);
                }
            });
            
            observer.observe(viewport, { attributes: true, attributeFilter: ['content'] });
            
            // Handle focus events without changing viewport
            document.addEventListener('focusin', function(e) {
                e.preventDefault();
                viewport.setAttribute('content', viewportContent);
            });
            
            document.addEventListener('focusout', function(e) {
                e.preventDefault();
                viewport.setAttribute('content', viewportContent);
            });
        }
        
        // Performance monitoring
        if ('performance' in window && 'PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.entryType === 'paint' && entry.name === 'first-contentful-paint') {
                        console.log('First Contentful Paint:', entry.startTime);
                    }
                }
            });
            observer.observe({ entryTypes: ['paint'] });
        }
    }
    
    async function requestLocationPermissions() {
        if (!navigator.geolocation) {
            showToast('Geolocation not supported', 'error');
            return;
        }
        
        try {
            // Check current permission state
            if ('permissions' in navigator) {
                const permission = await navigator.permissions.query({name: 'geolocation'});
                if (permission.state === 'denied') {
                    showToast('Location access denied. Please enable in settings.', 'warning');
                    return;
                }
            }

        // Start location tracking
        startLocationTracking();

        } catch (error) {
            console.error('Permission error:', error);
            // Fallback to direct geolocation request
            startLocationTracking();
        }
    }

    // ========== FIREBASE AUTHENTICATION & ADMIN SYSTEM ==========



    async function checkAndMakeFirstAdmin(userId) {
        console.log('👑 Checking if first admin should be created...');
        
        try {
            // Check if any admin users exist
            const adminSnapshot = await db.collection('users')
                .where('role', '==', 'admin')
                .limit(1)
                .get();
            
            if (adminSnapshot.empty) {
                // No admins exist, make this user an admin
                console.log('🎯 No admins found, promoting first user to admin');
                
                await db.collection('users').doc(userId).update({
                    role: 'admin',
                    promotedToAdmin: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                console.log('✅ First user promoted to admin successfully');
                return true;
            } else {
                // Set new users as restricted by default
                console.log('🚫 Admin users already exist, setting user as restricted');
                await db.collection('users').doc(userId).update({
                    role: 'restricted'
                });
                return false;
            }
            
        } catch (error) {
            console.error('❌ Error checking for first admin:', error);
            return false;
        }
    }

    function setupLoginHandlers() {
        console.log('🔑 Setting up login handlers');
        
        // Allow Enter key to submit
        document.getElementById('loginPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleEmailLogin();
            }
        });
        
        // Sign In
        document.getElementById('loginBtn').addEventListener('click', async () => {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showLoginError('Please enter both email and password');
                return;
            }
            
            try {
                showLoginError('');
                const result = await auth.signInWithEmailAndPassword(email, password);
                
                // Check if user document exists in Firestore
                const userDoc = await db.collection('users').doc(result.user.uid).get();
                if (!userDoc.exists) {
                    console.log('👤 Creating missing user document for existing user');
                    // Create user document if it doesn't exist (for existing auth users)
                    await db.collection('users').doc(result.user.uid).set({
                        email: result.user.email,
                        uid: result.user.uid,
                        role: 'pending', // New users start as pending
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        // Experience system fields with defaults
                        exp: 0,
                        level: 1,
                        achievements: [],
                        totalUtilitiesDrawn: 0,
                        profileAvatar: 1,
                        statsWater: 0,
                        statsGas: 0,
                        statsElectric: 0,
                        statsSewer: 0,
                        statsTelecom: 0,
                        totalDistance: 0
                    });
                    showLoginError('Account created in database. Awaiting admin approval.');
                    await auth.signOut();
                    return;
                }
                
                showLoginError('');
            } catch (error) {
                console.error('Login error:', error);
                let message = 'Login failed';
                switch (error.code) {
                    case 'auth/user-not-found':
                        message = 'No account found with this email';
                        break;
                    case 'auth/wrong-password':
                        message = 'Incorrect password';
                        break;
                    case 'auth/invalid-email':
                        message = 'Invalid email address';
                        break;
                    case 'auth/too-many-requests':
                        message = 'Too many failed attempts. Please try again later';
                        break;
                    default:
                        message = error.message || 'Login failed';
                }
                showLoginError(message);
            }
        });
        
        // Sign Up
        document.getElementById('signupBtn').addEventListener('click', async () => {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showLoginError('Please enter email and password');
                return;
            }
            
            if (password.length < 6) {
                showLoginError('Password must be at least 6 characters');
                return;
            }
            
            try {
                showLoginError('');
                const result = await auth.createUserWithEmailAndPassword(email, password);
                
                console.log('👤 Creating user document for new signup');
                // Create user document in Firestore
                await db.collection('users').doc(result.user.uid).set({
                    email: result.user.email,
                    uid: result.user.uid,
                    role: 'restricted',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    // Experience system fields with defaults
                    exp: 0,
                    level: 1,
                    achievements: [],
                    totalUtilitiesDrawn: 0,
                    profileAvatar: 1,
                    statsWater: 0,
                    statsGas: 0,
                    statsElectric: 0,
                    statsSewer: 0,
                    statsTelecom: 0,
                    totalDistance: 0
                });
                
                showLoginError('✅ Account created successfully! Awaiting admin approval.');
                
                // Sign out immediately since they're pending
                await auth.signOut();
                
            } catch (error) {
                console.error('Signup error:', error);
                let message = 'Signup failed';
                switch (error.code) {
                    case 'auth/email-already-in-use':
                        message = 'Email already registered';
                        break;
                    case 'auth/invalid-email':
                        message = 'Invalid email address';
                        break;
                    case 'auth/weak-password':
                        message = 'Password is too weak';
                        break;
                    default:
                        message = error.message || 'Signup failed';
                }
                showLoginError(message);
            }
        });
        
        // Google Sign In
        document.getElementById('googleBtn').addEventListener('click', async () => {
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                showLoginError('');
                const result = await auth.signInWithPopup(provider);
                
                // Check if user document exists
                const userDoc = await db.collection('users').doc(result.user.uid).get();
                if (!userDoc.exists) {
                    console.log('👤 Creating user document for new Google user');
                    // Create user document for Google users
                    await db.collection('users').doc(result.user.uid).set({
                        email: result.user.email,
                        uid: result.user.uid,
                        displayName: result.user.displayName || '',
                        role: 'restricted',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        // Experience system fields with defaults
                        exp: 0,
                        level: 1,
                        achievements: [],
                        totalUtilitiesDrawn: 0,
                        profileAvatar: 1,
                        statsWater: 0,
                        statsGas: 0,
                        statsElectric: 0,
                        statsSewer: 0,
                        statsTelecom: 0,
                        totalDistance: 0
                    });
                    
                    showLoginError('✅ Google account created! Awaiting admin approval.');
                    await auth.signOut();
                    return;
                }
                
                showLoginError('');
            } catch (error) {
                console.error('Google login error:', error);
                if (error.code !== 'auth/popup-closed-by-user') {
                    showLoginError('Google sign-in failed. Please try again.');
                }
            }
        });
    }

    function showLoginError(message) {
        const errorEl = document.getElementById('loginError');
        if (message) {
            errorEl.textContent = message;
            errorEl.classList.add('show');
        } else {
            errorEl.classList.remove('show');
        }
    }

    function showRestrictedScreen() {
        // Hide main app UI elements
        const elementsToHide = [
            '.top-bar',
            '.bottom-controls',
            '.right-controls',
            '.measurement-tools',
            '.structure-container'
        ];
        
        elementsToHide.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
                element.style.display = 'none';
            }
        });
        
        // Show role badge
        showRoleBadge();
        
        // Show restricted message on map
        const restrictedMessage = document.createElement('div');
        restrictedMessage.id = 'restrictedMessage';
        restrictedMessage.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: var(--spacing-2xl);
            border-radius: var(--radius-xl);
            text-align: center;
            z-index: 1000;
            box-shadow: var(--shadow-xl);
            max-width: 400px;
            border: 1px solid var(--border-color);
        `;
        restrictedMessage.innerHTML = `
            <i class="fas fa-lock" style="font-size: 48px; color: var(--danger-color); margin-bottom: 16px; display: block;"></i>
            <h2 style="margin-bottom: 16px; color: var(--text-primary);">Access Restricted</h2>
            <p style="color: var(--text-secondary); margin-bottom: 24px; line-height: 1.5;">
                Your account is pending approval. Please contact an administrator to gain access to the utility mapping system.
            </p>
            <button class="signout-btn" onclick="signOut()" style="width: 100%; margin-top: 0;">
                <i class="fas fa-sign-out-alt"></i>
                Sign Out
            </button>
        `;
        document.body.appendChild(restrictedMessage);
    }

    function showRoleBadge() {
        // Remove existing badge/button
        const existingBadge = document.querySelector('.role-badge');
        const existingAdminBtn = document.querySelector('.admin-btn');
        if (existingBadge) existingBadge.remove();
        if (existingAdminBtn) existingAdminBtn.remove();
        
        // Role icons and names
        const roleIcons = {
            admin: 'fa-user-shield',
            supervisor: 'fa-user-tie',
            pitman: 'fa-hard-hat',
            restricted: 'fa-lock'
        };
        
        const roleNames = {
            admin: 'ADMIN',
            supervisor: 'SUPERVISOR',
            pitman: 'PITMAN/MO',
            restricted: 'RESTRICTED'
        };
        
        // Add role badge
        const badge = document.createElement('div');
        badge.className = `role-badge ${AppState.userRole}`;
        badge.innerHTML = `
            <i class="fas ${roleIcons[AppState.userRole] || 'fa-user'}"></i>
            ${roleNames[AppState.userRole] || AppState.userRole.toUpperCase()}
        `;
        document.body.appendChild(badge);
        
        // Show admin panel button for admins and supervisors (not for restricted)
        if (AppState.userRole === 'admin' || AppState.userRole === 'supervisor') {
            const adminBtn = document.createElement('button');
            adminBtn.className = 'admin-btn';
            adminBtn.innerHTML = '<i class="fas fa-cog"></i>';
            adminBtn.onclick = openAdminPanel;
            adminBtn.title = 'Admin Panel';
            document.body.appendChild(adminBtn);
        }
    }



    function setupAdminListeners() {
        if (AppState.userRole !== 'admin' && AppState.userRole !== 'supervisor') {
            console.log('⚠️ Not admin or supervisor, skipping admin listeners');
            return;
        }
        
        console.log('🔄 Setting up admin real-time listeners...');
        
        // Listen for user changes
        const usersListener = AppState.safeCollection('users')
            .onSnapshot((snapshot) => {
                if (document.getElementById('adminPanel').classList.contains('active')) {
                    loadUsers(); // Refresh user list if admin panel is open
                }
            }, (error) => {
                console.error('❌ Error listening to users:', error);
            });
        
        AppState.realtimeListeners = [usersListener];
        console.log('✅ Admin listeners setup complete');
    }

    function cleanupRealtimeListeners() {
        console.log('🧹 Cleaning up Firebase listeners');
        AppState.realtimeListeners.forEach(unsubscribe => {
            try {
                unsubscribe();
            } catch (error) {
                console.error('Error unsubscribing listener:', error);
            }
        });
        AppState.realtimeListeners = [];
    }



    function removeUtilityFromMap(utilityId) {
        const index = AppState.utilities.findIndex(u => u.id === utilityId);
        if (index > -1) {
            const utility = AppState.utilities[index];
            
            // Remove from map
            if (utility.lineLayer) {
                AppState.map.removeLayer(utility.lineLayer);
            }
            if (utility.touchTarget) {
                AppState.map.removeLayer(utility.touchTarget);
            }
            if (utility.connectionMarkers) {
                utility.connectionMarkers.forEach(marker => {
                    if (AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                });
            }
            
            // Remove from state
            AppState.utilities.splice(index, 1);
        }
    }

    function removeStructureFromMap(structureId) {
        const index = AppState.structures.findIndex(s => s.id === structureId);
        if (index > -1) {
            const structure = AppState.structures[index];
            
            // Remove from map
            if (structure.marker) {
                AppState.map.removeLayer(structure.marker);
            }
            
            // Remove from state
            AppState.structures.splice(index, 1);
        }
    }

    function initializeDOMCache() {
        // Cache frequently accessed DOM elements for performance
        AppState.elements.drawingUI = document.getElementById('drawingUI');
        AppState.elements.refineOverlay = document.getElementById('refineOverlay');
        AppState.elements.infoModal = document.getElementById('infoModal');
        AppState.elements.settingsPanel = document.getElementById('settingsPanel');
        AppState.elements.proximityAlerts = document.getElementById('proximityAlerts');
        AppState.elements.toastContainer = document.getElementById('toastContainer');
        AppState.elements.syncStatus = document.getElementById('syncStatus');
    }

    // Add Bing Maps Helper Class
    L.TileLayer.Bing = L.TileLayer.extend({
        options: {
            subdomains: '0123',
            attribution: '© Microsoft'
        },
        initialize: function(type, options) {
            L.setOptions(this, options);
            this._type = type;
            this._url = 'https://t{s}.ssl.ak.tiles.virtualearth.net/tiles/' + type + '{q}.jpeg?g=1';
        },
        getTileUrl: function(coords) {
            return L.Util.template(this._url, L.extend({
                s: this._getSubdomain(coords),
                q: this._getQuadkey(coords)
            }, this.options));
        },
        _getQuadkey: function(coords) {
            const quadkey = [];
            for (let i = coords.z; i > 0; i--) {
                let digit = 0;
                const mask = 1 << (i - 1);
                if ((coords.x & mask) !== 0) digit++;
                if ((coords.y & mask) !== 0) digit += 2;
                quadkey.push(digit);
            }
            return quadkey.join('');
        }
    });

    function initializeMap() {
        // Create map
        AppState.map = L.map('map', {
            center: [40.7128, -74.0060], // Default to NYC
            zoom: 16,
            zoomControl: false,
            attributionControl: false,
            doubleClickZoom: false, // Disable double-click zoom
            touchZoom: true,
            scrollWheelZoom: true,
            boxZoom: false,
            keyboard: false,
            tap: true, // Enable tap for touch devices
            bounceAtZoomLimits: false,
            inertia: true, // Enable smooth panning
            zoomAnimation: true, // Enable zoom animations
            // Enhanced touch settings
            touchZoom: 'center', // Center pinch zoom
            wheelPxPerZoomLevel: 60,
            zoomSnap: 0.25, // Allow fractional zoom levels
            zoomDelta: 0.25
        });

        // Add tile layer
        L.tileLayer(AppState.mapStyles[AppState.currentMapStyle], {
            maxZoom: 22,
            maxNativeZoom: 19
        }).addTo(AppState.map);

        // Initialize utility layers
        const utilityTypes = ['water', 'gas', 'electric', 'sewer', 'telecom'];
        utilityTypes.forEach(type => {
            AppState.layers.utilities[type] = L.layerGroup().addTo(AppState.map);
            AppState.layers.structures[type] = L.layerGroup().addTo(AppState.map);
        });

        // Map events
        AppState.map.on('click', handleMapClick);
        AppState.map.on('contextmenu', function(e) {
            if (e && e.originalEvent) {
                e.originalEvent.preventDefault();
            }
            return false;
        });
        AppState.map.on('zoomend', handleZoomChange);
        AppState.map.on('zoom', handleZoomChange); // For smooth transitions during zoom
    }

    function initializeEventListeners() {
        // Prevent all context menus
        document.addEventListener('contextmenu', function(e) {
            if (e && e.preventDefault) {
                e.preventDefault();
            }
            return false;
        });

        // Utility selection
        document.querySelectorAll('.utility-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('.utility-btn').forEach(b => {
                    b.classList.remove('active');
                    b.setAttribute('aria-pressed', 'false');
                });
                btn.classList.add('active');
                btn.setAttribute('aria-pressed', 'true');
                AppState.selectedUtility = btn.dataset.utility;
                hapticFeedback(30);
            });
        });

        // Line type selection
        document.querySelectorAll('.line-type-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('.line-type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                AppState.lineType = btn.dataset.type;
                hapticFeedback(30);
            });
        });

        // Control buttons
        document.getElementById('drawBtn').addEventListener('click', startDrawing);
        document.getElementById('locateBtn').addEventListener('click', centerOnLocation);
        document.getElementById('layersBtn').addEventListener('click', toggleLayersPanel);
        document.getElementById('excavationBtn').addEventListener('click', toggleExcavationMode);
        document.getElementById('settingsBtn').addEventListener('click', openSettings);
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            AppState.map.zoomIn();
            hapticFeedback(20);
        });
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            AppState.map.zoomOut();
            hapticFeedback(20);
        });

        // Orientation permission button (iOS standalone mode)
        document.getElementById('orientationPermissionBtn').addEventListener('click', requestOrientationPermission);

        // Measurement tools
        document.getElementById('measureDistanceBtn').addEventListener('click', () => toggleMeasureMode('distance'));
        document.getElementById('measureAreaBtn').addEventListener('click', () => toggleMeasureMode('area'));

        // Structure button
        document.getElementById('addStructureBtn').addEventListener('click', toggleStructureMenu);
        document.querySelectorAll('.structure-type-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                startAddingStructure(btn.dataset.structure, btn.dataset.utility);
            });
        });

        // Drawing controls
        document.getElementById('cancelDrawBtn').addEventListener('click', cancelDrawing);
        document.getElementById('finishDrawBtn').addEventListener('click', finishDrawing);

        // Refine controls
        document.getElementById('finishRefineBtn').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            finishRefining();
        });

        // Modal controls
        document.getElementById('closeModalBtn').addEventListener('click', closeInfoModal);
        document.getElementById('editBtn').addEventListener('click', enterEditMode);
        document.getElementById('refineBtn').addEventListener('click', (e) => {
            console.log('🔧 Refine button clicked');
            startRefineLocation();
        });
        document.getElementById('deleteBtn').addEventListener('click', deleteUtility);

        // Edit form controls
        document.getElementById('cancelEditBtn').addEventListener('click', exitEditMode);
        document.getElementById('saveEditBtn').addEventListener('click', saveEdit);

        // Notes
        document.getElementById('addNoteBtn').addEventListener('click', showNoteInput);
        
        // Note input modal
        document.getElementById('cancelNoteBtn').addEventListener('click', hideNoteInput);
        document.getElementById('saveNoteBtn').addEventListener('click', saveNote);

        // Search functionality
        document.getElementById('searchBtn').addEventListener('click', openSearchModal);
        document.getElementById('searchCloseBtn').addEventListener('click', closeSearchModal);
        document.getElementById('searchSubmitBtn').addEventListener('click', performSearch);
        document.getElementById('searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });

        // Excavation mode
        document.getElementById('exitExcavationBtn').addEventListener('click', exitExcavationMode);
        document.getElementById('alertToggleBtn').addEventListener('click', toggleProximityAlerts);

        // Settings
        document.getElementById('closeSettingsBtn').addEventListener('click', closeSettings);
        document.getElementById('darkModeToggle').addEventListener('click', toggleDarkMode);
        document.getElementById('cloudSyncToggle').addEventListener('click', toggleCloudSync);

        // Map style buttons
        document.querySelectorAll('.map-style-btn').forEach(btn => {
            btn.addEventListener('click', () => changeMapStyle(btn.dataset.style));
        });

        // Visibility toggles
        document.querySelectorAll('.toggle-switch[data-utility]').forEach(toggle => {
            toggle.addEventListener('click', () => toggleUtilityVisibility(toggle));
        });

        document.querySelectorAll('.toggle-switch[data-linetype]').forEach(toggle => {
            toggle.addEventListener('click', () => toggleLineTypeVisibility(toggle));
        });

        // Connection dialog
        document.getElementById('noConnectBtn').addEventListener('click', () => {
            closeConnectionDialog(false);
        });
        document.getElementById('yesConnectBtn').addEventListener('click', () => {
            closeConnectionDialog(true);
        });

        // Close menus on outside click and cancel structure placement
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.structure-container')) {
                document.getElementById('structureMenu').classList.remove('active');
            }
        });

        // Add escape key handler to cancel structure placement
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (AppState.addingStructure) {
                    cancelStructurePlacement();
                }
            }
        });

        // Enhanced gesture prevention for iOS/Safari
        const preventGestures = (e) => e.preventDefault();
        document.addEventListener('gesturestart', preventGestures);
        document.addEventListener('gesturechange', preventGestures);
        document.addEventListener('gestureend', preventGestures);
        
        // Store cleanup functions for proper app shutdown
        AppState.cleanupFunctions = [
            () => {
                document.removeEventListener('gesturestart', preventGestures);
                document.removeEventListener('gesturechange', preventGestures);
                document.removeEventListener('gestureend', preventGestures);
            }
        ];
    }

    // Haptic Feedback
    function hapticFeedback(duration = 50) {
        if ('vibrate' in navigator) {
            navigator.vibrate(duration);
        }
    }

    // Location tracking
    function startLocationTracking() {
        if (!navigator.geolocation) {
            showToast('Geolocation not supported', 'error');
            return;
        }

        console.log('🎯 Starting location tracking...');

        // Get initial position with better options
        navigator.geolocation.getCurrentPosition(
            position => {
                console.log('✅ Initial location acquired');
                updateUserLocation(position);
            },
            error => {
                console.error('❌ Initial location error:', error);
                showToast('Location access denied', 'error');
            },
            { 
                enableHighAccuracy: true,
                timeout: 15000,
                maximumAge: 0
            }
        );

        // Watch position with more forgiving settings
        AppState.watchId = navigator.geolocation.watchPosition(
            position => {
                updateUserLocation(position);
            },
            error => {
                console.error('❌ Watch position error:', error);
                let message = 'Location error';
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        message = 'Location access denied by user';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        message = 'Location information unavailable';
                        break;
                    case error.TIMEOUT:
                        message = 'Location request timed out';
                        break;
                }
                showToast(message, 'warning');
            },
            {
                enableHighAccuracy: true,
                timeout: 15000,
                maximumAge: 5000  // Allow slightly cached positions
            }
        );

        // Watch device orientation - Handle iOS standalone mode properly
        if (window.DeviceOrientationEvent) {
            // Check if we need permission (iOS 13+)
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                // For iOS standalone mode, show button instead of auto-requesting
                const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                                   window.navigator.standalone === true;
                
                if (isStandalone) {
                    console.log('📱 iOS Standalone mode detected - showing orientation permission button');
                    showOrientationPermissionButton();
                } else {
                    // Not standalone, try auto-request
                    requestOrientationPermission();
                }
            } else {
                // No permission needed (Android, older iOS)
                console.log('🧭 Setting up orientation listeners (no permission required)');
                window.addEventListener('deviceorientation', handleDeviceOrientation);
                window.addEventListener('deviceorientationabsolute', handleDeviceOrientation);
            }
        }
    }

    function handleDeviceOrientation(event) {
        let heading = null;
        
        console.log('🧭 Orientation event received:', {
            alpha: event.alpha,
            beta: event.beta,
            gamma: event.gamma,
            absolute: event.absolute,
            webkitCompassHeading: event.webkitCompassHeading
        });
        
        // iOS with compass heading (most reliable for iOS)
        if (event.webkitCompassHeading !== undefined && event.webkitCompassHeading !== null) {
            heading = event.webkitCompassHeading;
            console.log('🧭 Using iOS webkitCompassHeading:', heading);
        }
        // For absolute orientation event (modern browsers)
        else if (event.absolute && event.alpha !== null) {
            heading = 360 - event.alpha; // Convert to compass heading
            console.log('🧭 Using absolute alpha:', heading);
        }
        // Android or iOS without compass
        else if (event.alpha !== null) {
            // Check if we're in standalone mode on iOS
            const isIOSStandalone = /iPad|iPhone|iPod/.test(navigator.userAgent) && 
                                   (window.matchMedia('(display-mode: standalone)').matches || 
                                    window.navigator.standalone === true);
            
            if (isIOSStandalone) {
                // iOS standalone mode - alpha is relative to initial orientation
                // We need to account for the device's initial orientation
                const orientation = screen.orientation ? screen.orientation.angle : window.orientation || 0;
                heading = (360 - event.alpha + orientation) % 360;
                console.log('🧭 iOS Standalone - adjusted heading:', heading, 'orientation:', orientation);
            } else {
                // Standard handling for other platforms
                heading = 360 - event.alpha;
                console.log('🧭 Using standard alpha:', heading);
            }
        }
        
        if (heading !== null) {
            console.log('🧭 Final heading:', heading);
            updatePremiumDirectionIndicator(heading);
        } else {
            console.log('🧭 No valid heading data received');
        }
    }

    function showOrientationPermissionButton() {
        const button = document.getElementById('orientationPermissionBtn');
        if (button) {
            button.classList.add('show');
            console.log('🧭 Orientation permission button shown');
            showToast('Tap the compass button to enable direction indicator', 'info');
        }
    }

    function requestOrientationPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permission => {
                    if (permission === 'granted') {
                        console.log('✅ Orientation permission granted');
                        window.addEventListener('deviceorientation', handleDeviceOrientation);
                        window.addEventListener('deviceorientationabsolute', handleDeviceOrientation);
                        hideOrientationPermissionButton();
                        showToast('Compass direction enabled!', 'success');
                        hapticFeedback(100);
                    } else {
                        console.log('❌ Orientation permission denied');
                        showToast('Direction indicator requires orientation permission', 'warning');
                    }
                })
                .catch(error => {
                    console.error('Error requesting orientation permission:', error);
                    showToast('Error requesting orientation permission', 'error');
                });
        }
    }

    function hideOrientationPermissionButton() {
        const button = document.getElementById('orientationPermissionBtn');
        if (button) {
            button.classList.remove('show');
            console.log('🧭 Orientation permission button hidden');
        }
    }

    // ========== PREMIUM GPS TRACKING SYSTEM ==========

    function updateUserLocation(position) {
        const { latitude, longitude, accuracy, speed } = position.coords;
        const timestamp = Date.now();
        
        console.log(`📍 Raw GPS: ${latitude.toFixed(6)}, ${longitude.toFixed(6)}, ±${accuracy.toFixed(1)}m`);
        
        // Validate coordinates
        if (!isValidCoordinate(latitude, longitude)) {
            console.error('❌ Invalid coordinates received:', latitude, longitude);
            return;
        }
        
        // Process location through premium filtering system
        const processedLocation = processLocationUpdate({
            lat: latitude,
            lng: longitude,
            accuracy: accuracy,
            speed: speed || 0,
            timestamp: timestamp
        });
        
        if (!processedLocation) {
            console.log('🚫 Location update filtered out');
            return;
        }
        
        // Update app state
        AppState.userLocation = [processedLocation.lat, processedLocation.lng];
        
        // Create or update marker
        if (!AppState.userMarker) {
            createPremiumLocationMarker(processedLocation);
        } else {
            updatePremiumLocationMarker(processedLocation);
        }
        
        // Check proximity in excavation mode
        if (AppState.excavationMode) {
            checkProximity();
        }
    }

    function processLocationUpdate(rawLocation) {
        const gps = AppState.gps;
        const now = rawLocation.timestamp;
        
        // First location - initialize system
        if (!gps.lastPosition) {
            gps.lastPosition = rawLocation;
            gps.filteredPosition = { ...rawLocation };
            gps.lastUpdateTime = now;
            gps.quality = getGPSQuality(rawLocation.accuracy);
            return gps.filteredPosition;
        }
        
        // Calculate time delta
        const timeDelta = (now - gps.lastUpdateTime) / 1000; // seconds
        if (timeDelta < 0.1) return null; // Too frequent, skip
        
        // Calculate movement
        const distance = haversineDistance(
            gps.lastPosition.lat, gps.lastPosition.lng,
            rawLocation.lat, rawLocation.lng
        );
        
        // Detect if we're actually moving
        gps.movementSpeed = distance / timeDelta;
        gps.isMoving = gps.movementSpeed > 0.5; // Moving faster than 0.5 m/s
        
        // Apply sophisticated filtering
        const filtered = applyLocationFilter(rawLocation, gps, timeDelta);
        
        // Update GPS state
        gps.lastPosition = rawLocation;
        gps.filteredPosition = filtered;
        gps.lastUpdateTime = now;
        gps.lastAccuracy = rawLocation.accuracy;
        gps.quality = getGPSQuality(rawLocation.accuracy);
        
        // Maintain position history for trend analysis
        gps.positionHistory.push({
            ...filtered,
            timestamp: now
        });
        
        // Keep only last 10 positions
        if (gps.positionHistory.length > 10) {
            gps.positionHistory.shift();
        }
        
        console.log(`✨ Filtered GPS: ${filtered.lat.toFixed(6)}, ${filtered.lng.toFixed(6)}, speed: ${gps.movementSpeed.toFixed(1)}m/s`);
        
        return filtered;
    }

    function applyLocationFilter(rawLocation, gps, timeDelta) {
        const lastFiltered = gps.filteredPosition;
        
        // If we haven't moved much and accuracy is poor, use more aggressive smoothing
        const accuracyFactor = Math.min(1, rawLocation.accuracy / 10);
        const movementFactor = Math.min(1, gps.movementSpeed / 2);
        
        // Adaptive smoothing based on movement and accuracy
        let smoothingFactor;
        if (gps.isMoving) {
            // When moving, be more responsive but still smooth
            smoothingFactor = 0.3 + (movementFactor * 0.4); // 0.3 to 0.7
        } else {
            // When stationary, apply heavy smoothing
            smoothingFactor = 0.1 + (accuracyFactor * 0.2); // 0.1 to 0.3
        }
        
        // Apply exponential smoothing
        const filtered = {
            lat: lastFiltered.lat + (rawLocation.lat - lastFiltered.lat) * smoothingFactor,
            lng: lastFiltered.lng + (rawLocation.lng - lastFiltered.lng) * smoothingFactor,
            accuracy: rawLocation.accuracy,
            speed: rawLocation.speed,
            timestamp: rawLocation.timestamp
        };
        
        return filtered;
    }

    function createPremiumLocationMarker(location) {
        console.log('🆕 Creating premium location marker');
        
            const userIcon = L.divIcon({
                className: 'user-location-marker',
                html: `
                <div class="location-container" data-gps-quality="${AppState.gps.quality}" data-moving="${AppState.gps.isMoving}">
                    <div class="location-signal"></div>
                    <div class="location-signal"></div>
                    <div class="location-signal"></div>
                        <div class="location-accuracy"></div>
                    <div class="location-arrow">
                        <div class="location-center"></div>
                        </div>
                    </div>
                `,
            iconSize: [56, 56],
            iconAnchor: [28, 28]
            });

        AppState.userMarker = L.marker([location.lat, location.lng], {
                icon: userIcon,
                zIndexOffset: 1000
            }).addTo(AppState.map);
        
        // Store the creation position to lock it in place
        AppState.userMarker._intendedLatLng = L.latLng(location.lat, location.lng);
        
        // Ensure marker element is always visible with comprehensive styling
        const markerElement = AppState.userMarker.getElement();
        if (markerElement) {
            markerElement.style.opacity = '1.0';
            markerElement.style.visibility = 'visible';
            markerElement.style.display = 'block';
            markerElement.style.zIndex = '1000';
            
            // Ensure all child elements are visible too
            const container = markerElement.querySelector('.location-container');
            if (container) {
                container.style.opacity = '1.0';
                container.style.visibility = 'visible';
            }
        }
        
                 // Apply initial scaling without timeout to prevent blinking
        const creationPosition = AppState.userMarker.getLatLng();
        const initialMarkerElement = AppState.userMarker.getElement();
        if (initialMarkerElement) {
            const zoom = AppState.map.getZoom();
            const scale = calculateUserLocationScale(zoom);
            initialMarkerElement.style.transform = `scale(${scale})`;
            initialMarkerElement.style.transformOrigin = 'center center';
            
            // Ensure visibility
            initialMarkerElement.style.opacity = '1.0';
            initialMarkerElement.style.visibility = 'visible';
            initialMarkerElement.style.display = 'block';
            initialMarkerElement.style.zIndex = '1000';
        }
        
        // Initialize direction indicator if orientation is available
        if (window.DeviceOrientationEvent) {
            setTimeout(() => {
                if (window.orientation !== undefined) {
                    updatePremiumDirectionIndicator(window.orientation);
                }
            }, 100);
        }
        
        console.log(`✅ Premium marker created at: ${location.lat.toFixed(6)}, ${location.lng.toFixed(6)}`);
    }

    function updatePremiumLocationMarker(location) {
        if (!AppState.userMarker) return;
        
        // Validate the new location before updating
        if (!location || !location.lat || !location.lng || 
            isNaN(location.lat) || isNaN(location.lng)) {
            console.warn('⚠️ Invalid location data, skipping marker update:', location);
            return;
        }
        
        // Get current position and new position
        const currentLatLng = AppState.userMarker.getLatLng();
        const newLatLng = L.latLng(location.lat, location.lng);
        
        // Calculate distance to see if we actually need to move the marker
        const distance = currentLatLng.distanceTo(newLatLng);
        
        // Only update position if the location has actually changed significantly (more than 1 meter)
        if (distance > 0.000009) { // approximately 1 meter
            console.log(`📍 Updating marker position: ${distance.toFixed(1)}m movement`);
            
            // Use smooth animation for significant position updates only
            animateMarkerToPosition(AppState.userMarker, currentLatLng, newLatLng, 800);
            
            // Store the intended position to prevent drift
            AppState.userMarker._intendedLatLng = newLatLng;
        } else {
            // Small movement - just ensure we're at the exact intended position without animation
            if (AppState.userMarker._intendedLatLng) {
                AppState.userMarker.setLatLng(AppState.userMarker._intendedLatLng);
            }
        }
        
        // Visual states are updated directly above to prevent conflicts
        
        // Update accuracy visualization
        updatePremiumAccuracyDisplay(location.accuracy);
    }

    function animateMarkerToPosition(marker, fromLatLng, toLatLng, duration) {
        const startTime = Date.now();
        const startLat = fromLatLng.lat;
        const startLng = fromLatLng.lng;
        const deltaLat = toLatLng.lat - startLat;
        const deltaLng = toLatLng.lng - startLng;
        
        console.log(`🎬 Animating marker from [${startLat.toFixed(6)}, ${startLng.toFixed(6)}] to [${toLatLng.lat.toFixed(6)}, ${toLatLng.lng.toFixed(6)}]`);
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Use easing function for smooth movement
            const eased = easeOutCubic(progress);
            
            const currentLat = startLat + (deltaLat * eased);
            const currentLng = startLng + (deltaLng * eased);
            
            marker.setLatLng([currentLat, currentLng]);
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - ensure we're at the exact final position
                marker.setLatLng(toLatLng);
                console.log(`✅ Animation complete - final position: [${toLatLng.lat.toFixed(6)}, ${toLatLng.lng.toFixed(6)}]`);
                
                // Double-check the position is exactly what we intended
                const finalPosition = marker.getLatLng();
                if (finalPosition.distanceTo(toLatLng) > 0.000001) {
                    console.warn('⚠️ Animation ended at wrong position, correcting...');
                    marker.setLatLng(toLatLng);
                }
            }
        }
        
        requestAnimationFrame(animate);
    }

    function updatePremiumDirectionIndicator(heading) {
        if (heading === null || heading === undefined || isNaN(heading)) {
            console.log('🧭 Invalid heading received:', heading);
            return;
        }
        
        // Normalize heading to 0-360 range
        const normalizedHeading = ((heading % 360) + 360) % 360;
        
        console.log(`🧭 Normalized heading: ${normalizedHeading.toFixed(1)}°`);
        
        // Apply sophisticated heading filtering
        const filteredHeading = filterHeading(normalizedHeading);
        
        if (filteredHeading === null) {
            console.log('🧭 Heading filtered out');
            return;
        }
        
        console.log(`🧭 Smooth heading: ${filteredHeading.toFixed(1)}°`);
        
        // Apply smooth rotation
        if (AppState.userMarker) {
            const markerElement = AppState.userMarker.getElement();
            if (markerElement) {
                const arrow = markerElement.querySelector('.location-arrow');
                if (arrow) {
                    // Use CSS transform for smooth rotation
                    arrow.style.transform = `rotate(${filteredHeading}deg)`;
                    arrow.style.transition = 'transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    console.log(`🧭 Arrow rotated to ${filteredHeading.toFixed(1)}°`);
                } else {
                    console.log('🧭 Arrow element not found');
                }
                
                const container = markerElement.querySelector('.location-container');
                if (container) {
                    container.setAttribute('data-heading', filteredHeading.toFixed(0));
                }
            } else {
                console.log('🧭 Marker element not found');
            }
        } else {
            console.log('🧭 User marker not found');
        }
    }

    function filterHeading(rawHeading) {
        const gps = AppState.gps;
        
        // Initialize heading history
        if (!gps.lastHeading) {
            gps.lastHeading = rawHeading;
            gps.filteredHeading = rawHeading;
            gps.headingHistory = [rawHeading];
            return rawHeading;
        }
        
        // Add to history
        gps.headingHistory.push(rawHeading);
        if (gps.headingHistory.length > 5) {
            gps.headingHistory.shift();
        }
        
        // Calculate heading difference (accounting for 360° wrap)
        const diff = ((rawHeading - gps.lastHeading + 540) % 360) - 180;
        
        // Apply different filtering based on movement
        let smoothingFactor;
        if (gps.isMoving) {
            // More responsive when moving
            smoothingFactor = Math.abs(diff) > 45 ? 0.7 : 0.4;
        } else {
            // Heavy smoothing when stationary
            smoothingFactor = Math.abs(diff) > 90 ? 0.3 : 0.1;
        }
        
        // Apply exponential smoothing with wrap-around handling
        let filteredHeading = gps.filteredHeading + (diff * smoothingFactor);
        filteredHeading = ((filteredHeading % 360) + 360) % 360;
        
        gps.lastHeading = rawHeading;
        gps.filteredHeading = filteredHeading;
        
        return filteredHeading;
    }

    function updatePremiumAccuracyDisplay(accuracy) {
        const accuracyElement = document.querySelector('.location-accuracy');
        if (!accuracyElement || !accuracy) return;
        
        // Sophisticated accuracy scaling
        const minScale = 0.4;
        const maxScale = 2.5;
        const scale = Math.min(maxScale, Math.max(minScale, accuracy / 8));
        
        // Smooth scale transition
            accuracyElement.style.transform = `scale(${scale})`;
        
        // Update opacity based on confidence
        const confidence = Math.max(0.2, Math.min(1, 1 - (accuracy / 30)));
        accuracyElement.style.opacity = confidence.toString();
    }

    function applyPremiumLocationTransform() {
        if (!AppState.userMarker) return;
        
        // ONLY apply visual transforms - NEVER touch position
        updateLocationMarkerVisuals();
    }

    function updateLocationMarkerVisuals() {
        if (!AppState.userMarker) return;
        
        const zoom = AppState.map.getZoom();
        const scale = calculateUserLocationScale(zoom);
        const markerElement = AppState.userMarker.getElement();
        
        if (markerElement) {
            // Store current position to prevent any accidental changes
            const currentPosition = AppState.userMarker.getLatLng();
            
            // Apply ONLY visual styling - no position changes
            markerElement.style.transform = `scale(${scale})`;
            markerElement.style.transformOrigin = 'center center';
            markerElement.style.opacity = '1.0'; // Always fully visible
            markerElement.style.visibility = 'visible'; // Force visibility
            markerElement.style.display = 'block'; // Ensure it's displayed
            markerElement.style.zIndex = '1000'; // Always on top
            
            // Ensure all child elements are also visible
            const container = markerElement.querySelector('.location-container');
            if (container) {
                container.setAttribute('data-gps-quality', AppState.gps.quality);
                container.setAttribute('data-moving', AppState.gps.isMoving.toString());
                container.style.opacity = '1.0';
                container.style.visibility = 'visible';
            }
            
            // Verify position hasn't changed accidentally
            const afterPosition = AppState.userMarker.getLatLng();
            if (currentPosition.distanceTo(afterPosition) > 0.000001) {
                console.warn('⚠️ Marker position changed during visual update, restoring...');
                AppState.userMarker.setLatLng(currentPosition);
            }
            
            console.log(`📍 Location marker visuals updated: zoom=${zoom}, scale=${scale}`);
        }
    }

    // Fixed scaling function for user location marker - NO ZOOM SCALING
    function calculateUserLocationScale(zoom) {
        // Always return 1.0 - location icon should never change size
        return 1.0;
    }

    // ========== UTILITY FUNCTIONS ==========

    function getGPSQuality(accuracy) {
        if (accuracy <= 3) return 'excellent';
        if (accuracy <= 8) return 'good';
        if (accuracy <= 20) return 'fair';
        return 'poor';
    }

    function haversineDistance(lat1, lng1, lat2, lng2) {
        const R = 6371000; // Earth's radius in meters
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const Δφ = (lat2 - lat1) * Math.PI / 180;
        const Δλ = (lng2 - lng1) * Math.PI / 180;

        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
    }

    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }

    function isValidCoordinate(lat, lng) {
        return !isNaN(lat) && !isNaN(lng) && 
               lat >= -90 && lat <= 90 && 
               lng >= -180 && lng <= 180 &&
               (lat !== 0 || lng !== 0); // Reject null island
    }

    async function centerOnLocation() {
        if (AppState.userLocation) {
            AppState.map.setView(AppState.userLocation, 18);
            showToast('Centered on your location', 'info');
            hapticFeedback(50);
        } else {
            showToast('Location not available', 'error');
        }
    }

    // Drawing functions
    function startDrawing() {
        if (AppState.measureMode) {
            toggleMeasureMode(null);
        }
        
        // Cancel structure placement if active
        if (AppState.addingStructure) {
            cancelStructurePlacement();
        }
        
        AppState.isDrawing = true;
        AppState.drawingPoints = [];
        document.getElementById('drawingUI').classList.add('active');
        document.getElementById('drawBtn').classList.add('active');
        updateDrawingStatus();
        hapticFeedback(50);
    }

    function handleMapClick(e) {
        if (AppState.isDrawing) {
            addDrawingPoint(e.latlng);
        } else if (AppState.refineMode) {
            // Ignore map clicks during refine mode - only marker dragging allowed
            return;
        } else if (AppState.addingStructure) {
            addStructure(e.latlng);
        } else if (AppState.measureMode) {
            addMeasurePoint(e.latlng);
        }
    }

    // Enhanced zoom-based visibility and scaling system
    function handleZoomChange() {
        const currentZoom = AppState.map.getZoom();
        const opacity = calculateZoomOpacity(currentZoom);
        const userScale = calculateZoomScale(currentZoom);
        const lineScale = calculateUtilityLineScale(currentZoom);
        
        console.log(`🔍 Zoom: ${currentZoom}, Opacity: ${opacity.toFixed(2)}, Line Scale: ${lineScale.toFixed(2)}`);
        
        // Apply to all utility lines with inverse scaling (thinner when zoomed out)
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                // Don't fade if currently highlighted/selected, in refine mode, or in excavation mode
                const isHighlighted = utility.lineLayer.options.className && 
                                    utility.lineLayer.options.className.includes('highlighted');
                const isBeingRefined = AppState.refineMode && 
                                     AppState.selectedUtilityData && 
                                     utility.id === AppState.selectedUtilityData.id;
                const isExcavationMode = AppState.excavationMode;
                const finalOpacity = (isHighlighted || isBeingRefined || isExcavationMode) ? 1.0 : opacity;
                
                // Keep consistent fixed weight regardless of zoom
                const fixedWeight = utility.lineType === 'main' ? 4 : 3;
                
                utility.lineLayer.setStyle({ 
                    opacity: finalOpacity,
                    weight: fixedWeight // No more zoom scaling
                });
                
                // Keep touch target at fixed size
                if (utility.touchTarget) {
                    utility.touchTarget.setStyle({ 
                        weight: 50, // Fixed large touch area
                        opacity: 0 // Always invisible
                    });
                }
                
                // Apply to connection markers
                if (utility.connectionMarkers) {
                    utility.connectionMarkers.forEach(marker => {
                        if (marker._icon) {
                            marker._icon.style.opacity = finalOpacity;
                        }
                    });
                }
            }
        });
        
        // Apply to all structure markers
        AppState.structures.forEach(structure => {
            if (structure.marker && structure.marker._icon) {
                const finalOpacity = AppState.excavationMode ? 1.0 : opacity;
                structure.marker._icon.style.opacity = finalOpacity;
            }
        });
        
        // Scale user location marker with premium transforms (always visible)
        if (AppState.userMarker) {
            // Store position before any operations
            const lockedPosition = AppState.userMarker.getLatLng();
            
            // Apply visual-only transforms without timeout delays that cause blinking
            const markerElement = AppState.userMarker.getElement();
            if (markerElement) {
                // Apply scaling based on zoom
                const scale = calculateUserLocationScale(currentZoom);
                markerElement.style.transform = `scale(${scale})`;
                markerElement.style.transformOrigin = 'center center';
                
                // Ensure full visibility - user location is ALWAYS visible
                markerElement.style.opacity = '1.0';
                markerElement.style.visibility = 'visible';
                markerElement.style.display = 'block';
                markerElement.style.zIndex = '1000';
                
                // Ensure container is also visible
                const container = markerElement.querySelector('.location-container');
                if (container) {
                    container.style.opacity = '1.0';
                    container.style.visibility = 'visible';
                    container.style.display = 'flex';
                }
            }
            
            // Ensure position hasn't drifted during zoom operations
            const currentPosition = AppState.userMarker.getLatLng();
            if (lockedPosition.distanceTo(currentPosition) > 0.000001) {
                console.warn('⚠️ Marker position drifted during zoom, restoring...');
                AppState.userMarker.setLatLng(lockedPosition);
            }
        }
        
        // Ensure refine markers are always fully visible
        if (AppState.refineMode && AppState.refineMarkers) {
            AppState.refineMarkers.forEach(marker => {
                if (marker._icon) {
                    marker._icon.style.opacity = 1.0;
                }
            });
        }
    }

    function calculateZoomOpacity(zoom) {
        // VERY AGGRESSIVE zoom-based fading:
        // 20+ (max zoom): 1.0 (fully visible)
        // 18-19 (street level): 0.7 (noticeable fade starts early)
        // 16-17 (building level): 0.4 (heavy fade)
        // 14-15 (block level): 0.15 (barely visible)
        // <14 (neighborhood+): 0.02 (almost invisible)
        
        if (zoom >= 20) {
            return 1.0; // Full visibility only at maximum zoom
        } else if (zoom >= 18) {
            return 0.7; // Start fading aggressively at street level
        } else if (zoom >= 16) {
            return 0.4; // Heavy fade at building level
        } else if (zoom >= 14) {
            return 0.15; // Barely visible at block level
        } else {
            return 0.02; // Almost completely invisible below zoom 14
        }
    }

    // Zoom-based scaling calculation for user location marker
    function calculateZoomScale(zoom) {
        // Responsive scaling - smaller at low zoom, larger at high zoom
        if (zoom >= 18) return 1.0;     // Full size at close zoom
        if (zoom >= 16) return 0.8;     // 80% size
        if (zoom >= 14) return 0.6;     // 60% size
        if (zoom >= 12) return 0.4;     // 40% size
        if (zoom >= 10) return 0.3;     // 30% size
        return 0.2;                     // 20% size at far zoom
    }

    // Utility line thickness scaling - thinner when zoomed out for cleaner appearance
    function calculateUtilityLineScale(zoom) {
        // Inverse scaling for utility lines - thinner at low zoom to reduce clutter
        if (zoom >= 20) return 1.0;     // Full thickness at max zoom
        if (zoom >= 18) return 0.9;     // Slightly thinner
        if (zoom >= 16) return 0.7;     // 70% thickness
        if (zoom >= 14) return 0.5;     // 50% thickness
        if (zoom >= 12) return 0.4;     // 40% thickness
        if (zoom >= 10) return 0.3;     // 30% thickness
        return 0.25;                    // Very thin at far zoom to prevent clutter
    }

    function addDrawingPoint(latlng) {
        AppState.drawingPoints.push(latlng);
        updateDrawingStatus();
        updateTempLine();
        hapticFeedback(30);

        // Check for nearby connections
        if (AppState.drawingPoints.length >= 1) {
            checkForNearbyConnections(latlng);
        }

        // Add a temporary marker for visual feedback
        const tempMarker = L.circleMarker(latlng, {
            radius: 6,
            fillColor: getUtilityColor(AppState.selectedUtility),
            fillOpacity: 1,
            color: 'white',
            weight: 2
        }).addTo(AppState.map);

        setTimeout(() => {
            AppState.map.removeLayer(tempMarker);
        }, 1000);
    }

    function updateDrawingStatus() {
        const status = document.getElementById('drawingStatus');
        const finishBtn = document.getElementById('finishDrawBtn');
        
        if (AppState.drawingPoints.length === 0) {
            status.textContent = 'Click points on the map';
            finishBtn.style.display = 'none';
        } else if (AppState.drawingPoints.length === 1) {
            status.textContent = 'Click to add more points';
            finishBtn.style.display = 'none';
        } else {
            status.textContent = `${AppState.drawingPoints.length} points added`;
            finishBtn.style.display = 'block';
        }
    }

    function updateTempLine() {
        if (AppState.tempLine) {
            AppState.map.removeLayer(AppState.tempLine);
        }

        if (AppState.drawingPoints.length > 1) {
            // Use consistent fixed weight
            const fixedWeight = AppState.lineType === 'main' ? 4 : 3;
            
            AppState.tempLine = L.polyline(AppState.drawingPoints, {
                color: getUtilityColor(AppState.selectedUtility),
                weight: fixedWeight,
                opacity: 1.0, // Always fully visible during drawing
                dashArray: AppState.lineType === 'service' ? '8, 4' : null,
                className: 'utility-line drawing'
            }).addTo(AppState.map);
        }
    }

    function checkForNearbyConnections(currentPoint) {
        const threshold = 0.00009; // Approximately 10 meters
        AppState.connectionCandidate = null;

        // Check for nearby utilities of the same type
        AppState.utilities.forEach(utility => {
            if (utility.type === AppState.selectedUtility) {
                // For service lines, check if we can connect to a main
                if (AppState.lineType === 'service' && utility.lineType === 'main') {
                    // Check distance to any point on the main line
                    const closestPoint = getClosestPointOnLine(currentPoint, utility.points);
                    if (closestPoint.distance < threshold) {
                        AppState.connectionCandidate = {
                            utility: utility,
                            point: closestPoint.point,
                            type: 'main-to-service'
                        };
                    }
                } else if (utility.lineType === AppState.lineType) {
                    // Same line type - check endpoints only
                    const startPoint = utility.points[0];
                    const endPoint = utility.points[utility.points.length - 1];

                    if (getDistance(currentPoint, startPoint) < threshold) {
                        AppState.connectionCandidate = {
                            utility: utility,
                            point: startPoint,
                            type: 'endpoint'
                        };
                    } else if (getDistance(currentPoint, endPoint) < threshold) {
                        AppState.connectionCandidate = {
                            utility: utility,
                            point: endPoint,
                            type: 'endpoint'
                        };
                    }
                }
            }
        });

        // Check for nearby structures
        AppState.structures.forEach(structure => {
            if (structure.utilityType === AppState.selectedUtility) {
                if (getDistance(currentPoint, structure.latlng) < threshold) {
                    AppState.connectionCandidate = {
                        structure: structure,
                        point: structure.latlng,
                        type: 'structure'
                    };
                }
            }
        });
    }

    function getClosestPointOnLine(point, linePoints) {
        let minDistance = Infinity;
        let closestPoint = null;

        for (let i = 0; i < linePoints.length - 1; i++) {
            const projectedPoint = projectPointOnSegment(point, linePoints[i], linePoints[i + 1]);
            const distance = getDistance(point, projectedPoint);
            
            if (distance < minDistance) {
                minDistance = distance;
                closestPoint = projectedPoint;
            }
        }

        return { point: closestPoint, distance: minDistance };
    }

    function projectPointOnSegment(point, segStart, segEnd) {
        const A = point.lat - segStart.lat;
        const B = point.lng - segStart.lng;
        const C = segEnd.lat - segStart.lat;
        const D = segEnd.lng - segStart.lng;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
            param = dot / lenSq;
        }

        let lat, lng;

        if (param < 0) {
            lat = segStart.lat;
            lng = segStart.lng;
        } else if (param > 1) {
            lat = segEnd.lat;
            lng = segEnd.lng;
        } else {
            lat = segStart.lat + param * C;
            lng = segStart.lng + param * D;
        }

        return L.latLng(lat, lng);
    }

    function getDistance(point1, point2) {
        const lat1 = point1.lat || point1[0];
        const lng1 = point1.lng || point1[1];
        const lat2 = point2.lat || point2[0];
        const lng2 = point2.lng || point2[1];
        
        return Math.sqrt(Math.pow(lat2 - lat1, 2) + Math.pow(lng2 - lng1, 2));
    }

    function showConnectionDialog() {
        const dialog = document.getElementById('connectionDialog');
        dialog.classList.add('active');
        hapticFeedback(50);
    }

    function closeConnectionDialog(connect) {
        const dialog = document.getElementById('connectionDialog');
        dialog.classList.remove('active');
        
        if (connect && AppState.connectionCandidate) {
            // Snap to connection point
            const lastIndex = AppState.drawingPoints.length - 1;
            AppState.drawingPoints[lastIndex] = AppState.connectionCandidate.point;
            updateTempLine();
            hapticFeedback(30);
            
            // Finish drawing immediately after connecting
            finishDrawingWithConnection();
        }
        
        // Clear connection candidate
        AppState.connectionCandidate = null;
    }
    
    function finishDrawingWithConnection() {
        if (AppState.drawingPoints.length < 2) {
            showToast('Need at least 2 points', 'warning');
            return;
        }

        // Create utility data
        const utilityData = {
            id: generateId(),
            type: AppState.selectedUtility,
            lineType: AppState.lineType,
            points: [...AppState.drawingPoints],
            size: '',
            depth: '',
            material: '',
            condition: '',
            curbDistance: '',
            dateAdded: new Date().toISOString(),
            connections: [],
            notes: []
        };

        // Add connection info if connected
        if (AppState.connectionCandidate) {
            utilityData.connections.push({
                type: AppState.connectionCandidate.type,
                targetId: AppState.connectionCandidate.utility?.id || AppState.connectionCandidate.structure?.id,
                point: AppState.connectionCandidate.point
            });
        }

        // Add utility to state
        AppState.utilities.push(utilityData);

        // Create the utility line on map
        createUtilityLine(utilityData);

        // Save
        saveUtilities();

        // Show info modal for editing
        showInfoModal(utilityData);

        // Reset drawing state
        cancelDrawing();

        showToast('Utility line connected and added', 'success');
        hapticFeedback(100);
    }

    function finishDrawing() {
        if (AppState.drawingPoints.length < 2) {
            showToast('Need at least 2 points', 'warning');
            return;
        }

        // Check if we should show connection dialog
        if (AppState.connectionCandidate && AppState.drawingPoints.length > 0) {
            showConnectionDialog();
            return;
        }

        // Create utility data - save directly without approval
        const utilityData = {
            id: generateId(),
            type: AppState.selectedUtility,
            lineType: AppState.lineType,
            points: [...AppState.drawingPoints],
            size: '',
            depth: '',
            material: '',
            condition: '',
            curbDistance: '',
            dateAdded: new Date().toISOString(),
            connections: [],
            notes: [],
            isModified: true // Mark for saving
        };

        // Add connection info if connected
        if (AppState.connectionCandidate) {
            utilityData.connections.push({
                type: AppState.connectionCandidate.type,
                targetId: AppState.connectionCandidate.utility?.id || AppState.connectionCandidate.structure?.id,
                point: AppState.connectionCandidate.point
            });
        }

        // Add utility to state
        AppState.utilities.push(utilityData);

        // Create the utility line on map
        createUtilityLine(utilityData);

        // Save directly to Firestore
        saveUtilities();

        // Show info modal for editing
        showInfoModal(utilityData);

        // Reset drawing state
        cancelDrawing();

        hapticFeedback(100);
    }

    function cancelDrawing() {
        AppState.isDrawing = false;
        AppState.drawingPoints = [];
        AppState.connectionCandidate = null;
        
        if (AppState.tempLine) {
            AppState.map.removeLayer(AppState.tempLine);
            AppState.tempLine = null;
        }

        document.getElementById('drawingUI').classList.remove('active');
        document.getElementById('drawBtn').classList.remove('active');
    }

    function createUtilityLine(utilityData) {
        // Use consistent fixed weights regardless of zoom
        const baseWeight = utilityData.lineType === 'main' ? 4 : 3; // Made thinner
        
        // Create visible line with fixed size
        const line = L.polyline(utilityData.points, {
            color: getUtilityColor(utilityData.type),
            weight: baseWeight,
            opacity: 1,
            dashArray: utilityData.lineType === 'service' ? '8, 4' : null, // Smaller dash pattern
            className: `utility-line ${utilityData.type} ${utilityData.lineType}`,
            interactive: true  // Make visual line interactive again for better touch handling
        });
        
        // Create invisible larger touch target for easier selection
        const touchTarget = L.polyline(utilityData.points, {
            color: 'transparent',
            weight: 50, // Large fixed touch area
            opacity: 0,
            interactive: true,
            className: `utility-touch-target ${utilityData.type} ${utilityData.lineType}`,
            pane: 'overlayPane' // Ensure it's on top
        });

        // Enhanced mobile-first interaction handling
        let pressTimer;
        let longPress = false;
        let startTime = 0;
        let lastClickTime = 0;
        let startPos = null;
        let hasMoved = false;
        
        const startPress = (e) => {
            if (AppState.isDrawing || AppState.refineMode || AppState.addingStructure || AppState.measureMode) {
                return; // Don't interfere with other modes
            }
            
            // Add this at the beginning - Exit early for multi-touch
            if (e.touches && e.touches.length > 1) {
                return; // Always allow pinch zoom gestures
            }
            
            // Prevent default for ALL events, not just non-map ones
            if (e.cancelable) {
                e.preventDefault();
            }
            e.stopPropagation();
            
            longPress = false;
            hasMoved = false;
            startTime = Date.now();
            
            // Enhanced touch position detection
            let clientX, clientY;
            
            if (e.type === 'touchstart') {
                // Try multiple ways to get touch coordinates
                if (e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0]) {
                    clientX = e.originalEvent.touches[0].clientX;
                    clientY = e.originalEvent.touches[0].clientY;
                } else if (e.touches && e.touches[0]) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.originalEvent && e.originalEvent.clientX !== undefined) {
                    clientX = e.originalEvent.clientX;
                    clientY = e.originalEvent.clientY;
                } else {
                    // Fallback to container point
                    const point = e.containerPoint || e.layerPoint;
                    if (point) {
                        clientX = point.x;
                        clientY = point.y;
                    } else {
                        console.warn('Could not determine touch position');
                        return;
                    }
                }
            } else {
                // Mouse event
                clientX = e.originalEvent ? e.originalEvent.clientX : e.clientX;
                clientY = e.originalEvent ? e.originalEvent.clientY : e.clientY;
            }
            
            startPos = { x: clientX, y: clientY };
            
            console.log('🎯 Touch start detected on utility line', {
                type: e.type,
                position: startPos,
                utilityId: utilityData.id
            });
            
            // Start long press timer (shorter for better mobile UX)
            pressTimer = setTimeout(() => {
                if (!hasMoved) {
                    console.log('✅ Long press triggered!');
                    longPress = true;
                    hapticFeedback(100);
                    showInfoModal(utilityData);
                }
            }, 280); // Reduced to 280ms for even faster response
            
            // Highlight line on press with stronger visual feedback
            line.setStyle({
                weight: (utilityData.lineType === 'main' ? 4 : 3) + 2, // Slightly thicker
                opacity: 1.0,
                className: `utility-line ${utilityData.type} ${utilityData.lineType} pressing`
            });
            
            // Add temporary glow effect
            if (line.getElement()) {
                line.getElement().style.filter = 'drop-shadow(0 0 15px currentColor)';
            }
        };
        
        const movePress = (e) => {
            if (!startPos) return;
            
            // Enhanced touch position detection for move events
            let clientX, clientY;
            
            if (e.type === 'touchmove') {
                if (e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0]) {
                    clientX = e.originalEvent.touches[0].clientX;
                    clientY = e.originalEvent.touches[0].clientY;
                } else if (e.touches && e.touches[0]) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.originalEvent && e.originalEvent.clientX !== undefined) {
                    clientX = e.originalEvent.clientX;
                    clientY = e.originalEvent.clientY;
                } else {
                    const point = e.containerPoint || e.layerPoint;
                    if (point) {
                        clientX = point.x;
                        clientY = point.y;
                    } else {
                        return;
                    }
                }
            } else {
                clientX = e.originalEvent ? e.originalEvent.clientX : e.clientX;
                clientY = e.originalEvent ? e.originalEvent.clientY : e.clientY;
            }
            
            const currentPos = { x: clientX, y: clientY };
            
            // Check if moved more than 40px (even more forgiving for touch)
            const distance = Math.sqrt(
                Math.pow(currentPos.x - startPos.x, 2) + 
                Math.pow(currentPos.y - startPos.y, 2)
            );
            
            if (distance > 40) { // Increased to 40px for very forgiving touch detection
                console.log('🔄 Movement detected, cancelling long press', { distance });
                hasMoved = true;
                clearTimeout(pressTimer);
            }
        };
        
        const endPress = (e) => {
            const pressDuration = Date.now() - startTime;
            
            console.log('🔚 Touch end detected', {
                type: e.type,
                duration: pressDuration,
                longPress,
                hasMoved,
                utilityId: utilityData.id
            });
            
            clearTimeout(pressTimer);
            
            // Reset line style to fixed weight
            const fixedWeight = utilityData.lineType === 'main' ? 4 : 3;
            
            line.setStyle({
                weight: fixedWeight,
                opacity: 1,
                className: `utility-line ${utilityData.type} ${utilityData.lineType}`
            });
            
            // Remove glow effect
            if (line.getElement()) {
                line.getElement().style.filter = '';
            }
            
            // Show quick info on short press without movement (if not a long press)
            if (!longPress && !hasMoved && pressDuration < 250 && pressDuration > 50) {
                const utilityName = `${capitalizeFirst(utilityData.type)} ${capitalizeFirst(utilityData.lineType)}`;
                const info = utilityData.size ? ` (${utilityData.size}")` : '';
                showToast(`${utilityName}${info} - Hold to edit`, 'info');
                hapticFeedback(30);
            }
            
            // Reset state
            startPos = null;
            hasMoved = false;
        };

        // Enhanced event handling for mobile - bind to both visual line and touch target
        const bindEventsToElement = (element, elementName) => {
            element.on('mousedown', startPress);
            element.on('touchstart', startPress);
            element.on('mousemove', movePress);
            element.on('touchmove', movePress);
            element.on('mouseup', endPress);
            element.on('touchend', endPress);
            element.on('mouseleave', endPress);
            element.on('touchcancel', endPress);
            
            element.on('click', (e) => {
                // Handle double-tap to open modal (alternative to long press)
                const now = Date.now();
                if (now - lastClickTime < 400) {
                    // Double tap detected (more responsive timing)
                    if (!AppState.isDrawing && !AppState.refineMode && !AppState.addingStructure && !AppState.measureMode) {
                        console.log(`🎯 Double tap detected on ${elementName} for utility:`, utilityData.id);
                        showInfoModal(utilityData);
                        hapticFeedback(50);
                    }
                }
                lastClickTime = now;
            });
            
            console.log(`📱 Touch events bound to ${elementName} for utility:`, utilityData.id);
        };
        
        // Bind events to both elements for better touch coverage
        bindEventsToElement(line, 'visual line');
        bindEventsToElement(touchTarget, 'touch target');

        // Store references
        utilityData.lineLayer = line;
        utilityData.touchTarget = touchTarget;

        // Add both to appropriate layer
        line.addTo(AppState.layers.utilities[utilityData.type]);
        touchTarget.addTo(AppState.layers.utilities[utilityData.type]);

        // Apply current zoom-based opacity to visible line only
        const currentZoom = AppState.map.getZoom();
        const opacity = calculateZoomOpacity(currentZoom);
        line.setStyle({ opacity: opacity });
        
        // Keep touch target at fixed large size
        touchTarget.setStyle({ weight: 50, opacity: 0 });
        
        console.log(`✅ Utility line created with touch events:`, {
            id: utilityData.id,
            type: utilityData.type,
            lineType: utilityData.lineType,
            visualWeight: baseWeight,
            touchWeight: 50,
            eventsReady: true
        });

        // Enhanced connection markers with animations
        if (utilityData.connections && utilityData.connections.length > 0) {
            utilityData.connections.forEach((conn, index) => {
                let markerClass = 'connection-marker';
                let radius = 8;
                let fillColor = 'white';
                
                if (conn.type === 'main-to-service') {
                    markerClass += ' t-junction';
                    radius = 10;
                    fillColor = '#f0f8ff';
                } else if (conn.type === 'endpoint') {
                    markerClass += ' endpoint';
                    radius = 8;
                    fillColor = '#fff5f5';
                } else if (conn.type === 'structure') {
                    markerClass += ' structure';
                    radius = 12;
                    fillColor = '#f0fff0';
                }
                
                const marker = L.circleMarker(conn.point, {
                    radius: radius,
                    fillColor: fillColor,
                    color: getUtilityColor(utilityData.type),
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 1,
                    className: `${markerClass} ${utilityData.type}`
                });
                
                // Add subtle animation delay for visual effect
                setTimeout(() => {
                marker.addTo(AppState.layers.utilities[utilityData.type]);
                }, index * 100);
                
                // Store connection marker reference
                if (!utilityData.connectionMarkers) {
                    utilityData.connectionMarkers = [];
                }
                utilityData.connectionMarkers.push(marker);
            });
        }
    }

    function getUtilityColor(type) {
        const colors = {
            water: '#00b4d8',
            gas: '#ffd60a',
            electric: '#ff006e',
            sewer: '#a8763e',
            telecom: '#b565d8'
        };
        return colors[type] || '#000000';
    }

    // Structure functions
    function toggleStructureMenu() {
        // If currently placing a structure, cancel it
        if (AppState.addingStructure) {
            cancelStructurePlacement();
            return;
        }
        
        const menu = document.getElementById('structureMenu');
        if (!menu) {
            console.error('❌ Structure menu element not found!');
            showToast('Structure menu not found', 'error');
            return;
        }
        
        const isActive = menu.classList.contains('active');
        
        if (isActive) {
            menu.classList.remove('active');
            console.log('📋 Structure menu closed');
        } else {
            menu.classList.add('active');
            console.log('📋 Structure menu opened, checking visibility...');
            
            // Debug menu visibility
            setTimeout(() => {
                const computedStyle = window.getComputedStyle(menu);
                console.log('Menu display:', computedStyle.display);
                console.log('Menu visibility:', computedStyle.visibility);
                console.log('Menu z-index:', computedStyle.zIndex);
                console.log('Menu position:', {
                    bottom: computedStyle.bottom,
                    right: computedStyle.right,
                    width: computedStyle.width,
                    height: computedStyle.height
                });
            }, 100);
            
            showToast('👆 Structure menu opened above green button', 'info');
        }
        
        hapticFeedback(30);
    }

    function startAddingStructure(structureType, utilityType) {
        console.log('🏗️ Starting to add structure:', { structureType, utilityType });
        
        AppState.addingStructure = true;
        AppState.structureToAdd = {
            type: structureType,
            utilityType: utilityType
        };
        
        // Close menu
        document.getElementById('structureMenu').classList.remove('active');
        
        // Add visual feedback to structure button
        document.getElementById('addStructureBtn').classList.add('active');
        
        // Change cursor to crosshair for better UX
        document.getElementById('map').style.cursor = 'crosshair';
        
        showToast(`Tap on map to place ${getStructureName(structureType)}`, 'success');
        hapticFeedback(50);
    }
    
    function getStructureName(structureType) {
        const names = {
            electricBox: 'Electric Box',
            catchBasin: 'Catch Basin',
            sewerManhole: 'Sewer Manhole',
            waterManhole: 'Water Manhole',
            gasManhole: 'Gas Manhole',
            gasValve: 'Gas Valve',
            hydrantValve: 'Hydrant',
            telecomBox: 'Telecom Box'
        };
        return names[structureType] || structureType;
    }

    function addStructure(latlng) {
        if (!AppState.structureToAdd) {
            console.warn('⚠️ No structure to add');
            return;
        }

        console.log('🏗️ Adding structure at:', latlng);

        const structureData = {
            id: generateId(),
            type: AppState.structureToAdd.type,
            utilityType: AppState.structureToAdd.utilityType,
            latlng: latlng,
            dateAdded: new Date().toISOString(),
            isModified: true // Mark for saving
        };

        // Add to state
        AppState.structures.push(structureData);

        // Create marker
        createStructureMarker(structureData);

        // Save directly to Firestore
        saveStructures();

        // Reset cursor and state
        document.getElementById('map').style.cursor = '';
        document.getElementById('addStructureBtn').classList.remove('active');
        AppState.addingStructure = false;
        AppState.structureToAdd = null;

        const structureName = getStructureName(structureData.type);
        showToast(`${structureName} created successfully`, 'success');
        hapticFeedback(100);
        
        console.log('✅ Structure submitted for approval:', structureData);
    }
    
    function cancelStructurePlacement() {
        if (AppState.addingStructure) {
            console.log('❌ Cancelling structure placement');
            
            // Reset cursor and state
            document.getElementById('map').style.cursor = '';
            document.getElementById('addStructureBtn').classList.remove('active');
            AppState.addingStructure = false;
            AppState.structureToAdd = null;
            
            // Close menu if open
            document.getElementById('structureMenu').classList.remove('active');
            
            showToast('Structure placement cancelled', 'info');
            hapticFeedback(30);
        }
    }

    function createStructureMarker(structureData) {
        const icons = {
            electricBox: 'fa-bolt',
            catchBasin: 'fa-water',
            sewerManhole: 'fa-circle',
            waterManhole: 'fa-tint',
            gasManhole: 'fa-fire',
            gasValve: 'fa-wrench',
            hydrantValve: 'fa-fire-extinguisher',
            telecomBox: 'fa-network-wired'
        };

        const icon = L.divIcon({
            className: '',
            html: `<div class="structure-marker ${structureData.utilityType}">
                <i class="fas ${icons[structureData.type]}"></i>
            </div>`,
            iconSize: [48, 48],
            iconAnchor: [24, 24]
        });

        const marker = L.marker(structureData.latlng, { icon: icon });
        
        // Add click handler
        marker.on('click', () => {
            showStructureInfo(structureData);
        });

        // Store reference
        structureData.marker = marker;

        // Add to layer
        marker.addTo(AppState.layers.structures[structureData.utilityType]);

        // Apply current zoom-based opacity
        const currentZoom = AppState.map.getZoom();
        const opacity = calculateZoomOpacity(currentZoom);
        if (marker._icon) {
            marker._icon.style.opacity = opacity;
        }
    }

    function showStructureInfo(structureData) {
        const structureNames = {
            electricBox: 'Electrical Box',
            catchBasin: 'Catch Basin',
            sewerManhole: 'Sewer Manhole',
            waterManhole: 'Water Manhole',
            gasManhole: 'Gas Manhole',
            gasValve: 'Gas Valve',
            hydrantValve: 'Hydrant Valve',
            telecomBox: 'Telecom Box'
        };

        showToast(`${structureNames[structureData.type]}`, 'info');
    }

    // Info Modal functions
    function showInfoModal(utilityData) {
        console.log('📋 Opening info modal for utility:', utilityData?.id);
        AppState.selectedUtilityData = utilityData;
        
        // Update modal content
        document.getElementById('modalIcon').className = getUtilityIcon(utilityData.type);
        document.getElementById('modalIcon').style.color = getUtilityColor(utilityData.type);
        document.getElementById('modalTitle').textContent = `${capitalizeFirst(utilityData.type)} ${capitalizeFirst(utilityData.lineType)} Line`;
        
        document.getElementById('infoType').textContent = capitalizeFirst(utilityData.type);
        document.getElementById('infoLineType').textContent = capitalizeFirst(utilityData.lineType);
        document.getElementById('infoSize').textContent = utilityData.size ? `${utilityData.size}"` : 'Not specified';
        document.getElementById('infoDepth').textContent = utilityData.depth ? `${utilityData.depth}'` : 'Not specified';
        document.getElementById('infoMaterial').textContent = utilityData.material || 'Not specified';
        document.getElementById('infoCondition').textContent = utilityData.condition || 'Not specified';
        document.getElementById('infoCurbDistance').textContent = utilityData.curbDistance ? `${utilityData.curbDistance}'` : 'Not specified';
        document.getElementById('infoDate').textContent = new Date(utilityData.dateAdded).toLocaleDateString();

        // Load notes
        loadNotes(utilityData);

        // Show view mode, hide edit mode
        document.getElementById('viewMode').style.display = 'block';
        document.getElementById('editMode').classList.remove('active');

        // Show modal
        document.getElementById('infoModal').classList.add('active');
    }

    function closeInfoModal() {
        document.getElementById('infoModal').classList.remove('active');
        // Don't clear selectedUtilityData if we're entering refine mode
        if (!AppState.refineMode) {
        AppState.selectedUtilityData = null;
        }
    }

    function getUtilityIcon(type) {
        const icons = {
            water: 'fas fa-tint',
            gas: 'fas fa-fire',
            electric: 'fas fa-bolt',
            sewer: 'fas fa-toilet',
            telecom: 'fas fa-phone'
        };
        return icons[type] || 'fas fa-question';
    }

    function capitalizeFirst(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function enterEditMode() {
        if (!AppState.selectedUtilityData) return;

        // Populate edit form
        document.getElementById('editSize').value = AppState.selectedUtilityData.size || '';
        document.getElementById('editDepth').value = AppState.selectedUtilityData.depth || '';
        document.getElementById('editMaterial').value = AppState.selectedUtilityData.material || '';
        document.getElementById('editCondition').value = AppState.selectedUtilityData.condition || '';
        document.getElementById('editCurbDistance').value = AppState.selectedUtilityData.curbDistance || '';

        // Show edit mode, hide view mode
        document.getElementById('viewMode').style.display = 'none';
        document.getElementById('editMode').classList.add('active');
    }

    function exitEditMode() {
        // Show view mode, hide edit mode
        document.getElementById('viewMode').style.display = 'block';
        document.getElementById('editMode').classList.remove('active');
    }

    async function saveEdit() {
        if (!AppState.selectedUtilityData) return;

        // Get and validate input values
        const size = document.getElementById('editSize').value.trim();
        const depth = document.getElementById('editDepth').value.trim();
        const material = document.getElementById('editMaterial').value.trim();
        const condition = document.getElementById('editCondition').value.trim();
        const curbDistance = document.getElementById('editCurbDistance').value.trim();

        // Validate numeric inputs
        if (size && (isNaN(size) || parseFloat(size) < 0)) {
            showToast('Size must be a positive number', 'error');
            return;
        }
        if (depth && (isNaN(depth) || parseFloat(depth) < 0)) {
            showToast('Depth must be a positive number', 'error');
            return;
        }
        if (curbDistance && (isNaN(curbDistance) || parseFloat(curbDistance) < 0)) {
            showToast('Curb distance must be a positive number', 'error');
            return;
        }

        // Update utility data
        AppState.selectedUtilityData.size = size;
        AppState.selectedUtilityData.depth = depth;
        AppState.selectedUtilityData.material = material;
        AppState.selectedUtilityData.condition = condition;
        AppState.selectedUtilityData.curbDistance = curbDistance;

        try {
            // Mark as modified and save immediately to Firestore
            AppState.selectedUtilityData.isModified = true;
            const success = await updateUtilityInFirestore(AppState.selectedUtilityData);
            
            if (success) {
                // Exit edit mode and refresh display only if save succeeded
                exitEditMode();
                showInfoModal(AppState.selectedUtilityData);
                showToast('Changes saved successfully', 'success');
                hapticFeedback(50);
            } else {
                throw new Error('Failed to save to Firestore');
            }
        } catch (error) {
            console.error('Error saving edits:', error);
            showToast('Error saving changes', 'error');
        }
    }

    // Notes functions
    function loadNotes(utilityData) {
        const notesList = document.getElementById('notesList');
        notesList.innerHTML = '';
        
        if (utilityData.notes && utilityData.notes.length > 0) {
            utilityData.notes.forEach((note, index) => {
                const noteItem = document.createElement('div');
                noteItem.className = 'note-item';
                noteItem.innerHTML = `
                    <p class="note-text">${note.text}</p>
                    <span class="note-date">${new Date(note.date).toLocaleString()}</span>
                    <button class="note-delete" onclick="deleteNote(${index})">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                notesList.appendChild(noteItem);
            });
        } else {
            notesList.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">No notes yet</p>';
        }
    }

    function showNoteInput() {
        document.getElementById('noteInputModal').classList.add('active');
        document.getElementById('noteTextarea').focus();
    }

    function hideNoteInput() {
        document.getElementById('noteInputModal').classList.remove('active');
        document.getElementById('noteTextarea').value = '';
    }

    async function saveNote() {
        const noteText = document.getElementById('noteTextarea').value.trim();
        
        if (!noteText) {
            showToast('Please enter a note', 'warning');
            return;
        }
        
        if (noteText.length > 1000) {
            showToast('Note is too long (max 1000 characters)', 'error');
            return;
        }
        
        if (!AppState.selectedUtilityData) {
            showToast('No utility selected', 'error');
            return;
        }
        
        if (!AppState.selectedUtilityData.notes) {
            AppState.selectedUtilityData.notes = [];
        }
        
        AppState.selectedUtilityData.notes.push({
            text: noteText,
            date: new Date().toISOString()
        });
        
        // Save immediately to Firestore
        try {
            const success = await updateUtilityInFirestore(AppState.selectedUtilityData);
            if (success) {
                loadNotes(AppState.selectedUtilityData);
                hideNoteInput();
                showToast('Note added', 'success');
                hapticFeedback(50);
            } else {
                // Remove the note if save failed
                AppState.selectedUtilityData.notes.pop();
                showToast('Error saving note', 'error');
            }
        } catch (error) {
            console.error('Error saving note:', error);
            // Remove the note if save failed
            AppState.selectedUtilityData.notes.pop();
            showToast('Error saving note', 'error');
        }
    }

    async function deleteNote(index) {
        if (!AppState.selectedUtilityData || !AppState.selectedUtilityData.notes) return;
        
        // Store the deleted note in case we need to restore it
        const deletedNote = AppState.selectedUtilityData.notes[index];
        AppState.selectedUtilityData.notes.splice(index, 1);
        
        // Save immediately to Firestore
        try {
            const success = await updateUtilityInFirestore(AppState.selectedUtilityData);
            if (success) {
                loadNotes(AppState.selectedUtilityData);
                showToast('Note deleted', 'success');
            } else {
                // Restore the note if save failed
                AppState.selectedUtilityData.notes.splice(index, 0, deletedNote);
                showToast('Error deleting note', 'error');
            }
        } catch (error) {
            console.error('Error deleting note:', error);
            // Restore the note if save failed
            AppState.selectedUtilityData.notes.splice(index, 0, deletedNote);
            showToast('Error deleting note', 'error');
        }
    }

    window.deleteNote = deleteNote;

    // Premium Refine Location - Completely Rebuilt for Reliability
    function startRefineLocation() {
        if (!AppState.selectedUtilityData) {
            console.error('❌ No selectedUtilityData found');
            showToast('No utility selected for refining', 'error');
            return;
        }

        console.log('🔧 Starting refine mode for utility:', AppState.selectedUtilityData.id);
        
        // Store reference to prevent accidental clearing
        const utilityToRefine = AppState.selectedUtilityData;
        
        // Cancel any other active modes
        if (AppState.addingStructure) {
            cancelStructurePlacement();
        }
        
        // Set refine mode FIRST
        AppState.refineMode = true;
        AppState.refineMarkers = [];
        
        // Close modal and show overlay
        closeInfoModal();

        // Ensure selectedUtilityData is still available
        AppState.selectedUtilityData = utilityToRefine;
        
        document.getElementById('refineOverlay').classList.add('active');

        // Highlight the utility line
        if (AppState.selectedUtilityData.lineLayer) {
            AppState.selectedUtilityData.lineLayer.setStyle({
                weight: AppState.selectedUtilityData.lineType === 'main' ? 6 : 5,
                opacity: 1,
                className: `utility-line ${AppState.selectedUtilityData.type} ${AppState.selectedUtilityData.lineType} highlighted`
            });
        }

        // Create simple, numbered refine markers
        const points = AppState.selectedUtilityData.points;
        points.forEach((point, index) => {
            createRefineMarker(point, index, false); // false = vertex marker
        });
        
        // Create intermediate markers for adding new points
        for (let i = 0; i < points.length - 1; i++) {
            const start = points[i];
            const end = points[i + 1];
            const midPoint = L.latLng(
                (start.lat + end.lat) / 2,
                (start.lng + end.lng) / 2
            );
            createRefineMarker(midPoint, i + 0.5, true); // true = intermediate marker
        }

        // Zoom to utility
        const bounds = L.latLngBounds(points);
        AppState.map.fitBounds(bounds, { 
            padding: [100, 100],
            maxZoom: 20
        });

        showToast(`Refine mode active - ${points.length} points to adjust. Drag + markers to add new points!`, 'success');
        hapticFeedback(100);
    }

    function createRefineMarker(latlng, index, isIntermediate = false) {
        const isVertex = !isIntermediate;
        
        const marker = L.marker(latlng, {
            icon: L.divIcon({
                className: 'refine-marker',
                html: isVertex 
                    ? `<div class="refine-point" title="Point ${Math.floor(index) + 1} - Drag to move">${Math.floor(index) + 1}</div>`
                    : `<div class="refine-point intermediate" title="Drag to create new point" style="width: 28px; height: 28px; font-size: 12px; background: linear-gradient(135deg, #e6f3ff 0%, #cce7ff 100%); border-color: #4d94ff;">+</div>`,
                iconSize: isVertex ? [40, 40] : [28, 28],
                iconAnchor: isVertex ? [20, 20] : [14, 14]
            }),
            draggable: true,
            zIndexOffset: isVertex ? 10000 : 9500
        });

        // Store marker properties
        marker.pointIndex = index;
        marker.utilityId = AppState.selectedUtilityData.id;
        marker.isIntermediate = isIntermediate;
        marker.originalPosition = L.latLng(latlng.lat, latlng.lng);

        // Enhanced drag events for mobile
        let isDragging = false;
        
        marker.on('dragstart', (e) => {
            isDragging = true;
            const displayIndex = isVertex ? Math.floor(index) + 1 : 'new';
            console.log(`📍 Starting drag of ${isVertex ? 'point' : 'intermediate'} ${displayIndex}`);
            
            // Visual feedback
            if (marker._icon) {
                const pointElement = marker._icon.querySelector('.refine-point');
                if (pointElement) {
                    pointElement.classList.add('dragging');
                }
            }
            
            // Disable map dragging
            AppState.map.dragging.disable();
            AppState.map.scrollWheelZoom.disable();
            
            const message = isVertex ? `Moving point ${displayIndex}` : 'Creating new point';
            showToast(message, 'info');
            hapticFeedback(50);
        });

        marker.on('drag', (e) => {
            if (!isDragging) return;
            
            // Update the line in real-time
                updateRefinedLine();
            hapticFeedback(5);
        });

        marker.on('dragend', (e) => {
                isDragging = false;
            const displayIndex = isVertex ? Math.floor(index) + 1 : 'new';
            console.log(`✅ Finished drag of ${isVertex ? 'point' : 'intermediate'} ${displayIndex}`);
            
            // Check if intermediate marker should become vertex
            if (isIntermediate) {
                const currentPos = marker.getLatLng();
                const distance = currentPos.distanceTo(marker.originalPosition);
                
                if (distance > 10) { // 10 meters threshold to create new vertex
                    console.log('🆕 Converting intermediate marker to vertex');
                    convertIntermediateToVertex(marker);
                    showToast('New point created!', 'success');
                    hapticFeedback(100);
                } else {
                    // If not moved far enough, snap back to middle
                    marker.setLatLng(marker.originalPosition);
                }
            }
            
            // Visual feedback reset
            if (marker._icon) {
                const pointElement = marker._icon.querySelector('.refine-point');
                if (pointElement) {
                    pointElement.classList.remove('dragging');
                }
            }
            
            // Re-enable map interactions
            setTimeout(() => {
                AppState.map.dragging.enable();
                AppState.map.scrollWheelZoom.enable();
            }, 100);
            
            // Final line update
            updateRefinedLine();
                hapticFeedback(30);
        });

        // Add to map and store reference
        marker.addTo(AppState.map);
        AppState.refineMarkers.push(marker);
        
        console.log(`✨ Created ${isVertex ? 'vertex' : 'intermediate'} marker ${index} at`, latlng);
    }

    function convertIntermediateToVertex(intermediateMarker) {
        const insertAfterIndex = Math.floor(intermediateMarker.pointIndex);
        
        // Convert the marker to a vertex
        intermediateMarker.isIntermediate = false;
        intermediateMarker.pointIndex = insertAfterIndex + 1;
        
        // Update all subsequent vertex markers' indices
        AppState.refineMarkers.forEach(marker => {
            if (!marker.isIntermediate && marker !== intermediateMarker && marker.pointIndex > insertAfterIndex) {
                marker.pointIndex += 1;
                
                // Update the visual number
                if (marker._icon) {
                    const pointElement = marker._icon.querySelector('.refine-point');
                    if (pointElement && !pointElement.classList.contains('intermediate')) {
                        pointElement.textContent = Math.floor(marker.pointIndex) + 1;
                        pointElement.title = `Point ${Math.floor(marker.pointIndex) + 1} - Drag to move`;
                    }
                }
            }
        });
        
        // Update the converted marker's appearance
        const newIcon = L.divIcon({
            className: 'refine-marker',
            html: `<div class="refine-point" title="Point ${Math.floor(intermediateMarker.pointIndex) + 1} - Drag to move">${Math.floor(intermediateMarker.pointIndex) + 1}</div>`,
            iconSize: [40, 40],
            iconAnchor: [20, 20]
        });
        intermediateMarker.setIcon(newIcon);
        intermediateMarker.setZIndexOffset(10000);
        
        // Recreate intermediate markers between all vertices
        recreateIntermediateMarkers();
        
        console.log('🔄 Updated marker indices and recreated intermediates');
    }

    function recreateIntermediateMarkers() {
        // Remove all existing intermediate markers
        const intermediateMarkers = AppState.refineMarkers.filter(m => m.isIntermediate);
        intermediateMarkers.forEach(marker => {
            AppState.map.removeLayer(marker);
        });
        
        // Remove them from the array
        AppState.refineMarkers = AppState.refineMarkers.filter(m => !m.isIntermediate);
        
        // Get all vertex markers sorted by index
        const vertexMarkers = AppState.refineMarkers
            .filter(m => !m.isIntermediate)
            .sort((a, b) => a.pointIndex - b.pointIndex);
        
        // Create new intermediate markers between each pair of vertices
        for (let i = 0; i < vertexMarkers.length - 1; i++) {
            const start = vertexMarkers[i].getLatLng();
            const end = vertexMarkers[i + 1].getLatLng();
            const midPoint = L.latLng(
                (start.lat + end.lat) / 2,
                (start.lng + end.lng) / 2
            );
            
            createRefineMarker(midPoint, vertexMarkers[i].pointIndex + 0.5, true);
        }
    }

    function updateRefinedLine() {
        if (!AppState.selectedUtilityData || !AppState.selectedUtilityData.lineLayer || !AppState.refineMode) {
            return;
        }

        try {
            // Get current positions from vertex markers only, sorted by index
            const currentPoints = AppState.refineMarkers
                .filter(marker => !marker.isIntermediate)
                .sort((a, b) => a.pointIndex - b.pointIndex)
                .map(marker => marker.getLatLng());
            
            if (currentPoints.length >= 2) {
                // Update the line on the map
                AppState.selectedUtilityData.lineLayer.setLatLngs(currentPoints);
                console.log(`📏 Updated line with ${currentPoints.length} vertex points`);
            }
        } catch (error) {
            console.error('Error updating refined line:', error);
        }
    }

    async function finishRefining() {
        console.log('🔍 Checking refine state:', {
            selectedUtilityData: !!AppState.selectedUtilityData,
            refineMode: AppState.refineMode,
            markersCount: AppState.refineMarkers?.length || 0
        });
        
        if (!AppState.selectedUtilityData) {
            console.error('❌ No selectedUtilityData available');
            showToast('No utility data available for refining', 'error');
            return;
        }
        
        if (!AppState.refineMode) {
            console.error('❌ Refine mode not active');
            showToast('Refine mode not active', 'warning');
            return;
        }

        try {
            console.log('💾 Finishing refine mode...');
            
            // Get final positions from vertex markers only
            const finalPoints = AppState.refineMarkers
                .filter(marker => !marker.isIntermediate)
                .sort((a, b) => a.pointIndex - b.pointIndex)
                .map(marker => marker.getLatLng());

            if (finalPoints.length >= 2) {
                // Update utility data
                AppState.selectedUtilityData.points = [...finalPoints];
                console.log(`📍 Updated utility with ${finalPoints.length} points`);
            }
            
            // Clean up refine markers
            AppState.refineMarkers.forEach((marker, index) => {
                if (AppState.map.hasLayer(marker)) {
            AppState.map.removeLayer(marker);
                }
        });

            // Reset line styling
        if (AppState.selectedUtilityData.lineLayer) {
            AppState.selectedUtilityData.lineLayer.setStyle({
                    weight: AppState.selectedUtilityData.lineType === 'main' ? 4 : 3,
                    opacity: 1,
                className: `utility-line ${AppState.selectedUtilityData.type} ${AppState.selectedUtilityData.lineType}`
            });
                
                // Ensure line is updated with final points
                AppState.selectedUtilityData.lineLayer.setLatLngs(AppState.selectedUtilityData.points);
        }

            // Clear refine state
        AppState.refineMode = false;
        AppState.refineMarkers = [];
        
        // Hide overlay
        document.getElementById('refineOverlay').classList.remove('active');

            // Re-enable map interactions
            AppState.map.dragging.enable();
            AppState.map.scrollWheelZoom.enable();

            // Save changes immediately to Firestore
            try {
                AppState.selectedUtilityData.isModified = true;
                const success = await updateUtilityInFirestore(AppState.selectedUtilityData);
                
                if (success) {
                    showToast('✅ Location refined and saved!', 'success');
                    hapticFeedback(200);
                } else {
                    throw new Error('Failed to save refined position');
                }
            } catch (saveError) {
                console.error('❌ Error saving refined position:', saveError);
                showToast('Error saving refined position', 'error');
                return; // Don't complete the refining if save failed
            }
            
            console.log('🎉 Refine mode completed successfully');
            
        } catch (error) {
            console.error('❌ Error finishing refining:', error);
            showToast('Error saving refined location', 'error');
            
            // Emergency cleanup
            AppState.refineMode = false;
            AppState.refineMarkers.forEach(marker => {
                try {
                    if (AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                } catch (e) { /* ignore */ }
            });
            AppState.refineMarkers = [];
            document.getElementById('refineOverlay').classList.remove('active');
            AppState.map.dragging.enable();
            AppState.map.scrollWheelZoom.enable();
        }
    }

    async function deleteUtility() {
        if (!AppState.selectedUtilityData) return;

        if (confirm('Are you sure you want to delete this utility line?')) {
            // Remove from map
            if (AppState.selectedUtilityData.lineLayer) {
                AppState.map.removeLayer(AppState.selectedUtilityData.lineLayer);
            }
            if (AppState.selectedUtilityData.touchTarget) {
                AppState.map.removeLayer(AppState.selectedUtilityData.touchTarget);
            }
            
            // Remove connection markers if they exist
            if (AppState.selectedUtilityData.connectionMarkers) {
                AppState.selectedUtilityData.connectionMarkers.forEach(marker => {
                    if (AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                });
            }

            // Remove from state
            const index = AppState.utilities.findIndex(u => u.id === AppState.selectedUtilityData.id);
            if (index > -1) {
                AppState.utilities.splice(index, 1);
            }

            // Delete from Firestore immediately
            await deleteUtilityFromFirestore(AppState.selectedUtilityData.id);
            syncToCloud();
            closeInfoModal();
            showToast('Utility deleted', 'success');
            hapticFeedback(50);
        }
    }

    // Excavation Mode
    function toggleExcavationMode() {
        if (AppState.excavationMode) {
            exitExcavationMode();
        } else {
            enterExcavationMode();
        }
    }

    function enterExcavationMode() {
        console.log('Entering excavation mode...');
        
        AppState.excavationMode = true;
        document.getElementById('excavationBtn').classList.add('active');
        document.getElementById('excavationOverlay').classList.add('active');

        // Enhanced utility visibility during excavation
        enhanceUtilityVisibilityForExcavation();
        
        // Initialize toggle state
        const toggleBtn = document.getElementById('alertToggleBtn');
        const toggleIcon = toggleBtn.querySelector('i');
        if (AppState.proximityAlertsVisible) {
            toggleBtn.classList.remove('alerts-hidden');
            toggleIcon.className = 'fas fa-eye';
            toggleBtn.title = 'Hide proximity alerts';
        } else {
            toggleBtn.classList.add('alerts-hidden');
            toggleIcon.className = 'fas fa-eye-slash';
            toggleBtn.title = 'Show proximity alerts';
            document.getElementById('proximityAlerts').classList.add('hidden');
        }

        // Check if user location is available
        if (!AppState.userLocation) {
            console.log('User location not available, requesting location...');
            showToast('Getting your location for excavation mode...', 'info');
            
            // Try to get current location
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        const { latitude, longitude } = position.coords;
                        AppState.userLocation = [latitude, longitude];
                        console.log('Got user location:', AppState.userLocation);
                        
                        // Update user marker if it exists
                        if (AppState.userMarker) {
                            AppState.userMarker.setLatLng([latitude, longitude]);
                        }
                        
                        // Zoom to location and start checking
            AppState.map.setView(AppState.userLocation, 20);
                        checkProximity();
                        showExcavationModeStatus();
                    },
                    error => {
                        console.error('Location error:', error);
                        showToast('Location required for excavation mode. Please enable location services.', 'error');
                        exitExcavationMode();
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
                );
            } else {
                showToast('Location services not available', 'error');
                exitExcavationMode();
                return;
            }
        } else {
            console.log('Using existing user location:', AppState.userLocation);
            // Zoom to user location
            AppState.map.setView(AppState.userLocation, 20);
            
            // Start proximity checking immediately
        checkProximity();
            showExcavationModeStatus();
        }

        // Start periodic proximity checking
        AppState.proximityInterval = setInterval(checkProximity, 2000); // Check every 2 seconds

        console.log('Excavation mode setup complete', {
            userLocation: AppState.userLocation,
            utilitiesCount: AppState.utilities.length,
            intervalId: AppState.proximityInterval
        });

        // Strong haptic feedback
        hapticFeedback(200);
        setTimeout(() => hapticFeedback(200), 200);
        setTimeout(() => hapticFeedback(200), 400);
    }

    function showExcavationModeStatus() {
        const utilitiesCount = AppState.utilities.length;
        if (utilitiesCount === 0) {
            showToast('Excavation mode active - No utilities mapped yet', 'warning');
            console.log('No utilities available for proximity checking');
        } else {
            showToast(`Excavation mode active - Monitoring ${utilitiesCount} utilities`, 'warning');
        }
    }

    // Debug function to create test utilities for testing excavation mode
    function createTestUtility(offsetLat = 0.0001, offsetLng = 0.0001) {
        if (!AppState.userLocation) {
            console.log('Cannot create test utility - no user location');
            return;
        }

        const testUtility = {
            id: generateId(),
            type: 'water',
            lineType: 'main',
            points: [
                L.latLng(AppState.userLocation[0] + offsetLat, AppState.userLocation[1] + offsetLng),
                L.latLng(AppState.userLocation[0] + offsetLat + 0.0001, AppState.userLocation[1] + offsetLng + 0.0001)
            ],
            size: '8',
            depth: '4',
            material: 'Cast Iron',
            condition: 'Good',
            curbDistance: '6',
            dateAdded: new Date().toISOString(),
            connections: [],
            notes: []
        };

        AppState.utilities.push(testUtility);
        createUtilityLine(testUtility);
        saveUtilities();
        
        console.log('Created test utility:', testUtility);
        return testUtility;
    }

    // Make debug function available globally for testing
    window.createTestUtility = createTestUtility;
    
    // Quick Test Function for New Refine Feature
    function createTestUtilityForRefining() {
        try {
            if (AppState.utilities.length > 0) {
                console.log('✅ Opening first utility for testing refine...');
                showInfoModal(AppState.utilities[0]);
                return AppState.utilities[0];
            }
            
            let testLocation;
            if (AppState.userLocation) {
                testLocation = AppState.userLocation;
            } else {
                testLocation = [40.7128, -74.0060]; // Default NYC
            }
            
            console.log('🧪 Creating test utility for refining at:', testLocation);
            
            const testUtility = {
                id: generateId(),
                type: 'water',
                lineType: 'main',
                points: [
                    L.latLng(testLocation[0] - 0.0003, testLocation[1] - 0.0003),
                    L.latLng(testLocation[0] + 0.0003, testLocation[1] + 0.0003)
                ],
                size: '8',
                depth: '4',
                material: 'Cast Iron',
                condition: 'Good',
                curbDistance: '6',
                dateAdded: new Date().toISOString(),
                connections: [],
                notes: []
            };

            AppState.utilities.push(testUtility);
            createUtilityLine(testUtility);
            saveUtilities();
            
            console.log('✨ Test utility created with 2 points for refining');
            showToast('🔧 Test utility created! Long press line → Edit → Refine. Drag + to add points!', 'success');
            
            // Zoom to the test utility
            const bounds = L.latLngBounds(testUtility.points);
            AppState.map.fitBounds(bounds, { padding: [80, 80] });
            
            return testUtility;
        } catch (error) {
            console.error('❌ Error creating test utility:', error);
            showToast('Error creating test utility', 'error');
            return null;
        }
    }
    
    // Make it available globally for testing
    window.createTestUtilityForRefining = createTestUtilityForRefining;

    function exitExcavationMode() {
        AppState.excavationMode = false;
        document.getElementById('excavationBtn').classList.remove('active');
        document.getElementById('excavationOverlay').classList.remove('active');

        // Reset utility visibility
        resetUtilityVisibilityFromExcavation();

        // Clear proximity alerts and reset visibility
        clearProximityAlerts();
        document.getElementById('proximityAlerts').classList.remove('hidden');

        // Stop proximity checking
        if (AppState.proximityInterval) {
            clearInterval(AppState.proximityInterval);
        }

        showToast('Excavation mode deactivated', 'info');
        hapticFeedback(50);
    }

    function checkProximity() {
        if (!AppState.userLocation || !AppState.excavationMode) {
            console.log('Proximity check skipped:', {
                userLocation: !!AppState.userLocation,
                excavationMode: AppState.excavationMode
            });
            return;
        }

        const alertsContainer = document.getElementById('proximityAlerts');
        const radius = 25; // 25 feet in meters (increased for safety)
        const radiusMeters = radius * 0.3048;

        console.log('Checking proximity:', {
            userLocation: AppState.userLocation,
            radiusMeters: radiusMeters,
            utilitiesCount: AppState.utilities.length
        });

        // Track which utilities are in range
        const inRangeUtilities = new Set();

        // Check each utility
        AppState.utilities.forEach((utility, index) => {
            // Skip if utility is not visible
            if (!AppState.layers.visibility[utility.type] || 
                !AppState.layers.visibility[utility.lineType]) {
                console.log(`Utility ${index} skipped - not visible:`, {
                    type: utility.type,
                    lineType: utility.lineType,
                    typeVisible: AppState.layers.visibility[utility.type],
                    lineTypeVisible: AppState.layers.visibility[utility.lineType]
                });
                return;
            }

            // Calculate distance to utility line
            const distance = calculateDistanceToLine(AppState.userLocation, utility.points);
            
            console.log(`Utility ${index} distance:`, {
                id: utility.id,
                type: utility.type,
                lineType: utility.lineType,
                distance: distance,
                radiusMeters: radiusMeters,
                inRange: distance <= radiusMeters
            });
            
            if (distance <= radiusMeters) {
                inRangeUtilities.add(utility.id);
                
                // Check if already alerted and not dismissed
                const alertId = `alert-${utility.id}`;
                const existingAlert = document.getElementById(alertId);
                const dismissedTime = AppState.dismissedAlerts.get(utility.id);
                
                if (dismissedTime) {
                    // Check if 3 minutes have passed
                    if (Date.now() - dismissedTime < 180000) {
                        console.log(`Alert for ${utility.id} dismissed recently`);
                        return;
                    }
                    AppState.dismissedAlerts.delete(utility.id);
                }

                if (!existingAlert) {
                    console.log(`Creating new proximity alert for utility ${utility.id}`);
                    createProximityAlert(utility, distance);
                } else {
                    console.log(`Updating existing alert for utility ${utility.id}`);
                    updateProximityAlert(utility, distance);
                }
            }
        });

        console.log('In-range utilities:', Array.from(inRangeUtilities));

        // Handle alerts for utilities that are out of range
        AppState.alertTimeouts.forEach((timeout, utilityId) => {
            if (!inRangeUtilities.has(utilityId)) {
                // Start or continue timeout
                if (!timeout) {
                    AppState.alertTimeouts.set(utilityId, Date.now());
                }
            } else {
                // In range again, clear timeout
                AppState.alertTimeouts.delete(utilityId);
            }
        });

        // Remove alerts that have been out of range for 45 seconds
        AppState.alertTimeouts.forEach((startTime, utilityId) => {
            if (Date.now() - startTime > 45000) {
                removeProximityAlert(utilityId);
                AppState.alertTimeouts.delete(utilityId);
            }
        });
    }

    function calculateDistanceToLine(point, linePoints) {
        let minDistance = Infinity;

        for (let i = 0; i < linePoints.length - 1; i++) {
            const distance = distanceToLineSegment(point, linePoints[i], linePoints[i + 1]);
            minDistance = Math.min(minDistance, distance);
        }

        return minDistance;
    }

    function distanceToLineSegment(point, lineStart, lineEnd) {
        const startLat = lineStart.lat || lineStart[0];
        const startLng = lineStart.lng || lineStart[1];
        const endLat = lineEnd.lat || lineEnd[0];
        const endLng = lineEnd.lng || lineEnd[1];

        const A = point[0] - startLat;
        const B = point[1] - startLng;
        const C = endLat - startLat;
        const D = endLng - startLng;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
            param = dot / lenSq;
        }

        let closestLat, closestLng;

        if (param < 0) {
            // Closest point is the start of the segment
            closestLat = startLat;
            closestLng = startLng;
        } else if (param > 1) {
            // Closest point is the end of the segment
            closestLat = endLat;
            closestLng = endLng;
        } else {
            // Closest point is somewhere along the segment
            closestLat = startLat + param * C;
            closestLng = startLng + param * D;
        }

        // Calculate distance using Haversine formula for better accuracy
        const R = 6371000; // Earth's radius in meters
        const φ1 = point[0] * Math.PI / 180;
        const φ2 = closestLat * Math.PI / 180;
        const Δφ = (closestLat - point[0]) * Math.PI / 180;
        const Δλ = (closestLng - point[1]) * Math.PI / 180;

        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c; // Distance in meters
    }

    function createProximityAlert(utility, distance) {
        // Don't create alerts if they're hidden
        if (!AppState.proximityAlertsVisible) {
            return;
        }
        
        const alertsContainer = document.getElementById('proximityAlerts');
        const alertId = `alert-${utility.id}`;

        const alertDiv = document.createElement('div');
        alertDiv.id = alertId;
        alertDiv.className = `proximity-alert ${utility.type}`;
        alertDiv.innerHTML = `
            <div class="alert-content">
                <div class="alert-header">
                    <div class="alert-icon-container ${utility.type}">
                        <i class="${getUtilityIcon(utility.type)}" aria-hidden="true"></i>
                    </div>
                    <button class="alert-close" onclick="dismissProximityAlert('${utility.id}')" aria-label="Dismiss alert">
                        <i class="fas fa-times" aria-hidden="true"></i>
                    </button>
                </div>
                
                <div class="alert-utility-info">
                    <h3 class="alert-utility-type">${utility.type.toUpperCase()}</h3>
                    <p class="alert-line-type">${utility.lineType} Line</p>
                </div>
                
                <div class="alert-distance-banner">
                    <span class="distance-value">${Math.round(distance / 0.3048)}</span>
                    <span class="distance-unit">FEET AWAY</span>
                </div>
                
                ${utility.depth ? `<div class="alert-depth-banner" style="font-weight: bold; color: #fff; background: linear-gradient(135deg, #ff6b35, #ff8c42); margin: 4px 0; padding: 8px 12px; border-radius: 12px; font-size: 13px; text-align: center; box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3); animation: depthPulse 2s ease-in-out infinite;">⚠️ DEPTH: ${utility.depth} FT</div>` : ''}
                
                <div class="alert-details">
                    <div class="detail-item">
                        <span class="detail-label">Size</span>
                        <span class="detail-value">${utility.size ? utility.size + '"' : 'N/A'}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Material</span>
                        <span class="detail-value">${utility.material || 'N/A'}</span>
                    </div>
                </div>
            </div>
        `;

        alertsContainer.appendChild(alertDiv);

        // Limit to 12 alerts for grid layout
        while (alertsContainer.children.length > 12) {
            const firstChild = alertsContainer.firstChild;
            const utilityId = firstChild.id.replace('alert-', '');
            AppState.alertTimeouts.set(utilityId, Date.now());
            alertsContainer.removeChild(firstChild);
        }

        // Haptic feedback for new alert
        hapticFeedback(200);
    }

    function updateProximityAlert(utility, distance) {
        // Don't update alerts if they're hidden
        if (!AppState.proximityAlertsVisible) {
            return;
        }
        
        const alertElement = document.getElementById(`alert-${utility.id}`);
        if (alertElement) {
            const distanceValue = alertElement.querySelector('.distance-value');
            if (distanceValue) {
                distanceValue.textContent = Math.round(distance / 0.3048);
            }
        }
    }

    function removeProximityAlert(utilityId) {
        const alert = document.getElementById(`alert-${utilityId}`);
        if (alert) {
            alert.remove();
        }
    }

    function dismissProximityAlert(utilityId) {
        const alert = document.getElementById(`alert-${utilityId}`);
        if (alert) {
            alert.remove();
            AppState.dismissedAlerts.set(utilityId, Date.now());
            AppState.alertTimeouts.delete(utilityId);
            hapticFeedback(30);
        }
    }

    window.dismissProximityAlert = dismissProximityAlert;

    function clearProximityAlerts() {
        const alertsContainer = document.getElementById('proximityAlerts');
        alertsContainer.innerHTML = '';
        AppState.dismissedAlerts.clear();
        AppState.alertTimeouts.clear();
    }

    function toggleProximityAlerts() {
        AppState.proximityAlertsVisible = !AppState.proximityAlertsVisible;
        const alertsContainer = document.getElementById('proximityAlerts');
        const toggleBtn = document.getElementById('alertToggleBtn');
        const toggleIcon = toggleBtn.querySelector('i');
        
        if (AppState.proximityAlertsVisible) {
            alertsContainer.classList.remove('hidden');
            toggleBtn.classList.remove('alerts-hidden');
            toggleIcon.className = 'fas fa-eye';
            toggleBtn.title = 'Hide proximity alerts';
        } else {
            alertsContainer.classList.add('hidden');
            toggleBtn.classList.add('alerts-hidden');
            toggleIcon.className = 'fas fa-eye-slash';
            toggleBtn.title = 'Show proximity alerts';
        }
        
        hapticFeedback(30);
    }

    function enhanceUtilityVisibilityForExcavation() {
        // Force all utilities to be fully visible and enhanced during excavation
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                utility.lineLayer.setStyle({
                    opacity: 1.0, // Full opacity regardless of zoom
                    weight: utility.lineType === 'main' ? 6 : 5, // Slightly thicker for excavation
                    className: `utility-line ${utility.type} ${utility.lineType} excavation-enhanced`
                });
                
                // Add glow effect
                utility.lineLayer.getElement()?.classList.add('excavation-enhanced');
            }
            
            // Enhanced connection markers
            if (utility.connectionMarkers) {
                utility.connectionMarkers.forEach(marker => {
                    if (marker._icon) {
                        marker._icon.style.opacity = '1.0';
                        marker._icon.style.transform = 'scale(1.3)';
                        marker._icon.style.filter = 'drop-shadow(0 0 12px currentColor)';
                    }
                });
            }
        });
        
        // Enhanced structures
        AppState.structures.forEach(structure => {
            if (structure.marker && structure.marker._icon) {
                structure.marker._icon.style.opacity = '1.0';
                structure.marker._icon.style.transform = 'scale(1.4)';
                structure.marker._icon.style.filter = 'drop-shadow(0 0 16px currentColor)';
            }
        });
    }

    function resetUtilityVisibilityFromExcavation() {
        // Reset utilities to normal zoom-based visibility
        const currentZoom = AppState.map.getZoom();
        const zoomOpacity = calculateZoomOpacity(currentZoom);
        
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                utility.lineLayer.setStyle({
                    opacity: zoomOpacity,
                    weight: utility.lineType === 'main' ? 4 : 3, // Normal fixed thickness
                    className: `utility-line ${utility.type} ${utility.lineType}`
                });
                
                // Remove glow effect
                utility.lineLayer.getElement()?.classList.remove('excavation-enhanced');
            }
            
            // Reset connection markers
            if (utility.connectionMarkers) {
                utility.connectionMarkers.forEach(marker => {
                    if (marker._icon) {
                        marker._icon.style.opacity = zoomOpacity;
                        marker._icon.style.transform = 'scale(1)';
                        marker._icon.style.filter = '';
                    }
                });
            }
        });
        
        // Reset structures
        AppState.structures.forEach(structure => {
            if (structure.marker && structure.marker._icon) {
                structure.marker._icon.style.opacity = zoomOpacity;
                structure.marker._icon.style.transform = 'scale(1)';
                structure.marker._icon.style.filter = '';
            }
        });
    }

    // Measurement Tools
    function toggleMeasureMode(mode) {
        if (AppState.measureMode === mode) {
            // Cancel measurement
            clearMeasurement();
            AppState.measureMode = null;
            document.getElementById('measureDistanceBtn').classList.remove('active');
            document.getElementById('measureAreaBtn').classList.remove('active');
        } else {
            // Start new measurement
            clearMeasurement();
            AppState.measureMode = mode;
            AppState.measurePoints = [];
            
            if (mode === 'distance') {
                document.getElementById('measureDistanceBtn').classList.add('active');
                document.getElementById('measureAreaBtn').classList.remove('active');
                showToast('Click points to measure distance', 'info');
            } else {
                document.getElementById('measureAreaBtn').classList.add('active');
                document.getElementById('measureDistanceBtn').classList.remove('active');
                showToast('Click points to measure area', 'info');
            }
        }
        hapticFeedback(30);
    }

    function addMeasurePoint(latlng) {
        AppState.measurePoints.push(latlng);
        
        // Add marker
        const marker = L.circleMarker(latlng, {
            radius: 6,
            fillColor: '#667eea',
            fillOpacity: 1,
            color: 'white',
            weight: 2
        }).addTo(AppState.map);
        
        AppState.measureMarkers.push(marker);
        
        // Update measurement display
        updateMeasurement();
        
        hapticFeedback(30);
    }

    function updateMeasurement() {
        if (AppState.measureMode === 'distance') {
            // Clear previous line
            if (AppState.measureLine) {
                AppState.map.removeLayer(AppState.measureLine);
            }
            
            if (AppState.measurePoints.length > 1) {
                // Draw line
                AppState.measureLine = L.polyline(AppState.measurePoints, {
                    color: '#667eea',
                    weight: 3,
                    dashArray: '5, 10'
                }).addTo(AppState.map);
                
                // Calculate total distance
                let totalDistance = 0;
                for (let i = 1; i < AppState.measurePoints.length; i++) {
                    totalDistance += AppState.measurePoints[i - 1].distanceTo(AppState.measurePoints[i]);
                }
                
                // Convert to feet
                const distanceFeet = Math.round(totalDistance * 3.28084);
                
                // Show distance
                showMeasurementDisplay(`Distance: ${distanceFeet}'`);
            }
        } else if (AppState.measureMode === 'area') {
            // Clear previous polygon
            if (AppState.measurePolygon) {
                AppState.map.removeLayer(AppState.measurePolygon);
            }
            
            if (AppState.measurePoints.length > 2) {
                // Draw polygon
                AppState.measurePolygon = L.polygon(AppState.measurePoints, {
                    color: '#667eea',
                    weight: 3,
                    fillOpacity: 0.2,
                    dashArray: '5, 10'
                }).addTo(AppState.map);
                
                // Calculate area
                const area = L.GeometryUtil.geodesicArea(AppState.measurePoints);
                const areaFeet = Math.round(area * 10.764); // Convert to square feet
                
                // Show area
                showMeasurementDisplay(`Area: ${areaFeet.toLocaleString()} sq ft`);
            }
        }
    }

    function showMeasurementDisplay(text) {
        // Remove previous display
        const existingDisplay = document.querySelector('.measurement-display');
        if (existingDisplay) {
            existingDisplay.remove();
        }
        
        // Create new display
        const display = document.createElement('div');
        display.className = 'measurement-display';
        display.textContent = text;
        
        // Position at last point
        const lastPoint = AppState.measurePoints[AppState.measurePoints.length - 1];
        const point = AppState.map.latLngToContainerPoint(lastPoint);
        
        display.style.left = `${point.x}px`;
        display.style.top = `${point.y - 40}px`;
        
        document.querySelector('.app-container').appendChild(display);
    }

    function clearMeasurement() {
        // Clear markers
        AppState.measureMarkers.forEach(marker => {
            AppState.map.removeLayer(marker);
        });
        AppState.measureMarkers = [];
        
        // Clear lines/polygons
        if (AppState.measureLine) {
            AppState.map.removeLayer(AppState.measureLine);
            AppState.measureLine = null;
        }
        if (AppState.measurePolygon) {
            AppState.map.removeLayer(AppState.measurePolygon);
            AppState.measurePolygon = null;
        }
        
        // Clear display
        const display = document.querySelector('.measurement-display');
        if (display) {
            display.remove();
        }
        
        AppState.measurePoints = [];
    }

    // Settings
    function openSettings() {
        document.getElementById('settingsPanel').classList.add('active');
    }

    function closeSettings() {
        document.getElementById('settingsPanel').classList.remove('active');
    }

    function toggleLayersPanel() {
        openSettings();
    }

    function setTheme(theme) {
        AppState.theme = theme;
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        
        const darkModeToggle = document.getElementById('darkModeToggle');
        if (theme === 'dark') {
            darkModeToggle.classList.add('active');
            if (AppState.currentMapStyle === 'streets') {
                changeMapStyle('dark');
            }
        } else {
            darkModeToggle.classList.remove('active');
            if (AppState.currentMapStyle === 'dark') {
                changeMapStyle('streets');
            }
        }
    }

    function toggleDarkMode() {
        const newTheme = AppState.theme === 'light' ? 'dark' : 'light';
        setTheme(newTheme);
        hapticFeedback(30);
    }

    function changeMapStyle(style) {
        // Update active button
        document.querySelectorAll('.map-style-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.style === style);
        });

        // Change map tiles
        AppState.map.eachLayer(layer => {
            if (layer instanceof L.TileLayer || layer instanceof L.TileLayer.Bing) {
                AppState.map.removeLayer(layer);
            }
        });

        // Handle special map layers
        let newLayer;
        const styleUrl = AppState.mapStyles[style];
        
        if (styleUrl === 'bing-satellite') {
            // Use Bing Satellite layer
            newLayer = new L.TileLayer.Bing('a', {
                maxZoom: 21,
                maxNativeZoom: 19,
                keepBuffer: 8
            });
        } else {
            // Use regular tile layer
            const layerOptions = {
                maxZoom: 22,
                maxNativeZoom: 19,
                keepBuffer: 8
            };
            
            // Add specific attribution for known services
            if (style === 'usgs-hybrid') {
                layerOptions.attribution = 'USGS National Map';
                layerOptions.maxNativeZoom = 16;
            } else if (style === 'infrastructure' || style === 'satellite-clarity') {
                layerOptions.attribution = '&copy; Esri';
            }
            
            newLayer = L.tileLayer(styleUrl, layerOptions);
        }
        
        newLayer.addTo(AppState.map);
        AppState.currentMapStyle = style;
        hapticFeedback(30);
    }

    function toggleUtilityVisibility(toggle) {
        const utility = toggle.dataset.utility;
        const isActive = toggle.classList.toggle('active');
        AppState.layers.visibility[utility] = isActive;

        // Show/hide layers
        if (isActive) {
            AppState.map.addLayer(AppState.layers.utilities[utility]);
            AppState.map.addLayer(AppState.layers.structures[utility]);
        } else {
            AppState.map.removeLayer(AppState.layers.utilities[utility]);
            AppState.map.removeLayer(AppState.layers.structures[utility]);
        }
        hapticFeedback(30);
    }

    function toggleLineTypeVisibility(toggle) {
        const lineType = toggle.dataset.linetype;
        const isActive = toggle.classList.toggle('active');
        AppState.layers.visibility[lineType] = isActive;

        // Update utility visibility
        updateUtilityVisibility();
        hapticFeedback(30);
    }

    function updateUtilityVisibility() {
        const currentZoom = AppState.map.getZoom();
        const zoomOpacity = calculateZoomOpacity(currentZoom);
        
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                const shouldShow = AppState.layers.visibility[utility.type] && 
                                 AppState.layers.visibility[utility.lineType];
                
                if (shouldShow) {
                    // Apply zoom-based opacity when visible
                    const isHighlighted = utility.lineLayer.options.className && 
                                        utility.lineLayer.options.className.includes('highlighted');
                    const isBeingRefined = AppState.refineMode && 
                                         AppState.selectedUtilityData && 
                                         utility.id === AppState.selectedUtilityData.id;
                    const finalOpacity = (isHighlighted || isBeingRefined) ? 1.0 : zoomOpacity;
                    
                    // Keep fixed weight
                    const fixedWeight = utility.lineType === 'main' ? 4 : 3;
                    
                    utility.lineLayer.setStyle({ 
                        opacity: finalOpacity,
                        weight: fixedWeight
                    });
                    
                    // Keep touch target interactive when visible
                    if (utility.touchTarget) {
                        utility.touchTarget.setStyle({ 
                            weight: 50,
                            opacity: 0 
                        });
                        utility.touchTarget.options.interactive = true;
                    }
                } else {
                    // Completely hidden when type is disabled
                    utility.lineLayer.setStyle({ opacity: 0 });
                    
                    // Disable touch target when hidden
                    if (utility.touchTarget) {
                        utility.touchTarget.setStyle({ opacity: 0 });
                        utility.touchTarget.options.interactive = false;
                    }
                }
            }
        });
    }

    // Cloud Sync functions
    function toggleCloudSync() {
        const toggle = document.getElementById('cloudSyncToggle');
        const isActive = toggle.classList.toggle('active');
        
        if (isActive) {
            enableCloudSync();
        } else {
            disableCloudSync();
        }
        
        localStorage.setItem('cloudSyncEnabled', isActive);
        hapticFeedback(30);
    }

    function enableCloudSync() {
        AppState.cloudSync.enabled = true;
        document.getElementById('cloudSyncToggle').classList.add('active');
        
        // Initialize cloud sync (implement actual cloud service)
        initializeCloudSync();
        syncToCloud();
    }

    function disableCloudSync() {
        AppState.cloudSync.enabled = false;
        document.getElementById('cloudSyncToggle').classList.remove('active');
    }

    function initializeCloudSync() {
        // This would connect to your actual cloud service
        // For now, we'll use a mock implementation
        AppState.cloudSync.userId = localStorage.getItem('userId') || generateId();
        localStorage.setItem('userId', AppState.cloudSync.userId);
    }

    function syncToCloud() {
        if (!AppState.cloudSync.enabled) return;
        
        showSyncStatus();
        
        // Mock cloud sync - replace with actual API calls
        setTimeout(() => {
            AppState.cloudSync.lastSync = new Date().toISOString();
            hideSyncStatus();
            console.log('Data synced to cloud');
        }, 1000);
    }

    function showSyncStatus() {
        document.getElementById('syncStatus').classList.add('show');
    }

    function hideSyncStatus() {
        setTimeout(() => {
            document.getElementById('syncStatus').classList.remove('show');
        }, 2000);
    }

    // Utility functions
    function generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    async function saveUtilities() {
        if (!AppState.currentUser) {
            console.warn('⚠️ No user logged in, cannot save utilities');
            return;
        }
        
        console.log('💾 Saving utilities to Firestore...');
        
        try {
            for (const utility of AppState.utilities) {
                // Save directly to utilities collection
                if (!utility.isSaved || utility.isModified) {
                    console.log('💾 Saving utility:', utility.id);
                    
                    const utilityData = {
                        id: utility.id,
                        type: utility.type,
                        lineType: utility.lineType,
                        points: utility.points.map(p => ({ lat: p.lat, lng: p.lng })),
                        size: utility.size || '',
                        depth: utility.depth || '',
                        material: utility.material || '',
                        condition: utility.condition || '',
                        curbDistance: utility.curbDistance || '',
                        dateAdded: utility.dateAdded,
                        connections: utility.connections || [],
                        notes: utility.notes || [],
                        createdBy: AppState.currentUser.uid,
                        createdByEmail: AppState.currentUser.email,
                        lastModified: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    await db.collection('utilities').doc(utility.id).set(utilityData);
                    utility.isSaved = true;
                    utility.isModified = false;
                    
                    // Update visual appearance - no more dashed lines
                    if (utility.lineLayer) {
                        utility.lineLayer.setStyle({
                            dashArray: null,
                            opacity: 1
                        });
                        
                        // Remove pending class
                        const currentClasses = utility.lineLayer.options.className || '';
                        utility.lineLayer.setStyle({
                            className: currentClasses.replace(' pending', '')
                        });
                    }
                    
                    console.log('✅ Utility saved:', utility.id);
                }
            }
            
            showToast('Utilities saved successfully', 'success');
            console.log('✅ All utilities saved');
        } catch (error) {
            console.error('❌ Error saving utilities:', error);
            showToast('Error saving utilities', 'error');
        }
    }

    // Individual Firestore operations for better sync control
    async function saveUtilityToFirestore(utility) {
        if (!AppState.currentUser) {
            console.warn('⚠️ No user logged in, cannot save utility to Firestore');
            return false;
        }

        try {
            const utilityDoc = {
                id: utility.id,
                type: utility.type,
                lineType: utility.lineType,
                points: utility.points.map(p => ({ lat: p.lat, lng: p.lng })),
                size: utility.size || '',
                depth: utility.depth || '',
                material: utility.material || '',
                condition: utility.condition || '',
                curbDistance: utility.curbDistance || '',
                dateAdded: utility.dateAdded,
                connections: utility.connections || [],
                notes: utility.notes || [],
                distance: utility.distance || 0,
                createdBy: AppState.currentUser.uid,
                createdByEmail: AppState.currentUser.email,
                lastModified: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            await db.collection('utilities').doc(utility.id).set(utilityDoc);
            utility.isSaved = true;
            utility.isModified = false;
            
            console.log('✅ Individual utility saved to Firestore:', utility.id);
            return true;
        } catch (error) {
            console.error('❌ Error saving utility to Firestore:', error);
            showToast('Error saving to cloud', 'error');
            return false;
        }
    }

    async function deleteUtilityFromFirestore(utilityId) {
        if (!AppState.currentUser) {
            console.warn('⚠️ No user logged in, cannot delete from Firestore');
            return false;
        }

        try {
            await db.collection('utilities').doc(utilityId).delete();
            console.log('✅ Utility deleted from Firestore:', utilityId);
            return true;
        } catch (error) {
            console.error('❌ Error deleting utility from Firestore:', error);
            showToast('Error deleting from cloud', 'error');
            return false;
        }
    }

    async function updateUtilityInFirestore(utility) {
        if (!AppState.currentUser) {
            console.warn('⚠️ No user logged in, cannot update in Firestore');
            return false;
        }

        try {
            const utilityDoc = {
                type: utility.type,
                lineType: utility.lineType,
                points: utility.points.map(p => ({ lat: p.lat, lng: p.lng })),
                size: utility.size || '',
                depth: utility.depth || '',
                material: utility.material || '',
                condition: utility.condition || '',
                curbDistance: utility.curbDistance || '',
                notes: utility.notes || [],
                connections: utility.connections || [],
                distance: utility.distance || 0,
                lastModified: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            await db.collection('utilities').doc(utility.id).update(utilityDoc);
            utility.isModified = false;
            
            console.log('✅ Utility updated in Firestore:', utility.id);
            return true;
        } catch (error) {
            console.error('❌ Error updating utility in Firestore:', error);
            showToast('Error updating cloud data', 'error');
            return false;
        }
    }

    async function loadUtilitiesFromFirestore() {
        if (!AppState.currentUser) {
            console.log('⚠️ No user logged in, skipping Firestore load');
            return false;
        }

        try {
            console.log('📥 Loading utilities from Firestore...');
            const snapshot = await AppState.safeCollection('utilities').get();
            
            if (snapshot.empty) {
                console.log('📝 No utilities found in Firestore');
                return true;
            }
            
            // Clear existing utilities
            AppState.utilities.forEach(utility => {
                if (utility.lineLayer) {
                    AppState.map.removeLayer(utility.lineLayer);
                }
                if (utility.touchTarget) {
                    AppState.map.removeLayer(utility.touchTarget);
                }
                if (utility.connectionMarkers) {
                    utility.connectionMarkers.forEach(marker => {
                        if (AppState.map.hasLayer(marker)) {
                            AppState.map.removeLayer(marker);
                        }
                    });
                }
            });
            AppState.utilities = [];
            
            let loadedCount = 0;
            
            snapshot.forEach((doc) => {
                const utilityData = doc.data();
                
                // Skip placeholder documents
                if (utilityData.isPlaceholder) {
                    return;
                }
                
                // Validate required data exists
                if (!utilityData.points || !Array.isArray(utilityData.points)) {
                    console.warn('⚠️ Skipping utility with invalid points:', doc.id);
                    return;
                }
                
                try {
                    // Convert points
                    utilityData.points = utilityData.points.map(p => {
                        if (p && typeof p.lat === 'number' && typeof p.lng === 'number') {
                            return L.latLng(p.lat, p.lng);
                        } else {
                            return null;
                        }
                    }).filter(p => p !== null);
                    
                    // Only add if we have at least 2 valid points
                    if (utilityData.points.length >= 2) {
                        utilityData.isSaved = true;
                        utilityData.isModified = false;
                        
                        // Check if user can see this utility
                        if (canUserSeeUtility(utilityData)) {
                            AppState.utilities.push(utilityData);
                            createUtilityLine(utilityData);
                            loadedCount++;
                        }
                    }
                } catch (pointError) {
                    console.error('❌ Error processing utility points:', doc.id, pointError);
                }
            });
            
            console.log(`✅ Loaded ${loadedCount} utilities from Firestore`);
            return true;
        } catch (error) {
            console.error('❌ Error loading utilities from Firestore:', error);
            return false;
        }
    }

    // Real-time sync setup
    function setupRealtimeSync() {
        if (!AppState.currentUser) {
            console.warn('⚠️ No user logged in, skipping real-time sync setup');
            return;
        }

        console.log('🔄 Setting up real-time sync...');

        // Listen for utility changes
        const utilitiesListener = db.collection('utilities').onSnapshot((snapshot) => {
            snapshot.docChanges().forEach((change) => {
                const data = change.doc.data();
                
                // Skip placeholder documents
                if (data.isPlaceholder) {
                    return;
                }

                // Validate required data
                if (!data.points || !Array.isArray(data.points)) {
                    console.warn('⚠️ Skipping utility with invalid points:', change.doc.id);
                    return;
                }

                const utility = {
                    id: change.doc.id,
                    ...data,
                    points: data.points.map(p => {
                        if (p && typeof p.lat === 'number' && typeof p.lng === 'number') {
                            return L.latLng(p.lat, p.lng);
                        }
                        return null;
                    }).filter(p => p !== null)
                };

                if (utility.points.length < 2) {
                    console.warn('⚠️ Skipping utility with insufficient points:', change.doc.id);
                    return;
                }

                if (change.type === 'added') {
                    console.log('🆕 Real-time: Utility added', utility.id);
                    
                    // Check if we already have this utility (avoid duplicates)
                    const existingIndex = AppState.utilities.findIndex(u => u.id === utility.id);
                    if (existingIndex === -1 && canUserSeeUtility(utility)) {
                        utility.isSaved = true;
                        utility.isModified = false;
                        AppState.utilities.push(utility);
                        createUtilityLine(utility);
                        showToast('New utility added to map', 'info');
                    }
                    
                } else if (change.type === 'modified') {
                    console.log('✏️ Real-time: Utility modified', utility.id);
                    
                    // Find and update existing utility
                    const index = AppState.utilities.findIndex(u => u.id === utility.id);
                    if (index >= 0) {
                        const oldUtility = AppState.utilities[index];
                        
                        // Remove old visual elements
                        if (oldUtility.lineLayer) {
                            AppState.map.removeLayer(oldUtility.lineLayer);
                        }
                        if (oldUtility.touchTarget) {
                            AppState.map.removeLayer(oldUtility.touchTarget);
                        }
                        if (oldUtility.connectionMarkers) {
                            oldUtility.connectionMarkers.forEach(marker => {
                                if (AppState.map.hasLayer(marker)) {
                                    AppState.map.removeLayer(marker);
                                }
                            });
                        }
                        
                        // Update the utility data
                        utility.isSaved = true;
                        utility.isModified = false;
                        AppState.utilities[index] = utility;
                        
                        // Create new visual elements
                        if (canUserSeeUtility(utility)) {
                            createUtilityLine(utility);
                            showToast('Utility updated on map', 'info');
                        }
                    } else if (canUserSeeUtility(utility)) {
                        // Add if we don't have it and can see it
                        utility.isSaved = true;
                        utility.isModified = false;
                        AppState.utilities.push(utility);
                        createUtilityLine(utility);
                        showToast('New utility added to map', 'info');
                    }
                    
                } else if (change.type === 'removed') {
                    console.log('🗑️ Real-time: Utility removed', change.doc.id);
                    
                    // Remove from local data and map
                    const index = AppState.utilities.findIndex(u => u.id === change.doc.id);
                    if (index >= 0) {
                        const utility = AppState.utilities[index];
                        
                        // Remove from map
                        if (utility.lineLayer) {
                            AppState.map.removeLayer(utility.lineLayer);
                        }
                        if (utility.touchTarget) {
                            AppState.map.removeLayer(utility.touchTarget);
                        }
                        if (utility.connectionMarkers) {
                            utility.connectionMarkers.forEach(marker => {
                                if (AppState.map.hasLayer(marker)) {
                                    AppState.map.removeLayer(marker);
                                }
                            });
                        }
                        
                        // Remove from array
                        AppState.utilities.splice(index, 1);
                        showToast('Utility removed from map', 'info');
                        
                        // Close info modal if this utility was selected
                        if (AppState.selectedUtilityData && AppState.selectedUtilityData.id === change.doc.id) {
                            closeInfoModal();
                        }
                    }
                }
            });
        }, (error) => {
            console.error('❌ Error in utilities real-time listener:', error);
            if (error.code !== 'permission-denied') {
                showToast('Real-time sync error for utilities', 'error');
            }
        });

        // Listen for structure changes
        const structuresListener = db.collection('structures').onSnapshot((snapshot) => {
            snapshot.docChanges().forEach((change) => {
                const data = change.doc.data();
                
                // Skip placeholder documents
                if (data.isPlaceholder) {
                    return;
                }

                if (change.type === 'added') {
                    console.log('🆕 Real-time: Structure added', change.doc.id);
                    
                    // Check if we already have this structure
                    const existingIndex = AppState.structures.findIndex(s => s.id === change.doc.id);
                    if (existingIndex === -1 && data.latlng) {
                        const structure = {
                            id: change.doc.id,
                            ...data,
                            latlng: L.latLng(data.latlng.lat, data.latlng.lng),
                            isSaved: true,
                            isModified: false
                        };
                        AppState.structures.push(structure);
                        createStructureMarker(structure);
                        showToast('New structure added to map', 'info');
                    }
                    
                } else if (change.type === 'modified') {
                    console.log('✏️ Real-time: Structure modified', change.doc.id);
                    
                    const index = AppState.structures.findIndex(s => s.id === change.doc.id);
                    if (index >= 0 && data.latlng) {
                        const oldStructure = AppState.structures[index];
                        
                        // Remove old marker
                        if (oldStructure.marker) {
                            AppState.map.removeLayer(oldStructure.marker);
                        }
                        
                        // Update structure data
                        const structure = {
                            id: change.doc.id,
                            ...data,
                            latlng: L.latLng(data.latlng.lat, data.latlng.lng),
                            isSaved: true,
                            isModified: false
                        };
                        AppState.structures[index] = structure;
                        
                        // Create new marker
                        createStructureMarker(structure);
                        showToast('Structure updated on map', 'info');
                    }
                    
                } else if (change.type === 'removed') {
                    console.log('🗑️ Real-time: Structure removed', change.doc.id);
                    
                    const index = AppState.structures.findIndex(s => s.id === change.doc.id);
                    if (index >= 0) {
                        const structure = AppState.structures[index];
                        
                        // Remove from map
                        if (structure.marker) {
                            AppState.map.removeLayer(structure.marker);
                        }
                        
                        // Remove from array
                        AppState.structures.splice(index, 1);
                        showToast('Structure removed from map', 'info');
                    }
                }
            });
        }, (error) => {
            console.error('❌ Error in structures real-time listener:', error);
            if (error.code !== 'permission-denied') {
                showToast('Real-time sync error for structures', 'error');
            }
        });

        // Store listeners for cleanup
        if (!AppState.realtimeListeners) {
            AppState.realtimeListeners = [];
        }
        AppState.realtimeListeners.push(utilitiesListener, structuresListener);

        console.log('✅ Real-time sync setup complete');
    }

    // Function to cleanup real-time listeners
    function cleanupRealtimeListeners() {
        if (AppState.realtimeListeners) {
            AppState.realtimeListeners.forEach(listener => {
                if (typeof listener === 'function') {
                    listener(); // Call the unsubscribe function
                }
            });
            AppState.realtimeListeners = [];
            console.log('🧹 Real-time listeners cleaned up');
        }
    }

    async function loadUtilities() {
        if (!AppState.currentUser) {
            console.log('⚠️ No user logged in, skipping utilities load');
            return;
        }
        
        try {
            console.log('📥 Loading utilities from Firestore...');
            const snapshot = await AppState.safeCollection('utilities').get();
            
            if (snapshot.empty) {
                console.log('📝 No utilities found (this is normal for new setups)');
                return; // Don't show error for empty collection
            }
            
            let loadedCount = 0;
            let filteredCount = 0;
            
            snapshot.forEach((doc) => {
                const utilityData = doc.data();
                
                // Skip placeholder documents
                if (utilityData.isPlaceholder) {
                    console.log('🗑️ Skipping placeholder utility:', doc.id);
                    return;
                }
                
                // Validate required data exists
                if (!utilityData.points || !Array.isArray(utilityData.points)) {
                    console.warn('⚠️ Skipping utility with invalid points:', doc.id);
                    return;
                }
                
                try {
                    // Safely convert points with validation
                    utilityData.points = utilityData.points.map(p => {
                        if (p && typeof p.lat === 'number' && typeof p.lng === 'number') {
                            return L.latLng(p.lat, p.lng);
                        } else {
                            console.warn('⚠️ Invalid point in utility:', p);
                            return null;
                        }
                    }).filter(p => p !== null); // Remove invalid points
                    
                    // Only add if we have at least 2 valid points
                    if (utilityData.points.length >= 2) {
                        utilityData.isSaved = true;
                        
                        // Check if user can see this utility based on role and distance
                        if (canUserSeeUtility(utilityData)) {
                            // Avoid duplicates
                            if (!AppState.utilities.find(u => u.id === utilityData.id)) {
                    AppState.utilities.push(utilityData);
                    createUtilityLine(utilityData);
                                loadedCount++;
                            }
                        } else {
                            filteredCount++;
                        }
                    } else {
                        console.warn('⚠️ Skipping utility with insufficient points:', doc.id);
                    }
                } catch (pointError) {
                    console.error('❌ Error processing utility points:', doc.id, pointError);
                }
            });
            
            console.log(`✅ Loaded ${loadedCount} valid utilities from Firestore`);
            if (AppState.userRole === 'pitman' && filteredCount > 0) {
                console.log(`🚫 Filtered out ${filteredCount} utilities (>150ft away)`);
                showToast(`Loaded ${loadedCount} utilities (${filteredCount} filtered by distance)`, 'info');
            } else if (loadedCount > 0) {
                showToast(`Loaded ${loadedCount} utilities`, 'success');
            }
        } catch (error) {
            console.error('❌ Error loading utilities:', error);
            // Only show error if it's a real permission issue
            if (error.code === 'permission-denied') {
                showToast('Permission denied loading utilities', 'error');
            }
            // Don't show error for missing collections or other normal cases
        }
    }

    async function loadStructures() {
        if (!AppState.currentUser) {
            console.log('⚠️ No user logged in, skipping structures load');
            return;
        }
        
        try {
            console.log('📥 Loading structures from Firestore...');
            const snapshot = await AppState.safeCollection('structures').get();
            
            if (snapshot.empty) {
                console.log('📝 No structures found (this is normal for new setups)');
                return; // Don't show error for empty collection
            }
            
            let loadedCount = 0;
            snapshot.forEach((doc) => {
                const structureData = doc.data();
                
                // Skip placeholder documents
                if (structureData.isPlaceholder) {
                    console.log('🗑️ Skipping placeholder structure:', doc.id);
                    return;
                }
                
                // Validate required data exists
                if (!structureData.latlng) {
                    console.warn('⚠️ Skipping structure with no location:', doc.id);
                    return;
                }
                
                try {
                    // Safely convert latlng with validation
                    if (structureData.latlng.lat !== undefined && 
                        structureData.latlng.lng !== undefined &&
                        typeof structureData.latlng.lat === 'number' &&
                        typeof structureData.latlng.lng === 'number') {
                        
                        structureData.latlng = L.latLng(
                            structureData.latlng.lat, 
                            structureData.latlng.lng
                        );
                        structureData.isSaved = true;
                        
                        // Avoid duplicates
                        if (!AppState.structures.find(s => s.id === structureData.id)) {
                    AppState.structures.push(structureData);
                    createStructureMarker(structureData);
                            loadedCount++;
                        }
                    } else {
                        console.warn('⚠️ Invalid latlng in structure:', doc.id, structureData.latlng);
                    }
                } catch (latlngError) {
                    console.error('❌ Error processing structure location:', doc.id, latlngError);
                }
            });
            
            console.log(`✅ Loaded ${loadedCount} valid structures from Firestore`);
        } catch (error) {
            console.error('❌ Error loading structures:', error);
            // Only show error if it's a real permission issue
            if (error.code === 'permission-denied') {
                showToast('Permission denied loading structures', 'error');
            }
            // Don't show error for missing collections
        }
    }

    async function saveStructures() {
        if (!AppState.currentUser) {
            console.warn('⚠️ No user logged in, cannot save structures');
            return;
        }
        
        try {
            for (const structure of AppState.structures) {
                if (!structure.isSaved || structure.isModified) {
                    console.log('💾 Saving structure:', structure.id);
                    
                    const structureData = {
                        id: structure.id,
                        type: structure.type,
                        utilityType: structure.utilityType,
                        latlng: {
                            lat: structure.latlng.lat,
                            lng: structure.latlng.lng
                        },
                        dateAdded: structure.dateAdded,
                        createdBy: AppState.currentUser.uid,
                        createdByEmail: AppState.currentUser.email,
                        lastModified: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    await db.collection('structures').doc(structure.id).set(structureData);
                    structure.isSaved = true;
                    structure.isModified = false;
                    
                    // Update visual appearance
                    if (structure.marker && structure.marker._icon) {
                        structure.marker._icon.classList.remove('pending');
                    }
                    
                    console.log('✅ Structure saved:', structure.id);
                }
            }
            
            showToast('Structures saved successfully', 'success');
            console.log('✅ All structures saved');
        } catch (error) {
            console.error('❌ Error saving structures:', error);
            showToast('Error saving structures', 'error');
        }
    }



    // ========== ADMIN PANEL FUNCTIONS ==========

    async function loadPendingChanges() {
        console.log('📥 Pending changes system disabled - all users can save directly');
        const listEl = document.getElementById('pendingChangesList');
        if (listEl) {
            listEl.innerHTML = `
                <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                    <i class="fas fa-check-circle" style="font-size: 48px; color: var(--success-color); margin-bottom: 16px;"></i>
                    <h3 style="margin: 0 0 8px 0; color: var(--text-primary);">Direct Save Enabled</h3>
                    <p style="margin: 0; font-size: 14px;">All roles can create and save utilities directly.<br/>No approval process required.</p>
                </div>
            `;
        }
    }

    function updatePendingChangesList(docs) {
        const listEl = document.getElementById('pendingChangesList');
        listEl.innerHTML = '';
        
        if (docs.length === 0) {
            listEl.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">✅ No pending changes</p>';
            return;
        }
        
        docs.forEach((doc) => {
            const change = doc.data();
            const pendingEl = document.createElement('div');
            pendingEl.className = 'pending-item';
            
            // Format timestamp
            let timeStr = 'Just now';
            if (change.timestamp && change.timestamp.toDate) {
                const timeAgo = Date.now() - change.timestamp.toDate().getTime();
                const minutes = Math.floor(timeAgo / 60000);
                const hours = Math.floor(timeAgo / 3600000);
                const days = Math.floor(timeAgo / 86400000);
                
                if (days > 0) timeStr = `${days} day${days > 1 ? 's' : ''} ago`;
                else if (hours > 0) timeStr = `${hours} hour${hours > 1 ? 's' : ''} ago`;
                else if (minutes > 0) timeStr = `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
            }
            
            // Create detailed description
            let details = '';
            if (change.type === 'utility') {
                details = `${capitalizeFirst(change.data.type)} ${change.data.lineType} line`;
                if (change.data.size) details += ` (${change.data.size}")`;
                if (change.data.material) details += ` - ${change.data.material}`;
            } else if (change.type === 'structure') {
                details = getStructureName(change.data.type);
            }
            
            pendingEl.innerHTML = `
                <div class="pending-header">
                    <span class="pending-type">
                        <i class="fas ${getChangeIcon(change.type, change.action)}"></i>
                        ${capitalizeFirst(change.action)} ${capitalizeFirst(change.type)}
                    </span>
                    <span class="pending-user">${change.userEmail}</span>
                </div>
                <div class="pending-timestamp">${timeStr}</div>
                <div class="pending-details">${details}</div>
                <div class="pending-actions">
                    <button class="approve-btn" onclick="approveChange('${doc.id}')">
                        <i class="fas fa-check"></i> Approve
                    </button>
                    <button class="reject-btn" onclick="rejectChange('${doc.id}')">
                        <i class="fas fa-times"></i> Reject
                    </button>
                </div>
            `;
            listEl.appendChild(pendingEl);
        });
    }

    function getChangeIcon(type, action) {
        const icons = {
            utility: {
                add: 'fa-plus-circle',
                edit: 'fa-edit',
                delete: 'fa-trash'
            },
            structure: {
                add: 'fa-plus-circle',
                edit: 'fa-edit',
                delete: 'fa-trash'
            }
        };
        return icons[type]?.[action] || 'fa-question-circle';
    }

    async function approveChange(changeId) {
        if (AppState.userRole !== 'admin') {
            showToast('Only admins can approve changes', 'error');
            return;
        }
        
        console.log('✅ Approving change:', changeId);
        
        try {
            const changeDoc = await db.collection('pendingChanges').doc(changeId).get();
            if (!changeDoc.exists) {
                showToast('Change not found', 'error');
                return;
            }
            
            const change = changeDoc.data();
            
            if (change.type === 'utility' && change.action === 'add') {
                // Add to approved utilities collection
                await db.collection('utilities').doc(change.data.id).set(change.data);
                console.log('✅ Utility approved and added to database');
            } else if (change.type === 'structure' && change.action === 'add') {
                // Add to approved structures collection
                await db.collection('structures').doc(change.data.id).set(change.data);
                console.log('✅ Structure approved and added to database');
            }
            
            // Delete the pending change
            await db.collection('pendingChanges').doc(changeId).delete();
            
            showToast(`${capitalizeFirst(change.type)} approved successfully!`, 'success');
            hapticFeedback(100);
            
        } catch (error) {
            console.error('❌ Error approving change:', error);
            showToast('Error approving change', 'error');
        }
    }

    async function rejectChange(changeId) {
        if (AppState.userRole !== 'admin') {
            showToast('Only admins can reject changes', 'error');
            return;
        }
        
        console.log('❌ Rejecting change:', changeId);
        
        try {
            const changeDoc = await db.collection('pendingChanges').doc(changeId).get();
            if (!changeDoc.exists) {
                showToast('Change not found', 'error');
                return;
            }
            
            const change = changeDoc.data();
            
            // Delete the pending change
            await db.collection('pendingChanges').doc(changeId).delete();
            
            showToast(`${capitalizeFirst(change.type)} change rejected`, 'info');
            hapticFeedback(50);
            
        } catch (error) {
            console.error('❌ Error rejecting change:', error);
            showToast('Error rejecting change', 'error');
        }
    }

    async function loadUsers() {
        if (AppState.userRole !== 'admin' && AppState.userRole !== 'supervisor') {
            console.warn('⚠️ Only admins and supervisors can load users');
            return;
        }
        
        console.log('👥 Loading users...');
        try {
            const snapshot = await AppState.safeCollection('users').orderBy('createdAt', 'desc').get();
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '';
            
            if (snapshot.empty) {
                usersList.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">No users found</p>';
                return;
            }
            
            snapshot.forEach((doc) => {
                const user = doc.data();
                const userEl = document.createElement('div');
                userEl.className = 'user-item';
                userEl.innerHTML = `
                    <div class="user-info">
                        <div class="user-email">${user.email}</div>
                        <div class="user-role ${user.role}">${user.role}</div>
                    </div>
                    <select class="role-select" onchange="updateUserRole('${doc.id}', this.value)" style="padding: 4px 8px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-primary); font-size: 12px;">
                        <option value="restricted" ${user.role === 'restricted' ? 'selected' : ''}>Restricted</option>
                        <option value="pitman" ${user.role === 'pitman' ? 'selected' : ''}>Pitman/MO</option>
                        <option value="supervisor" ${user.role === 'supervisor' ? 'selected' : ''}>Supervisor</option>
                        ${AppState.userRole === 'admin' ? 
                            `<option value="admin" ${user.role === 'admin' ? 'selected' : ''}>Admin</option>` : ''}
                    </select>
                `;
                usersList.appendChild(userEl);
            });
            
            console.log(`✅ Loaded ${snapshot.size} users`);
        } catch (error) {
            console.error('❌ Error loading users:', error);
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '<p style="color: var(--danger-color);">Error loading users</p>';
        }
    }

    async function approveUser(userId) {
        if (AppState.userRole !== 'admin') {
            showToast('Only admins can approve users', 'error');
            return;
        }
        
        console.log('👤 Approving user:', userId);
        
        try {
            await db.collection('users').doc(userId).update({ 
                role: 'user',
                approvedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            showToast('User approved successfully!', 'success');
            hapticFeedback(100);
            
            // Refresh user list
            loadUsers();
            
        } catch (error) {
            console.error('❌ Error approving user:', error);
            showToast('Error approving user', 'error');
        }
    }

    function openAdminPanel() {
        if (AppState.userRole !== 'admin' && AppState.userRole !== 'supervisor') {
            showToast('Admin or supervisor access required', 'error');
            return;
        }
        
        console.log('🔧 Opening admin panel');
        document.getElementById('adminPanel').classList.add('active');
        
        // Load fresh data
        loadPendingChanges();
        loadUsers();
    }

    function closeAdminPanel() {
        document.getElementById('adminPanel').classList.remove('active');
    }

    function signOut() {
        if (confirm('Are you sure you want to sign out?')) {
            console.log('👋 Signing out user');
            auth.signOut().then(() => {
                // Clear app state
                AppState.currentUser = null;
                AppState.userRole = null;
                AppState.utilities = [];
                AppState.structures = [];
                
                // Clear map
                if (AppState.map) {
                    AppState.map.eachLayer((layer) => {
                        if (layer !== AppState.map._layers[Object.keys(AppState.map._layers)[0]]) {
                            AppState.map.removeLayer(layer);
                        }
                    });
                }
                
                // Remove role badge and admin button
                const badge = document.querySelector('.role-badge');
                const adminBtn = document.querySelector('.admin-btn');
                if (badge) badge.remove();
                if (adminBtn) adminBtn.remove();
                
                showToast('Signed out successfully', 'success');
                
                // Reload page to reset state
                setTimeout(() => {
                    location.reload();
                }, 1000);
            }).catch((error) => {
                console.error('❌ Sign out error:', error);
                showToast('Error signing out', 'error');
            });
        }
    }

    // Make admin functions available globally
    window.approveChange = approveChange;
    window.rejectChange = rejectChange;
    window.approveUser = approveUser;
    window.openAdminPanel = openAdminPanel;
    window.closeAdminPanel = closeAdminPanel;
    window.signOut = signOut;

    function showToast(message, type = 'info') {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            success: 'fa-check-circle',
            error: 'fa-exclamation-circle',
            warning: 'fa-exclamation-triangle',
            info: 'fa-info-circle'
        };
        
        toast.innerHTML = `
            <i class="fas ${icons[type]}"></i>
            <span>${message}</span>
        `;
        
        container.appendChild(toast);
        
        setTimeout(() => toast.classList.add('show'), 10);
        
        // Adjust timeout based on message length
        const timeout = type === 'info' && message.length > 50 ? 5000 : 3000;
        
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, timeout);
    }

    // Initialize GeometryUtil for area calculations
    L.GeometryUtil = L.extend(L.GeometryUtil || {}, {
        geodesicArea: function (latLngs) {
            const R = 6378137; // Earth's radius in meters
            let area = 0;
            const len = latLngs.length;
            let x1, y1, x2, y2;
            
            for (let i = 0; i < len; i++) {
                x1 = latLngs[i].lng * Math.PI / 180;
                y1 = latLngs[i].lat * Math.PI / 180;
                x2 = latLngs[(i + 1) % len].lng * Math.PI / 180;
                y2 = latLngs[(i + 1) % len].lat * Math.PI / 180;
                
                area += (x2 - x1) * (Math.sin(y1) + Math.sin(y2));
            }
            
            area = Math.abs(area * R * R / 2);
            return area;
        }
    });
    
    // Debug function to test refine workflow
    function testRefineWorkflow() {
        console.log('🧪 Testing refine workflow...');
        
        // Step 1: Create test utility if none exist
        if (AppState.utilities.length === 0) {
            console.log('📝 Creating test utility...');
            createTestUtilityForRefining();
            return;
        }
        
        // Step 2: Open info modal for first utility
        const testUtility = AppState.utilities[0];
        console.log('📋 Opening modal for:', testUtility.id);
        showInfoModal(testUtility);
        
        // Step 3: After a short delay, start refining
        setTimeout(() => {
            console.log('🔧 Starting refine mode...');
            startRefineLocation();
        }, 1000);
    }
    
    // Make it available globally for testing
    window.testRefineWorkflow = testRefineWorkflow;
    
    // Test structure functionality
    function testStructureButton() {
        console.log('🧪 Testing structure button functionality...');
        
        // Check if button exists
        const structureBtn = document.getElementById('addStructureBtn');
        if (!structureBtn) {
            console.error('❌ Structure button not found');
            return;
        }
        
        // Check if menu exists
        const structureMenu = document.getElementById('structureMenu');
        if (!structureMenu) {
            console.error('❌ Structure menu not found');
            return;
        }
        
        console.log('✅ Structure button and menu found');
        console.log('📏 Button position:', structureBtn.getBoundingClientRect());
        console.log('📏 Menu position:', structureMenu.getBoundingClientRect());
        
        // Simulate clicking the button
        console.log('🔄 Opening menu...');
        toggleStructureMenu();
        
        setTimeout(() => {
            const isVisible = structureMenu.classList.contains('active');
            const computedStyle = window.getComputedStyle(structureMenu);
            console.log('📋 Menu active:', isVisible);
            console.log('📋 Menu display:', computedStyle.display);
            console.log('📋 Menu visibility:', computedStyle.visibility);
            console.log('📏 Menu bounds after open:', structureMenu.getBoundingClientRect());
            
            if (isVisible && computedStyle.display === 'grid') {
                console.log('✅ Menu is properly visible!');
                showToast('✅ Structure menu test passed!', 'success');
            } else {
                console.error('❌ Menu is not visible properly');
                showToast('❌ Structure menu test failed', 'error');
            }
            
            // Close after 3 seconds
            setTimeout(() => {
                console.log('🔄 Closing menu...');
                toggleStructureMenu();
            }, 3000);
            
        }, 500);
        
        console.log('✅ Structure test initiated');
    }
    
    // Make it available globally for testing
    window.testStructureButton = testStructureButton;
    
    // Test zoom fading functionality
    function testZoomFading() {
        console.log('🔍 Testing zoom-based fading...');
        
        if (AppState.utilities.length === 0) {
            console.log('📝 Creating test utility for zoom testing...');
            createTestUtilityForRefining();
        }
        
        const startZoom = AppState.map.getZoom();
        console.log(`🎯 Starting zoom level: ${startZoom}`);
        
        showToast('🔍 Testing zoom fading - watch utilities fade as we zoom out!', 'info');
        
        // Zoom out gradually to show aggressive fading effect
        let currentZoom = Math.min(startZoom, 20); // Start from max zoom 20
        const zoomOut = () => {
            if (currentZoom > 10) {
                currentZoom -= 1;
                AppState.map.setZoom(currentZoom);
                const opacity = calculateZoomOpacity(currentZoom);
                console.log(`🔍 Zoom ${currentZoom}: Opacity ${opacity.toFixed(2)}`);
                showToast(`Zoom ${currentZoom}: ${Math.round(opacity * 100)}% opacity`, 'info');
                setTimeout(zoomOut, 1200);
            } else {
                // Zoom back in
                console.log('🔄 Zooming back in...');
                setTimeout(() => {
                    const zoomIn = () => {
                        if (currentZoom < startZoom) {
                            currentZoom += 1;
                            AppState.map.setZoom(currentZoom);
                            const opacity = calculateZoomOpacity(currentZoom);
                            console.log(`🔍 Zoom ${currentZoom}: Opacity ${opacity.toFixed(2)}`);
                            setTimeout(zoomIn, 500);
                        } else {
                            console.log('✅ Zoom fading test completed!');
                            showToast('✅ Zoom fading test completed!', 'success');
                        }
                    };
                    zoomIn();
                }, 1000);
            }
        };
        
        setTimeout(zoomOut, 1000);
    }
    
    // Make it available globally for testing
    window.testZoomFading = testZoomFading;
    
    // Test mobile touch functionality
    function testMobileTouch() {
        console.log('🧪 Testing mobile touch functionality...');
        
        // Check if we're on a touch device
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        console.log('📱 Touch device detected:', isTouchDevice);
        
        if (!isTouchDevice) {
            showToast('⚠️ No touch support detected - test may not be accurate', 'warning');
        }
        
        // Create a test utility if none exist
        if (AppState.utilities.length === 0) {
            console.log('📝 Creating test utility for touch testing...');
            createTestUtilityForRefining();
            
            setTimeout(() => {
                console.log('✅ Test utility created');
                showToast('📱 Touch test: Try pressing and holding the blue line for 0.5 seconds', 'info');
                
                // Check if events are bound
                const testUtility = AppState.utilities[0];
                if (testUtility && testUtility.lineLayer) {
                    console.log('🔗 Testing event listeners on utility line...');
                    const events = testUtility.lineLayer._events;
                    if (events) {
                        console.log('📋 Registered events:', Object.keys(events));
                        console.log('  - touchstart:', !!events.touchstart);
                        console.log('  - touchmove:', !!events.touchmove); 
                        console.log('  - touchend:', !!events.touchend);
                        console.log('  - mousedown:', !!events.mousedown);
                    }
                }
            }, 1000);
            
            return;
        }
        
        // Test existing utility
        const testUtility = AppState.utilities[0];
        console.log('🎯 Testing touch events on utility:', testUtility.id);
        
        // Show info about the utility
        showToast('📱 Touch test: Try pressing and holding the utility line for 0.5 seconds', 'info');
        
        // Zoom to the utility for better testing
        if (testUtility.points && testUtility.points.length > 0) {
            const bounds = L.latLngBounds(testUtility.points);
            AppState.map.fitBounds(bounds, { padding: [100, 100] });
        }
        
        // Check event listeners
        if (testUtility.lineLayer && testUtility.lineLayer._events) {
            const events = testUtility.lineLayer._events;
            console.log('📋 Touch events registered:', {
                touchstart: !!events.touchstart,
                touchmove: !!events.touchmove, 
                touchend: !!events.touchend,
                mousedown: !!events.mousedown
            });
            
            if (events.touchstart) {
                console.log('✅ Touch events are properly registered');
                showToast('✅ Touch events are registered - try the long press now!', 'success');
            } else {
                console.error('❌ Touch events not found');
                showToast('❌ Touch events not registered properly', 'error');
            }
        }
    }
    
    // Make it available globally for testing
    window.testMobileTouch = testMobileTouch;
    
    // Debug function for account status
    async function debugAccountStatus() {
        if (!auth.currentUser) {
            console.log('❌ No user logged in');
            return;
        }
        
        console.log('🔍 Account Status Debug:');
        console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        console.log('👤 Firebase Auth User:');
        console.log('  UID:', auth.currentUser.uid);
        console.log('  Email:', auth.currentUser.email);
        console.log('  Display Name:', auth.currentUser.displayName);
        console.log('');
        
        try {
            const userDoc = await db.collection('users').doc(auth.currentUser.uid).get();
            if (userDoc.exists) {
                console.log('✅ Firestore User Document:');
                const userData = userDoc.data();
                console.log('  Role:', userData.role);
                console.log('  Created:', userData.createdAt?.toDate());
                console.log('  Promoted to Admin:', userData.promotedToAdmin?.toDate());
                console.log('  Document Data:', userData);
            } else {
                console.log('❌ No Firestore User Document Found');
                console.log('  This is the problem! User exists in Auth but not in Firestore.');
                console.log('  Try signing out and signing back in to create the document.');
            }
        } catch (error) {
            console.error('❌ Error fetching user document:', error);
        }
        
        try {
            const adminSnapshot = await db.collection('users').where('role', '==', 'admin').get();
            console.log('');
            console.log('👑 Admin Users in System:');
            if (adminSnapshot.empty) {
                console.log('  No admin users found - next user will become admin');
            } else {
                adminSnapshot.forEach(doc => {
                    const data = doc.data();
                    console.log(`  - ${data.email} (${doc.id})`);
                });
            }
        } catch (error) {
            console.error('❌ Error fetching admin users:', error);
        }
        
        console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    }
    
    // Make debug function available globally
    window.debugAccountStatus = debugAccountStatus;

    // ========== ROLE MANAGEMENT FUNCTIONS ==========

    // Role management functions
    async function updateUserRole(userId, newRole) {
        if (AppState.userRole !== 'admin' && AppState.userRole !== 'supervisor') {
            showToast('Only admins and supervisors can change roles', 'error');
            return;
        }
        
        const validRoles = ['admin', 'supervisor', 'pitman', 'restricted'];
        if (!validRoles.includes(newRole)) {
            showToast('Invalid role', 'error');
            return;
        }
        
        try {
            await db.collection('users').doc(userId).update({ 
                role: newRole,
                roleUpdatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            showToast(`User role updated to ${newRole}`, 'success');
            loadUsers(); // Refresh user list
        } catch (error) {
            console.error('Error updating user role:', error);
            showToast('Error updating user role', 'error');
        }
    }

    // Check if user can see utility based on role and distance
    function canUserSeeUtility(utility) {
        // Restricted users cannot see any utilities
        if (AppState.userRole === 'restricted') {
            return false;
        }
        
        // Admins and Supervisors can see everything
        if (AppState.userRole === 'admin' || AppState.userRole === 'supervisor') {
            return true;
        }
        
        // Pitman can only see utilities within 150 feet
        if (AppState.userRole === 'pitman' && AppState.userLocation) {
            // Check distance to each point in the utility line
            for (const point of utility.points) {
                const distance = calculateDistanceInFeet(
                    AppState.userLocation,
                    [point.lat || point[0], point.lng || point[1]]
                );
                if (distance <= 150) {
                    return true;
                }
            }
            return false;
        }
        
        return true; // Default allow
    }

    // Calculate distance in feet
    function calculateDistanceInFeet(point1, point2) {
        const R = 20902231; // Earth's radius in feet
        const lat1 = point1[0] * Math.PI / 180;
        const lat2 = point2[0] * Math.PI / 180;
        const deltaLat = (point2[0] - point1[0]) * Math.PI / 180;
        const deltaLng = (point2[1] - point1[1]) * Math.PI / 180;
        
        const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                  Math.cos(lat1) * Math.cos(lat2) *
                  Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        
        return R * c;
    }

    // Make role management functions available globally
    window.updateUserRole = updateUserRole;
    
    // Cleanup function for bad Firestore data
    async function cleanupBadData() {
        if (AppState.userRole !== 'admin') {
            console.log('❌ Only admins can clean up data');
            showToast('Admin access required', 'error');
            return;
        }
        
        console.log('🧹 Starting cleanup of bad Firestore data...');
        let deletedUtilities = 0;
        let deletedStructures = 0;
        
        try {
            // Clean utilities collection
            console.log('🔍 Checking utilities collection...');
            const utilitiesSnapshot = await AppState.safeCollection('utilities').get();
            
            for (const doc of utilitiesSnapshot.docs) {
                const data = doc.data();
                let shouldDelete = false;
                let reason = '';
                
                if (data.isPlaceholder) {
                    shouldDelete = true;
                    reason = 'placeholder document';
                } else if (!data.points || !Array.isArray(data.points)) {
                    shouldDelete = true;
                    reason = 'missing or invalid points array';
                } else if (data.points.length < 2) {
                    shouldDelete = true;
                    reason = 'insufficient points';
                } else {
                    // Check if points have valid lat/lng
                    const invalidPoints = data.points.filter(p => 
                        !p || typeof p.lat !== 'number' || typeof p.lng !== 'number'
                    );
                    if (invalidPoints.length > 0) {
                        shouldDelete = true;
                        reason = 'invalid point coordinates';
                    }
                }
                
                if (shouldDelete) {
                    console.log(`🗑️ Deleting bad utility ${doc.id}: ${reason}`);
                    await doc.ref.delete();
                    deletedUtilities++;
                }
            }
            
            // Clean structures collection
            console.log('🔍 Checking structures collection...');
            const structuresSnapshot = await AppState.safeCollection('structures').get();
            
            for (const doc of structuresSnapshot.docs) {
                const data = doc.data();
                let shouldDelete = false;
                let reason = '';
                
                if (data.isPlaceholder) {
                    shouldDelete = true;
                    reason = 'placeholder document';
                } else if (!data.latlng) {
                    shouldDelete = true;
                    reason = 'missing latlng';
                } else if (typeof data.latlng.lat !== 'number' || typeof data.latlng.lng !== 'number') {
                    shouldDelete = true;
                    reason = 'invalid latlng coordinates';
                }
                
                if (shouldDelete) {
                    console.log(`🗑️ Deleting bad structure ${doc.id}: ${reason}`);
                    await doc.ref.delete();
                    deletedStructures++;
                }
            }
            
            // Clean pending changes collection
            console.log('🔍 Checking pendingChanges collection...');
            const pendingSnapshot = await AppState.safeCollection('pendingChanges').get();
            let deletedPending = 0;
            
            for (const doc of pendingSnapshot.docs) {
                const data = doc.data();
                let shouldDelete = false;
                let reason = '';
                
                if (data.isPlaceholder) {
                    shouldDelete = true;
                    reason = 'placeholder document';
                } else if (data.type === 'utility' && data.data) {
                    if (!data.data.points || !Array.isArray(data.data.points)) {
                        shouldDelete = true;
                        reason = 'invalid utility data';
                    }
                } else if (data.type === 'structure' && data.data) {
                    if (!data.data.latlng) {
                        shouldDelete = true;
                        reason = 'invalid structure data';
                    }
                }
                
                if (shouldDelete) {
                    console.log(`🗑️ Deleting bad pending change ${doc.id}: ${reason}`);
                    await doc.ref.delete();
                    deletedPending++;
                }
            }
            
            console.log(`✅ Cleanup complete!`);
            console.log(`  🗑️ Deleted ${deletedUtilities} bad utilities`);
            console.log(`  🗑️ Deleted ${deletedStructures} bad structures`);
            console.log(`  🗑️ Deleted ${deletedPending} bad pending changes`);
            
            const totalDeleted = deletedUtilities + deletedStructures + deletedPending;
            if (totalDeleted > 0) {
                showToast(`Cleanup complete! Deleted ${totalDeleted} corrupted documents`, 'success');
                
                // Reload the app to refresh data
                setTimeout(() => {
                    console.log('🔄 Reloading app to refresh data...');
                    location.reload();
                }, 2000);
            } else {
                showToast('No corrupted data found - database is clean!', 'info');
            }
            
        } catch (error) {
            console.error('❌ Error during cleanup:', error);
            showToast('Error during cleanup - check console', 'error');
        }
    }
    
    // Make cleanup function available globally for admin use
    window.cleanupBadData = cleanupBadData;
    
    // Premium GPS Debug System
    function debugLocation() {
        const gps = AppState.gps;
        console.log('🔍 Premium GPS Debug Info:');
        console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        console.log('📍 Location State:');
        console.log('  Raw Position:', gps.lastPosition);
        console.log('  Filtered Position:', gps.filteredPosition);
        console.log('  App User Location:', AppState.userLocation);
        console.log('');
        console.log('🎯 GPS Quality:');
        console.log('  Quality Level:', gps.quality);
        console.log('  Last Accuracy:', gps.lastAccuracy?.toFixed(1), 'm');
        console.log('  Is Moving:', gps.isMoving);
        console.log('  Movement Speed:', gps.movementSpeed?.toFixed(2), 'm/s');
        console.log('');
        console.log('🧭 Direction State:');
        console.log('  Raw Heading:', gps.lastHeading?.toFixed(1), '°');
        console.log('  Filtered Heading:', gps.filteredHeading?.toFixed(1), '°');
        console.log('  Heading History:', gps.headingHistory?.map(h => h.toFixed(1)));
        console.log('');
        console.log('📊 Position History:');
        gps.positionHistory?.forEach((pos, i) => {
            console.log(`  ${i}: ${pos.lat.toFixed(6)}, ${pos.lng.toFixed(6)} (${new Date(pos.timestamp).toLocaleTimeString()})`);
        });
        console.log('');
        console.log('🗺️ Marker Info:');
        console.log('  Marker exists:', !!AppState.userMarker);
        if (AppState.userMarker) {
            console.log('  Marker position:', AppState.userMarker.getLatLng());
            const element = AppState.userMarker.getElement();
            if (element) {
                console.log('  Element transform:', element.style.transform);
                const container = element.querySelector('.location-container');
                if (container) {
                    console.log('  GPS Quality attr:', container.getAttribute('data-gps-quality'));
                    console.log('  Moving attr:', container.getAttribute('data-moving'));
                    console.log('  Heading attr:', container.getAttribute('data-heading'));
                }
            }
        }
        console.log('');
        console.log('🗺️ Map State:');
        console.log('  Center:', AppState.map.getCenter());
        console.log('  Zoom:', AppState.map.getZoom());
        console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        
        // Force a premium location update
        if (navigator.geolocation) {
            console.log('🎯 Requesting fresh premium location...');
            navigator.geolocation.getCurrentPosition(
                position => {
                    console.log('📍 Fresh GPS data received');
                    updateUserLocation(position);
                    // Debug the processing
                    setTimeout(() => {
                        console.log('✨ Post-processing GPS state:', {
                            quality: AppState.gps.quality,
                            isMoving: AppState.gps.isMoving,
                            speed: AppState.gps.movementSpeed
                        });
                    }, 100);
                },
                error => console.error('❌ Fresh location error:', error),
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }
    }
    
    // Test Premium GPS System
    function testPremiumGPS() {
        console.log('🧪 Testing Premium GPS System...');
        
        if (!navigator.geolocation) {
            console.error('❌ Geolocation not supported');
            showToast('Geolocation not supported', 'error');
            return;
        }
        
        showToast('🧪 Testing premium GPS - check console for details', 'info');
        
        let testCount = 0;
        const maxTests = 5;
        
        function runTest() {
            testCount++;
            console.log(`🔬 GPS Test ${testCount}/${maxTests}`);
            
            navigator.geolocation.getCurrentPosition(
                position => {
                    console.log(`✅ Test ${testCount} - Raw GPS:`, {
                        lat: position.coords.latitude.toFixed(6),
                        lng: position.coords.longitude.toFixed(6),
                        accuracy: position.coords.accuracy.toFixed(1),
                        speed: position.coords.speed
                    });
                    
                    updateUserLocation(position);
                    
                    setTimeout(() => {
                        console.log(`✨ Test ${testCount} - Processed:`, {
                            quality: AppState.gps.quality,
                            isMoving: AppState.gps.isMoving,
                            speed: AppState.gps.movementSpeed?.toFixed(2),
                            filteredLat: AppState.gps.filteredPosition?.lat.toFixed(6),
                            filteredLng: AppState.gps.filteredPosition?.lng.toFixed(6)
                        });
                        
                        if (testCount < maxTests) {
                            setTimeout(runTest, 2000); // Test every 2 seconds
                        } else {
                            console.log('🎉 Premium GPS test completed!');
                            showToast('Premium GPS test completed! Check console for results.', 'success');
                        }
                    }, 500);
                },
                error => {
                    console.error(`❌ Test ${testCount} failed:`, error);
                    if (testCount < maxTests) {
                        setTimeout(runTest, 2000);
                    }
                },
                { enableHighAccuracy: true, timeout: 15000, maximumAge: 1000 }
            );
        }
        
        runTest();
    }
    
    // Quick Demo of Premium GPS Features
    function demoPremiumGPS() {
        console.log('🎪 Premium GPS Demo Starting...');
        showToast('🎪 Premium GPS Demo - Watch the console!', 'success');
        
        if (!navigator.geolocation) {
            showToast('❌ Geolocation not available', 'error');
            return;
        }
        
        console.log('🔮 Premium GPS Features:');
        console.log('  ✨ Advanced coordinate filtering');
        console.log('  🎯 Movement detection & adaptive smoothing');
        console.log('  🧭 Sophisticated compass heading filters');
        console.log('  📊 Quality-based visual indicators');
        console.log('  🎬 Smooth animations for all updates');
        console.log('  🎨 Multi-layer accuracy visualization');
        
        // Get location and show the filtering in action
        navigator.geolocation.getCurrentPosition(
            position => {
                console.log('📍 Raw GPS received - processing through premium filters...');
                updateUserLocation(position);
                
                setTimeout(() => {
                    debugLocation();
                    showToast('✅ Premium GPS demo complete! Check console for details.', 'success');
                    
                    // Show visual feedback about quality
                    const quality = AppState.gps.quality;
                    const qualityEmoji = {
                        'excellent': '🟢',
                        'good': '🟡', 
                        'fair': '🟠',
                        'poor': '🔴'
                    };
                    
                    showToast(`${qualityEmoji[quality]} GPS Quality: ${quality.toUpperCase()}`, 'info');
                }, 1000);
            },
            error => {
                console.error('❌ Demo failed:', error);
                showToast('❌ GPS demo failed - check permissions', 'error');
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
    }

    window.debugLocation = debugLocation;
    window.testPremiumGPS = testPremiumGPS;
    window.demoPremiumGPS = demoPremiumGPS;
    
    // Test function to verify location marker stability during zoom
    function testLocationMarkerStability() {
        if (!AppState.userMarker) {
            showToast('❌ No location marker found. Enable location tracking first.', 'error');
            return;
        }
        
        console.log('🧪 Testing location marker stability during zoom operations...');
        showToast('🧪 Testing marker stability - check console', 'info');
        
        const startPosition = AppState.userMarker.getLatLng();
        console.log(`📍 Starting position: [${startPosition.lat.toFixed(6)}, ${startPosition.lng.toFixed(6)}]`);
        
        let testStep = 0;
        const testSteps = [
            { zoom: 20, name: 'Maximum zoom' },
            { zoom: 10, name: 'Medium zoom' },
            { zoom: 8, name: 'Low zoom' },
            { zoom: 18, name: 'High zoom' },
            { zoom: 15, name: 'Street level' }
        ];
        
        function runNextTest() {
            if (testStep >= testSteps.length) {
                const finalPosition = AppState.userMarker.getLatLng();
                const drift = startPosition.distanceTo(finalPosition);
                
                console.log(`🎯 Test complete! Final position: [${finalPosition.lat.toFixed(6)}, ${finalPosition.lng.toFixed(6)}]`);
                console.log(`📊 Total drift: ${(drift * 111000).toFixed(2)} meters`);
                
                if (drift < 0.000001) {
                    console.log('✅ SUCCESS: Marker position remained stable throughout all zoom levels!');
                    showToast('✅ Marker stability test PASSED!', 'success');
                } else {
                    console.log('❌ FAILED: Marker position drifted during zoom operations');
                    showToast('❌ Marker stability test FAILED - check console', 'error');
                }
                return;
            }
            
            const step = testSteps[testStep];
            console.log(`🔍 Test ${testStep + 1}: Setting zoom to ${step.zoom} (${step.name})`);
            
            const beforePosition = AppState.userMarker.getLatLng();
            AppState.map.setZoom(step.zoom);
            
            setTimeout(() => {
                const afterPosition = AppState.userMarker.getLatLng();
                const stepDrift = beforePosition.distanceTo(afterPosition);
                
                console.log(`📍 Position after zoom ${step.zoom}: [${afterPosition.lat.toFixed(6)}, ${afterPosition.lng.toFixed(6)}]`);
                console.log(`📊 Step drift: ${(stepDrift * 111000).toFixed(2)} meters`);
                
                if (stepDrift > 0.000001) {
                    console.warn(`⚠️ Position drift detected at zoom ${step.zoom}!`);
                }
                
                testStep++;
                setTimeout(runNextTest, 1000);
            }, 500);
        }
        
        runNextTest();
    }
    
    window.testLocationMarkerStability = testLocationMarkerStability;
    
    // Debug function to test orientation
    function testOrientation() {
        console.log('🧪 Testing orientation system...');
        console.log('Device info:', {
            userAgent: navigator.userAgent,
            isStandalone: window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true,
            hasDeviceOrientationEvent: !!window.DeviceOrientationEvent,
            needsPermission: typeof DeviceOrientationEvent.requestPermission === 'function',
            screenOrientation: screen.orientation ? screen.orientation.angle : window.orientation
        });
        
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            console.log('🔐 Permission required - requesting...');
            requestOrientationPermission();
        } else {
            console.log('✅ No permission required');
            // Test if events are being received
            let eventCount = 0;
            const testListener = (event) => {
                eventCount++;
                console.log(`🧭 Test event ${eventCount}:`, {
                    alpha: event.alpha,
                    webkitCompassHeading: event.webkitCompassHeading,
                    absolute: event.absolute
                });
                
                if (eventCount >= 5) {
                    window.removeEventListener('deviceorientation', testListener);
                    console.log('🧪 Orientation test complete');
                }
            };
            
            window.addEventListener('deviceorientation', testListener);
            showToast('🧪 Testing orientation - check console for 5 events', 'info');
        }
    }
    
    window.testOrientation = testOrientation;

    // Debug function to fix invisible location marker
    function fixLocationMarker() {
        console.log('🔧 Fixing location marker visibility...');
        
        if (!AppState.userMarker) {
            console.log('❌ No user marker found');
            showToast('No location marker found. Enable location first.', 'warning');
            return;
        }
        
        const markerElement = AppState.userMarker.getElement();
        if (!markerElement) {
            console.log('❌ No marker element found');
            showToast('Location marker element not found', 'error');
            return;
        }
        
        // Force visibility
        markerElement.style.opacity = '1.0';
        markerElement.style.visibility = 'visible';
        markerElement.style.display = 'block';
        markerElement.style.zIndex = '1000';
        
        // Apply current zoom scaling
        const zoom = AppState.map.getZoom();
        const scale = calculateUserLocationScale(zoom);
        markerElement.style.transform = `scale(${scale})`;
        markerElement.style.transformOrigin = 'center center';
        
        console.log('✅ Location marker visibility fixed');
        console.log('Current properties:', {
            opacity: markerElement.style.opacity,
            zIndex: markerElement.style.zIndex,
            transform: markerElement.style.transform,
            zoom: zoom,
            scale: scale
        });
        
        showToast('Location marker visibility fixed!', 'success');
        
        // Center on location to make it visible
        if (AppState.userLocation) {
            AppState.map.setView(AppState.userLocation, Math.max(AppState.map.getZoom(), 16));
        }
    }
    
    window.fixLocationMarker = fixLocationMarker;
    
    // Enhanced location marker visibility guardian - VISUALS ONLY, NO POSITION CHANGES
    function ensureLocationMarkerVisibility() {
        if (!AppState.userMarker) return;
        
        const markerElement = AppState.userMarker.getElement();
        if (!markerElement) return;
        
        // Store the current position to prevent any accidental changes
        const lockedPosition = AppState.userMarker.getLatLng();
        
        // Force all visibility properties - NO POSITION CHANGES
        markerElement.style.opacity = '1.0';
        markerElement.style.visibility = 'visible';
        markerElement.style.display = 'block';
        markerElement.style.zIndex = '1000';
        
        // Ensure proper scaling with stable transform
        const zoom = AppState.map.getZoom();
        const scale = calculateUserLocationScale(zoom);
        markerElement.style.transform = `scale(${scale})`;
        markerElement.style.transformOrigin = 'center center';
        
        // Ensure container visibility and attributes - with stability check
        const container = markerElement.querySelector('.location-container');
        if (container) {
            // Only update if visibility has changed to prevent flicker
            if (container.style.opacity !== '1.0') {
                container.style.opacity = '1.0';
            }
            if (container.style.visibility !== 'visible') {
                container.style.visibility = 'visible';
            }
            if (container.style.display !== 'flex') {
                container.style.display = 'flex';
            }
            
            // Update visual attributes without touching position (only when needed)
            if (AppState.gps) {
                const currentQuality = container.getAttribute('data-gps-quality');
                const currentMoving = container.getAttribute('data-moving');
                
                if (currentQuality !== AppState.gps.quality) {
                    container.setAttribute('data-gps-quality', AppState.gps.quality);
                }
                if (currentMoving !== AppState.gps.isMoving.toString()) {
                    container.setAttribute('data-moving', AppState.gps.isMoving.toString());
                }
            }
        }
        
        // Verify position hasn't been accidentally changed by any operations
        const currentPosition = AppState.userMarker.getLatLng();
        if (lockedPosition.distanceTo(currentPosition) > 0.000001) {
            console.warn('⚠️ Guardian detected position drift, restoring locked position');
            AppState.userMarker.setLatLng(lockedPosition);
        }
    }
    
    // Start periodic visibility check - reduced frequency to prevent blinking
    if (typeof window.locationVisibilityInterval === 'undefined') {
        window.locationVisibilityInterval = setInterval(() => {
            if (AppState.userMarker && AppState.map) {
                ensureLocationMarkerVisibility();
            }
        }, 5000); // Check every 5 seconds instead of 2
    }
    
    // Enhanced cleanup function for memory management
    function cleanup() {
        console.log('Cleaning up UtiliTrack resources...');
        
        // Location tracking cleanup
        if (AppState.watchId) {
            navigator.geolocation.clearWatch(AppState.watchId);
            AppState.watchId = null;
        }
        
        // Excavation mode cleanup
        if (AppState.proximityInterval) {
            clearInterval(AppState.proximityInterval);
            AppState.proximityInterval = null;
        }
        
        // Clear all alert timeouts
        AppState.alertTimeouts.forEach((timeout, utilityId) => {
            if (timeout && typeof timeout === 'number') {
                clearTimeout(timeout);
            }
        });
        AppState.alertTimeouts.clear();
        
        // Clear location visibility guardian
        if (window.locationVisibilityInterval) {
            clearInterval(window.locationVisibilityInterval);
            delete window.locationVisibilityInterval;
        }
        
        // Clear refine markers if any exist
        if (AppState.refineMarkers && AppState.refineMarkers.length > 0) {
            AppState.refineMarkers.forEach(marker => {
                try {
                    if (AppState.map && AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                } catch (error) {
                    console.error('Error removing refine marker during cleanup:', error);
                }
            });
            AppState.refineMarkers = [];
        }
        
        // Clear refine mode state
        AppState.refineMode = false;
        
        // Reset premium GPS state
        if (AppState.gps) {
            AppState.gps.lastPosition = null;
            AppState.gps.filteredPosition = null;
            AppState.gps.lastHeading = null;
            AppState.gps.filteredHeading = null;
            AppState.gps.headingHistory = [];
            AppState.gps.positionHistory = [];
        }
        
        // Run all stored cleanup functions
        if (AppState.cleanupFunctions) {
            AppState.cleanupFunctions.forEach(fn => {
                try {
                    fn();
                } catch (error) {
                    console.error('Error in cleanup function:', error);
                }
            });
        }
        
        console.log('UtiliTrack cleanup completed');
    }
    
    // ========== SEARCH FUNCTIONALITY ==========

    function openSearchModal() {
        const modal = document.getElementById('searchModal');
        const input = document.getElementById('searchInput');
        const resultsContainer = document.getElementById('searchResults');
        
        // Debug: Check if we're in standalone mode
        const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                            window.navigator.standalone === true;
        console.log('🔍 Opening search modal - Standalone mode:', isStandalone);
        
        modal.classList.add('active');
        input.focus();
        
        // Clear previous results
        resultsContainer.innerHTML = '';
        input.value = '';
        
        hapticFeedback(30);
    }

    function closeSearchModal() {
        const modal = document.getElementById('searchModal');
        modal.classList.remove('active');
        hapticFeedback(30);
    }

    async function performSearch() {
        const input = document.getElementById('searchInput');
        const resultsContainer = document.getElementById('searchResults');
        const query = input.value.trim();
        
        if (!query) {
            showToast('Please enter a search term', 'warning');
            return;
        }
        
        // Show loading
        resultsContainer.innerHTML = `
            <div class="search-loading">
                <i class="fas fa-spinner"></i>
                <span>Searching...</span>
            </div>
        `;
        
        try {
            console.log('🔍 Searching for:', query);
            
            // Use Nominatim (OpenStreetMap) geocoding service - free and no API key required
            const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=10&countrycodes=us&addressdetails=1`,
                {
                    headers: {
                        'User-Agent': 'CAC-UtiliTrack/1.0'
                    }
                }
            );
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const results = await response.json();
            
            console.log('📍 Search results:', results);
            
            if (results.length === 0) {
                resultsContainer.innerHTML = `
                    <div class="search-loading">
                        <i class="fas fa-search"></i>
                        <span>No results found for "${query}"</span>
                    </div>
                `;
                return;
            }
            
            // Display results
            displaySearchResults(results);
            
        } catch (error) {
            console.error('❌ Search error:', error);
            resultsContainer.innerHTML = `
                <div class="search-loading">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span>Search failed. Please try again.</span>
                </div>
            `;
            showToast('Search failed. Please check your internet connection.', 'error');
        }
    }

    function displaySearchResults(results) {
        const resultsContainer = document.getElementById('searchResults');
        
        resultsContainer.innerHTML = results.map((result, index) => {
            const type = result.type || result.class || 'location';
            const icon = getLocationIcon(type);
            
            // Create display name
            let displayName = result.display_name;
            if (displayName.length > 60) {
                displayName = displayName.substring(0, 60) + '...';
            }
            
            // Get address components
            const address = result.address || {};
            const mainName = address.house_number && address.road 
                ? `${address.house_number} ${address.road}`
                : address.road || address.name || result.display_name.split(',')[0];
            
            const locality = [
                address.city || address.town || address.village,
                address.state,
                address.postcode
            ].filter(Boolean).join(', ');
            
            return `
                <div class="search-result-item" onclick="selectSearchResult(${result.lat}, ${result.lon}, '${mainName.replace(/'/g, "\\'")}')">
                    <div class="search-result-icon">
                        <i class="fas ${icon}"></i>
                    </div>
                    <div class="search-result-content">
                        <div class="search-result-title">${mainName}</div>
                        <div class="search-result-subtitle">${locality}</div>
                    </div>
                </div>
            `;
        }).join('');
    }

    function getLocationIcon(type) {
        const iconMap = {
            'house': 'fa-home',
            'building': 'fa-building',
            'residential': 'fa-home',
            'commercial': 'fa-store',
            'industrial': 'fa-industry',
            'school': 'fa-school',
            'hospital': 'fa-hospital',
            'restaurant': 'fa-utensils',
            'hotel': 'fa-bed',
            'gas_station': 'fa-gas-pump',
            'bank': 'fa-university',
            'park': 'fa-tree',
            'road': 'fa-road',
            'street': 'fa-road',
            'highway': 'fa-highway',
            'city': 'fa-city',
            'town': 'fa-map-marker',
            'village': 'fa-map-marker',
            'suburb': 'fa-map-marker-alt',
            'administrative': 'fa-landmark',
            'boundary': 'fa-map',
            'place': 'fa-map-marker-alt'
        };
        
        return iconMap[type] || 'fa-map-marker-alt';
    }

    function selectSearchResult(lat, lon, name) {
        console.log(`📍 Selected location: ${name} at ${lat}, ${lon}`);
        
        // Center map on selected location
        AppState.map.setView([lat, lon], 18);
        
        // Add temporary marker to show the searched location
        const searchMarker = L.marker([lat, lon], {
            icon: L.divIcon({
                className: 'search-result-marker',
                html: `
                    <div style="
                        width: 40px; 
                        height: 40px; 
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                        border: 3px solid white; 
                        border-radius: 50%; 
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                        animation: searchBounce 0.6s ease-out;
                    ">
                        <i class="fas fa-search" style="color: white; font-size: 16px;"></i>
                    </div>
                `,
                iconSize: [40, 40],
                iconAnchor: [20, 20]
            })
        }).addTo(AppState.map);
        
        // Remove marker after 5 seconds
        setTimeout(() => {
            if (AppState.map.hasLayer(searchMarker)) {
                AppState.map.removeLayer(searchMarker);
            }
        }, 5000);
        
        // Close search modal
        closeSearchModal();
        
        // Show success message
        showToast(`📍 Found: ${name}`, 'success');
        hapticFeedback(100);
    }

    // Make selectSearchResult available globally for onclick handlers
    window.selectSearchResult = selectSearchResult;

    // Add bounce animation CSS
    const searchAnimationStyle = document.createElement('style');
    searchAnimationStyle.textContent = `
        @keyframes searchBounce {
            0% {
                transform: scale(0.3) translateY(-50px);
                opacity: 0;
            }
            50% {
                transform: scale(1.1) translateY(-10px);
                opacity: 1;
            }
            100% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
    `;
    document.head.appendChild(searchAnimationStyle);

    // Cleanup on page unload
    window.addEventListener('beforeunload', cleanup);
    window.addEventListener('pagehide', cleanup);

    /*********************************
    * USER PROFILE & EXPERIENCE SYSTEM
    *********************************/
    const ExperienceSystem = {
        // Level thresholds (exponential progression)
        levelThresholds: [
            0,      // Level 1
            100,    // Level 2
            250,    // Level 3
            450,    // Level 4
            700,    // Level 5
            1000,   // Level 6
            1400,   // Level 7
            1900,   // Level 8
            2500,   // Level 9
            3200,   // Level 10
            4000,   // Level 11
            5000,   // Level 12
            6200,   // Level 13
            7600,   // Level 14
            9200,   // Level 15
            11000,  // Level 16
            13000,  // Level 17
            15300,  // Level 18
            17900,  // Level 19
            20800,  // Level 20
        ],
        
        // Achievement definitions
        achievements: {
            first_steps: {
                id: 'first_steps',
                name: 'First Steps',
                description: 'Draw your first utility',
                exp: 50,
                icon: 'route',
                check: (userData) => userData.totalUtilitiesDrawn >= 1
            },
            mapper_novice: {
                id: 'mapper_novice',
                name: 'Mapper Novice',
                description: 'Draw 10 utilities',
                exp: 100,
                icon: 'map',
                check: (userData) => userData.totalUtilitiesDrawn >= 10
            },
            jack_of_all_trades: {
                id: 'jack_of_all_trades',
                name: 'Jack of All Trades',
                description: 'Draw all 5 utility types',
                exp: 200,
                icon: 'layers',
                check: (userData) => {
                    return userData.statsWater > 0 && userData.statsGas > 0 && 
                           userData.statsElectric > 0 && userData.statsSewer > 0 && 
                           userData.statsTelecom > 0;
                }
            },
            mile_walker: {
                id: 'mile_walker',
                name: 'A Mile in My Shoes',
                description: 'Draw a mile of utilities total',
                exp: 300,
                icon: 'ruler',
                check: (userData) => userData.totalDistance >= 1609.34 // 1 mile in meters
            },
            first_delete: {
                id: 'first_delete',
                name: 'Clean Slate',
                description: 'Delete your first utility',
                exp: 25,
                icon: 'trash',
                requiresAction: 'delete'
            },
            first_edit: {
                id: 'first_edit',
                name: 'Perfectionist',
                description: 'Edit your first utility',
                exp: 25,
                icon: 'edit',
                requiresAction: 'edit'
            },
            first_refine: {
                id: 'first_refine',
                name: 'Fine Tuner',
                description: 'Refine your first utility',
                exp: 25,
                icon: 'crosshairs',
                requiresAction: 'refine'
            },
            // Type-specific achievements
            water_10: { id: 'water_10', name: 'Water Apprentice', description: 'Draw 10 water utilities', exp: 50, icon: 'tint', check: (userData) => userData.statsWater >= 10 },
            water_25: { id: 'water_25', name: 'Water Journeyman', description: 'Draw 25 water utilities', exp: 100, icon: 'tint', check: (userData) => userData.statsWater >= 25 },
            water_50: { id: 'water_50', name: 'Water Expert', description: 'Draw 50 water utilities', exp: 150, icon: 'tint', check: (userData) => userData.statsWater >= 50 },
            water_100: { id: 'water_100', name: 'Water Master', description: 'Draw 100 water utilities', exp: 250, icon: 'tint', check: (userData) => userData.statsWater >= 100 },
            water_150: { id: 'water_150', name: 'Water Legend', description: 'Draw 150 water utilities', exp: 350, icon: 'tint', check: (userData) => userData.statsWater >= 150 },
            water_200: { id: 'water_200', name: 'Water Grandmaster', description: 'Draw 200 water utilities', exp: 500, icon: 'tint', check: (userData) => userData.statsWater >= 200 },
            
            gas_10: { id: 'gas_10', name: 'Gas Apprentice', description: 'Draw 10 gas utilities', exp: 50, icon: 'fire', check: (userData) => userData.statsGas >= 10 },
            gas_25: { id: 'gas_25', name: 'Gas Journeyman', description: 'Draw 25 gas utilities', exp: 100, icon: 'fire', check: (userData) => userData.statsGas >= 25 },
            gas_50: { id: 'gas_50', name: 'Gas Expert', description: 'Draw 50 gas utilities', exp: 150, icon: 'fire', check: (userData) => userData.statsGas >= 50 },
            gas_100: { id: 'gas_100', name: 'Gas Master', description: 'Draw 100 gas utilities', exp: 250, icon: 'fire', check: (userData) => userData.statsGas >= 100 },
            gas_150: { id: 'gas_150', name: 'Gas Legend', description: 'Draw 150 gas utilities', exp: 350, icon: 'fire', check: (userData) => userData.statsGas >= 150 },
            gas_200: { id: 'gas_200', name: 'Gas Grandmaster', description: 'Draw 200 gas utilities', exp: 500, icon: 'fire', check: (userData) => userData.statsGas >= 200 },
            
            electric_10: { id: 'electric_10', name: 'Electric Apprentice', description: 'Draw 10 electric utilities', exp: 50, icon: 'bolt', check: (userData) => userData.statsElectric >= 10 },
            electric_25: { id: 'electric_25', name: 'Electric Journeyman', description: 'Draw 25 electric utilities', exp: 100, icon: 'bolt', check: (userData) => userData.statsElectric >= 25 },
            electric_50: { id: 'electric_50', name: 'Electric Expert', description: 'Draw 50 electric utilities', exp: 150, icon: 'bolt', check: (userData) => userData.statsElectric >= 50 },
            electric_100: { id: 'electric_100', name: 'Electric Master', description: 'Draw 100 electric utilities', exp: 250, icon: 'bolt', check: (userData) => userData.statsElectric >= 100 },
            electric_150: { id: 'electric_150', name: 'Electric Legend', description: 'Draw 150 electric utilities', exp: 350, icon: 'bolt', check: (userData) => userData.statsElectric >= 150 },
            electric_200: { id: 'electric_200', name: 'Electric Grandmaster', description: 'Draw 200 electric utilities', exp: 500, icon: 'bolt', check: (userData) => userData.statsElectric >= 200 },
            
            sewer_10: { id: 'sewer_10', name: 'Sewer Apprentice', description: 'Draw 10 sewer utilities', exp: 50, icon: 'toilet', check: (userData) => userData.statsSewer >= 10 },
            sewer_25: { id: 'sewer_25', name: 'Sewer Journeyman', description: 'Draw 25 sewer utilities', exp: 100, icon: 'toilet', check: (userData) => userData.statsSewer >= 25 },
            sewer_50: { id: 'sewer_50', name: 'Sewer Expert', description: 'Draw 50 sewer utilities', exp: 150, icon: 'toilet', check: (userData) => userData.statsSewer >= 50 },
            sewer_100: { id: 'sewer_100', name: 'Sewer Master', description: 'Draw 100 sewer utilities', exp: 250, icon: 'toilet', check: (userData) => userData.statsSewer >= 100 },
            sewer_150: { id: 'sewer_150', name: 'Sewer Legend', description: 'Draw 150 sewer utilities', exp: 350, icon: 'toilet', check: (userData) => userData.statsSewer >= 150 },
            sewer_200: { id: 'sewer_200', name: 'Sewer Grandmaster', description: 'Draw 200 sewer utilities', exp: 500, icon: 'toilet', check: (userData) => userData.statsSewer >= 200 },
            
            telecom_10: { id: 'telecom_10', name: 'Telecom Apprentice', description: 'Draw 10 telecom utilities', exp: 50, icon: 'phone', check: (userData) => userData.statsTelecom >= 10 },
            telecom_25: { id: 'telecom_25', name: 'Telecom Journeyman', description: 'Draw 25 telecom utilities', exp: 100, icon: 'phone', check: (userData) => userData.statsTelecom >= 25 },
            telecom_50: { id: 'telecom_50', name: 'Telecom Expert', description: 'Draw 50 telecom utilities', exp: 150, icon: 'phone', check: (userData) => userData.statsTelecom >= 50 },
            telecom_100: { id: 'telecom_100', name: 'Telecom Master', description: 'Draw 100 telecom utilities', exp: 250, icon: 'phone', check: (userData) => userData.statsTelecom >= 100 },
            telecom_150: { id: 'telecom_150', name: 'Telecom Legend', description: 'Draw 150 telecom utilities', exp: 350, icon: 'phone', check: (userData) => userData.statsTelecom >= 150 },
            telecom_200: { id: 'telecom_200', name: 'Telecom Grandmaster', description: 'Draw 200 telecom utilities', exp: 500, icon: 'phone', check: (userData) => userData.statsTelecom >= 200 },
        },
        
        // Initialize the experience system
        init: async function() {
            if (!firebase.auth().currentUser) return;
            
            const userId = firebase.auth().currentUser.uid;
            const userRef = firebase.firestore().collection('users').doc(userId);
            
            // Listen to user data changes
            userRef.onSnapshot((doc) => {
                if (doc.exists) {
                    const userData = doc.data();
                    this.updateUserProfile(userData);
                }
            });
            
            // Create profile widget if it doesn't exist
            if (!document.getElementById('user-profile-widget')) {
                this.createProfileWidget();
            }
            
            // Initialize audit log button for admins
            const userData = await this.getUserData();
            if (userData && userData.role === 'admin') {
                this.createAuditLogButton();
            }
        },
        
        // Get current user data
        getUserData: async function() {
            if (!firebase.auth().currentUser) return null;
            
            const userId = firebase.auth().currentUser.uid;
            const userDoc = await firebase.firestore().collection('users').doc(userId).get();
            
            if (userDoc.exists) {
                return userDoc.data();
            }
            return null;
        },
        
        // Create profile widget
        createProfileWidget: function() {
            const widget = document.createElement('div');
            widget.id = 'user-profile-widget';
            widget.className = 'user-profile-widget';
            widget.innerHTML = `
                <div class="profile-avatar-container">
                    <div class="profile-avatar">
                        <svg class="avatar-svg" viewBox="0 0 100 100" id="avatar-svg">
                            <!-- Avatar will be generated here -->
                        </svg>
                    </div>
                    <div class="exp-ring">
                        <svg viewBox="0 0 50 50">
                            <defs>
                                <linearGradient id="expGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <circle cx="25" cy="25" r="22" class="exp-ring-bg" />
                            <circle cx="25" cy="25" r="22" class="exp-ring-fill" id="exp-ring-fill" />
                        </svg>
                    </div>
                    <div class="level-badge" id="level-badge">1</div>
                </div>
                <div class="profile-info">
                    <div class="profile-name" id="profile-name">Loading...</div>
                    <div class="profile-exp" id="profile-exp">0 / 100 EXP</div>
                    <div class="exp-progress">
                        <div class="exp-progress-bar" id="exp-progress-bar" style="width: 0%"></div>
                    </div>
                </div>
            `;
            document.body.appendChild(widget);
            
            // Add click handler for expand/collapse
            let isExpanded = false;
            let expandTimeout;
            
            widget.addEventListener('click', () => {
                if (!isExpanded) {
                    // Expand
                    widget.classList.add('expanded');
                    isExpanded = true;
                    
                    // Auto-collapse after 3 seconds if not hovering
                    expandTimeout = setTimeout(() => {
                        if (!widget.matches(':hover')) {
                            widget.classList.remove('expanded');
                            isExpanded = false;
                        }
                    }, 3000);
                } else {
                    // Collapse
                    widget.classList.remove('expanded');
                    isExpanded = false;
                    clearTimeout(expandTimeout);
                }
            });
            
            // Keep expanded while hovering
            widget.addEventListener('mouseenter', () => {
                clearTimeout(expandTimeout);
            });
            
            // Auto-collapse when not hovering (if expanded)
            widget.addEventListener('mouseleave', () => {
                if (isExpanded) {
                    expandTimeout = setTimeout(() => {
                        widget.classList.remove('expanded');
                        isExpanded = false;
                    }, 1000);
                }
            });
        },
        
        // Update user profile display
        updateUserProfile: function(userData) {
            if (!userData) return;
            
            // Ensure required fields exist with defaults
            const exp = userData.exp || 0;
            const level = userData.level || 1;
            const profileAvatar = userData.profileAvatar || 1;
            const email = userData.email || 'Unknown User';
            
            // Update profile name
            const profileName = document.getElementById('profile-name');
            if (profileName) {
                profileName.textContent = email.split('@')[0];
            }
            
            // Update level badge
            const levelBadge = document.getElementById('level-badge');
            if (levelBadge) {
                levelBadge.textContent = level;
            }
            
            // Calculate exp progress
            const currentLevelThreshold = this.levelThresholds[level - 1] || 0;
            const nextLevelThreshold = this.levelThresholds[level] || this.levelThresholds[this.levelThresholds.length - 1];
            const levelProgress = exp - currentLevelThreshold;
            const levelRequired = nextLevelThreshold - currentLevelThreshold;
            const progressPercent = (levelProgress / levelRequired) * 100;
            
            // Update exp text
            const profileExp = document.getElementById('profile-exp');
            if (profileExp) {
                profileExp.textContent = `${levelProgress} / ${levelRequired} EXP`;
            }
            
            // Update progress bar
            const progressBar = document.getElementById('exp-progress-bar');
            if (progressBar) {
                progressBar.style.width = `${progressPercent}%`;
            }
            
            // Update exp ring
            const expRing = document.getElementById('exp-ring-fill');
            if (expRing) {
                const circumference = 2 * Math.PI * 22;
                const strokeDasharray = `${(progressPercent / 100) * circumference} ${circumference}`;
                expRing.style.strokeDasharray = strokeDasharray;
            }
            
            // Update avatar
            this.updateAvatar(level);
        },
        
        // Update avatar based on level
        updateAvatar: function(level) {
            const avatarSvg = document.getElementById('avatar-svg');
            if (!avatarSvg) return;
            
            // Generate geometric avatar based on level
            const shapes = this.generateAvatarShapes(level);
            avatarSvg.innerHTML = shapes;
        },
        
        // Generate avatar shapes based on level
        generateAvatarShapes: function(level) {
            let shapes = '';
            const baseColor = 'rgba(255, 255, 255, 0.9)';
            
            // Level 1-5: Simple shapes
            if (level >= 1) {
                shapes += `<circle cx="50" cy="50" r="30" fill="${baseColor}" />`;
            }
            
            // Level 6-10: Add inner details
            if (level >= 6) {
                shapes += `<circle cx="50" cy="50" r="20" fill="none" stroke="${baseColor}" stroke-width="2" />`;
            }
            
            // Level 11-15: Add triangular elements
            if (level >= 11) {
                shapes += `<polygon points="50,25 65,45 35,45" fill="${baseColor}" opacity="0.6" />`;
                shapes += `<polygon points="50,75 65,55 35,55" fill="${baseColor}" opacity="0.6" />`;
            }
            
            // Level 16-20: Add hexagonal frame
            if (level >= 16) {
                shapes += `<polygon points="50,15 75,32.5 75,67.5 50,85 25,67.5 25,32.5" fill="none" stroke="${baseColor}" stroke-width="2" />`;
            }
            
            // Level 21+: Add star pattern
            if (level >= 21) {
                const starPoints = this.generateStarPoints(50, 50, 5, 25, 15);
                shapes += `<polygon points="${starPoints}" fill="${baseColor}" opacity="0.4" />`;
            }
            
            return shapes;
        },
        
        // Generate star points for avatar
        generateStarPoints: function(cx, cy, spikes, outerRadius, innerRadius) {
            let points = '';
            const step = Math.PI / spikes;
            
            for (let i = 0; i < 2 * spikes; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = cx + Math.cos(i * step - Math.PI / 2) * radius;
                const y = cy + Math.sin(i * step - Math.PI / 2) * radius;
                points += `${x},${y} `;
            }
            
            return points.trim();
        },
        
        // Award experience points
        awardExp: async function(amount, reason) {
            if (!firebase.auth().currentUser) return;
            
            const userId = firebase.auth().currentUser.uid;
            const userRef = firebase.firestore().collection('users').doc(userId);
            
            try {
                const userData = await this.getUserData();
                if (!userData) return;
                
                const currentExp = userData.exp || 0;
                const currentLevel = userData.level || 1;
                const newExp = currentExp + amount;
                
                // Calculate new level
                let newLevel = currentLevel;
                for (let i = 0; i < this.levelThresholds.length; i++) {
                    if (newExp >= this.levelThresholds[i]) {
                        newLevel = i + 1;
                    }
                }
                
                // Update user data
                await userRef.update({
                    exp: newExp,
                    level: newLevel,
                    lastActiveDate: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Show exp gain animation
                this.showExpGain(amount);
                
                // Check for level up
                if (newLevel > currentLevel) {
                    this.showLevelUp(newLevel);
                }
                
            } catch (error) {
                console.error('Error awarding exp:', error);
            }
        },
        
        // Show exp gain animation
        showExpGain: function(amount) {
            const widget = document.getElementById('user-profile-widget');
            if (!widget) return;
            
            const popup = document.createElement('div');
            popup.className = 'exp-gain-popup';
            popup.textContent = `+${amount} EXP`;
            popup.style.left = '60px';
            popup.style.top = '20px';
            
            widget.appendChild(popup);
            
            setTimeout(() => {
                popup.remove();
            }, 1500);
        },
        
        // Show level up animation
        showLevelUp: function(newLevel) {
            const levelUpDiv = document.createElement('div');
            levelUpDiv.className = 'level-up-animation';
            levelUpDiv.innerHTML = `
                <div class="level-up-content">
                    <div class="level-up-icon">
                        <div class="level-up-number">${newLevel}</div>
                    </div>
                    <div class="level-up-text">Level Up!</div>
                    <div class="level-up-subtext">You've reached level ${newLevel}</div>
                    <div class="level-particles" id="level-particles"></div>
                </div>
            `;
            
            document.body.appendChild(levelUpDiv);
            
            // Create particles
            const particlesContainer = document.getElementById('level-particles');
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = '50%';
                particle.style.top = '50%';
                particle.style.setProperty('--tx', `${(Math.random() - 0.5) * 200}px`);
                particle.style.setProperty('--ty', `${(Math.random() - 0.5) * 200}px`);
                particle.style.animationDelay = `${Math.random() * 0.5}s`;
                particlesContainer.appendChild(particle);
            }
            
            // Remove after animation
            setTimeout(() => {
                levelUpDiv.remove();
            }, 3000);
        },
        
        // Check achievements
        checkAchievements: async function(action) {
            if (!firebase.auth().currentUser) return;
            
            const userId = firebase.auth().currentUser.uid;
            const userRef = firebase.firestore().collection('users').doc(userId);
            const userData = await this.getUserData();
            
            if (!userData) return;
            
            const currentAchievements = userData.achievements || [];
            
            for (const [key, achievement] of Object.entries(this.achievements)) {
                // Skip if already earned
                if (currentAchievements.includes(achievement.id)) continue;
                
                // Check if achievement requires specific action
                if (achievement.requiresAction && achievement.requiresAction !== action) continue;
                
                // Check if achievement is earned
                if (achievement.check && achievement.check(userData)) {
                    // Award achievement
                    await userRef.update({
                        achievements: firebase.firestore.FieldValue.arrayUnion(achievement.id)
                    });
                    
                    // Award exp
                    await this.awardExp(achievement.exp, `Achievement: ${achievement.name}`);
                    
                    // Show achievement toast
                    this.showAchievementToast(achievement);
                }
            }
        },
        
        // Show achievement toast
        showAchievementToast: function(achievement) {
            const toast = document.createElement('div');
            toast.className = 'achievement-toast';
            toast.innerHTML = `
                <div class="achievement-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" fill="currentColor"/>
                    </svg>
                </div>
                <div class="achievement-content">
                    <div class="achievement-title">${achievement.name}</div>
                    <div class="achievement-desc">${achievement.description}</div>
                    <div class="achievement-exp">+${achievement.exp} EXP</div>
                </div>
                <button class="achievement-close">
                    <i class="fas fa-times"></i>
                </button>
            `;
            
            document.body.appendChild(toast);
            
            // Show animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);
            
            // Auto hide after 5 seconds
            const hideTimeout = setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    toast.remove();
                }, 500);
            }, 5000);
            
            // Close button
            toast.querySelector('.achievement-close').addEventListener('click', () => {
                clearTimeout(hideTimeout);
                toast.classList.remove('show');
                setTimeout(() => {
                    toast.remove();
                }, 500);
            });
        },
        
        // Create audit log button for admins
        createAuditLogButton: function() {
            if (AppState.userRole === 'admin') {
                const adminBtn = document.querySelector('.admin-btn');
                if (adminBtn && !document.getElementById('audit-log-btn')) {
                    const auditBtn = document.createElement('button');
                    auditBtn.className = 'admin-btn';
                    auditBtn.id = 'audit-log-btn';
                    auditBtn.style.right = 'calc(var(--spacing-md) + 160px)';
                    auditBtn.innerHTML = '<i class="fas fa-history"></i>';
                    auditBtn.title = 'Audit Log';
                    auditBtn.onclick = () => AuditLog.toggle();
                    document.body.appendChild(auditBtn);
                }
            }
        },
        
        // Calculate utility distance
        calculateUtilityDistance: function(points) {
            let totalDistance = 0;
            
            for (let i = 0; i < points.length - 1; i++) {
                const distance = haversineDistance(
                    points[i].lat || points[i][0], 
                    points[i].lng || points[i][1],
                    points[i + 1].lat || points[i + 1][0], 
                    points[i + 1].lng || points[i + 1][1]
                );
                totalDistance += distance;
            }
            
            return totalDistance; // Returns meters
        }
    };

    /*********************************
    * AUDIT LOG SYSTEM
    *********************************/
    const AuditLog = {
        isOpen: false,
        currentFilter: 'all',
        
        // Initialize audit log
        init: function() {
            this.createAuditLogPanel();
        },
        
        // Create audit log panel
        createAuditLogPanel: function() {
            const panel = document.createElement('div');
            panel.className = 'audit-log-panel';
            panel.id = 'audit-log-panel';
            panel.innerHTML = `
                <div class="audit-log-header">
                    <div class="audit-log-title">Audit Log</div>
                    <button class="audit-log-close" id="audit-log-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="audit-log-filters">
                    <button class="audit-filter-btn active" data-filter="all">All</button>
                    <button class="audit-filter-btn" data-filter="created">Created</button>
                    <button class="audit-filter-btn" data-filter="edited">Edited</button>
                    <button class="audit-filter-btn" data-filter="deleted">Deleted</button>
                    <button class="audit-filter-btn" data-filter="refined">Refined</button>
                </div>
                <div class="audit-log-list" id="audit-log-list">
                    <!-- Logs will be populated here -->
                </div>
            `;
            
            document.body.appendChild(panel);
            
            // Event listeners
            document.getElementById('audit-log-close').addEventListener('click', () => {
                this.close();
            });
            
            // Filter buttons
            panel.querySelectorAll('.audit-filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.setFilter(btn.getAttribute('data-filter'));
                });
            });
        },
        
        // Toggle audit log panel
        toggle: function() {
            if (this.isOpen) {
                this.close();
            } else {
                this.open();
            }
        },
        
        // Open audit log
        open: function() {
            this.isOpen = true;
            document.getElementById('audit-log-panel').classList.add('show');
            this.loadLogs();
        },
        
        // Close audit log
        close: function() {
            this.isOpen = false;
            document.getElementById('audit-log-panel').classList.remove('show');
        },
        
        // Set filter
        setFilter: function(filter) {
            this.currentFilter = filter;
            
            // Update button states
            document.querySelectorAll('.audit-filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-filter') === filter);
            });
            
            this.loadLogs();
        },
        
        // Load audit logs
        loadLogs: async function() {
            const logList = document.getElementById('audit-log-list');
            logList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-tertiary);">Loading...</div>';
            
            try {
                let query = firebase.firestore().collection('auditLogs')
                    .orderBy('timestamp', 'desc')
                    .limit(100);
                
                if (this.currentFilter !== 'all') {
                    query = query.where('action', '==', this.currentFilter);
                }
                
                const snapshot = await query.get();
                
                if (snapshot.empty) {
                    logList.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-tertiary);">No audit logs found</div>';
                    return;
                }
                
                logList.innerHTML = '';
                
                snapshot.forEach(doc => {
                    const log = doc.data();
                    const logItem = this.createLogItem(log);
                    logList.appendChild(logItem);
                });
                
            } catch (error) {
                console.error('Error loading audit logs:', error);
                logList.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--danger-color);">Error loading logs</div>';
            }
        },
        
        // Create log item element
        createLogItem: function(log) {
            const item = document.createElement('div');
            item.className = 'audit-log-item';
            
            const timestamp = log.timestamp ? new Date(log.timestamp.toDate()).toLocaleString() : 'Unknown time';
            
            item.innerHTML = `
                <div class="audit-item-header">
                    <span class="audit-action-badge ${log.action}">${log.action}</span>
                    <span class="audit-timestamp">${timestamp}</span>
                </div>
                <div class="audit-user">${log.userEmail || 'Unknown user'}</div>
                <div class="audit-details">${this.formatDetails(log)}</div>
                <div class="audit-entity-type">
                    <i class="fas fa-${log.entityType === 'utility' ? 'grip-lines' : 'shapes'}"></i>
                    ${log.entityType}
                </div>
            `;
            
            return item;
        },
        
        // Format log details
        formatDetails: function(log) {
            const details = log.details || {};
            let text = '';
            
            switch (log.action) {
                case 'created':
                    text = `Created new ${details.utilityType || log.entityType}`;
                    if (details.lineType) text += ` (${details.lineType} line)`;
                    break;
                case 'edited':
                    text = `Edited ${details.utilityType || log.entityType}`;
                    if (details.changes) text += ` - ${details.changes}`;
                    break;
                case 'deleted':
                    text = `Deleted ${details.utilityType || log.entityType}`;
                    break;
                case 'refined':
                    text = `Refined position of ${details.utilityType || log.entityType}`;
                    break;
                default:
                    text = `Performed ${log.action} on ${log.entityType}`;
            }
            
            return text;
        },
        
        // Log an action
        logAction: async function(action, entityType, entityId, details = {}) {
            if (!firebase.auth().currentUser) return;
            
            const userId = firebase.auth().currentUser.uid;
            const userEmail = firebase.auth().currentUser.email;
            
            try {
                await firebase.firestore().collection('auditLogs').add({
                    action: action,
                    entityType: entityType,
                    entityId: entityId,
                    userId: userId,
                    userEmail: userEmail,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    details: details
                });
            } catch (error) {
                console.error('Error logging action:', error);
            }
        }
    };

    // Hook into existing utility creation function - store original only once
    if (!window.originalFinishDrawing) {
        window.originalFinishDrawing = finishDrawing;
        
        // Override with experience system integration
        finishDrawing = async function() {
            // Call the original function first
            await window.originalFinishDrawing.call(this);
            
            // If drawing was successful, add experience system tracking
            if (AppState.utilities.length > 0) {
                const lastUtility = AppState.utilities[AppState.utilities.length - 1];
                
                // Calculate distance for exp
                const distance = ExperienceSystem.calculateUtilityDistance(lastUtility.points);
                const expGained = Math.round(distance / 10); // 1 exp per 10 meters
                
                // Store distance for future reference
                lastUtility.distance = distance;
                lastUtility.createdBy = firebase.auth().currentUser ? firebase.auth().currentUser.uid : null;

                // Update user stats and award exp
                if (firebase.auth().currentUser) {
                    const userId = firebase.auth().currentUser.uid;
                    const userRef = firebase.firestore().collection('users').doc(userId);
                    
                    const updateData = {
                        totalUtilitiesDrawn: firebase.firestore.FieldValue.increment(1),
                        totalDistance: firebase.firestore.FieldValue.increment(distance),
                        lastActiveDate: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    // Update specific utility type count
                    updateData[`stats${lastUtility.type.charAt(0).toUpperCase() + lastUtility.type.slice(1)}`] = firebase.firestore.FieldValue.increment(1);
                    
                    // Set first utility date if not set
                    const userData = await ExperienceSystem.getUserData();
                    if (userData && !userData.firstUtilityDate) {
                        updateData.firstUtilityDate = firebase.firestore.FieldValue.serverTimestamp();
                    }
                    
                    await userRef.update(updateData);
                    
                    // Award exp
                    await ExperienceSystem.awardExp(expGained, 'Utility drawn');
                    
                    // Check achievements
                    await ExperienceSystem.checkAchievements('draw');
                    
                    // Log to audit
                    await AuditLog.logAction('created', 'utility', lastUtility.id, {
                        utilityType: lastUtility.type,
                        lineType: lastUtility.lineType,
                        distance: distance
                    });
                }
            }
        };
    }

    // Hook into existing delete function
    const originalDeleteUtility = deleteUtility;
    deleteUtility = async function() {
        if (!AppState.selectedUtilityData) return;

        const utility = AppState.selectedUtilityData;
        let expLost = 0;

        // Check if current user created this utility
        if (firebase.auth().currentUser && utility.createdBy === firebase.auth().currentUser.uid) {
            expLost = Math.round((utility.distance || 0) / 10);
        }

        // Call original delete function
        await originalDeleteUtility();

        // Update user stats if they created it
        if (firebase.auth().currentUser && utility.createdBy === firebase.auth().currentUser.uid) {
            const userRef = firebase.firestore().collection('users').doc(firebase.auth().currentUser.uid);
            
            const updateData = {
                totalUtilitiesDrawn: firebase.firestore.FieldValue.increment(-1),
                totalDistance: firebase.firestore.FieldValue.increment(-(utility.distance || 0))
            };
            
            // Update specific utility type count
            updateData[`stats${utility.type.charAt(0).toUpperCase() + utility.type.slice(1)}`] = firebase.firestore.FieldValue.increment(-1);
            
            await userRef.update(updateData);
            
            // Remove exp
            if (expLost > 0) {
                await ExperienceSystem.awardExp(-expLost, 'Utility deleted');
            }
            
            // Check delete achievement
            const userData = await ExperienceSystem.getUserData();
            if (userData && !userData.achievements.includes('first_delete')) {
                await ExperienceSystem.checkAchievements('delete');
            }
        }

        // Log to audit
        await AuditLog.logAction('deleted', 'utility', utility.id, {
            utilityType: utility.type,
            lineType: utility.lineType
        });
    };

    // Hook into existing edit function
    const originalSaveEdit = saveEdit;
    saveEdit = async function() {
        if (!AppState.selectedUtilityData) return;

        const utility = AppState.selectedUtilityData;
        const originalValues = {
            size: utility.size,
            depth: utility.depth,
            material: utility.material,
            condition: utility.condition
        };

        // Call original save edit function
        await originalSaveEdit();

        // Log changes if successful
        if (firebase.auth().currentUser) {
            const changes = [];
            if (originalValues.size !== utility.size) changes.push('size');
            if (originalValues.depth !== utility.depth) changes.push('depth');
            if (originalValues.material !== utility.material) changes.push('material');
            if (originalValues.condition !== utility.condition) changes.push('condition');
            
            if (changes.length > 0) {
                await AuditLog.logAction('edited', 'utility', utility.id, {
                    utilityType: utility.type,
                    changes: changes.join(', ')
                });
                
                // Check edit achievement
                const userData = await ExperienceSystem.getUserData();
                if (userData && !userData.achievements.includes('first_edit')) {
                    await ExperienceSystem.checkAchievements('edit');
                }
            }
        }
    };

    // Hook into existing refine function
    const originalFinishRefining = finishRefining;
    finishRefining = async function() {
        const utility = AppState.selectedUtilityData;
        
        // Call original refine function
        await originalFinishRefining();
        
        // Log refine action
        if (utility && firebase.auth().currentUser) {
            await AuditLog.logAction('refined', 'utility', utility.id, {
                utilityType: utility.type,
                lineType: utility.lineType
            });
            
            // Check refine achievement
            const userData = await ExperienceSystem.getUserData();
            if (userData && !userData.achievements.includes('first_refine')) {
                await ExperienceSystem.checkAchievements('refine');
            }
        }
    };

    // Initialize systems when auth state changes
    firebase.auth().onAuthStateChanged(async (user) => {
        if (user) {
            // Ensure user document has required fields
            const userRef = firebase.firestore().collection('users').doc(user.uid);
            const userDoc = await userRef.get();
            
            if (userDoc.exists) {
                const userData = userDoc.data();
                const updates = {};
                
                // Check and add missing fields
                if (userData.exp === undefined) updates.exp = 0;
                if (userData.level === undefined) updates.level = 1;
                if (userData.achievements === undefined) updates.achievements = [];
                if (userData.totalUtilitiesDrawn === undefined) updates.totalUtilitiesDrawn = 0;
                if (userData.profileAvatar === undefined) updates.profileAvatar = 1;
                if (userData.statsWater === undefined) updates.statsWater = 0;
                if (userData.statsGas === undefined) updates.statsGas = 0;
                if (userData.statsElectric === undefined) updates.statsElectric = 0;
                if (userData.statsSewer === undefined) updates.statsSewer = 0;
                if (userData.statsTelecom === undefined) updates.statsTelecom = 0;
                if (userData.totalDistance === undefined) updates.totalDistance = 0;
                
                // Update if there are missing fields
                if (Object.keys(updates).length > 0) {
                    await userRef.update(updates);
                }
            }
            
            // Initialize systems
            await ExperienceSystem.init();
            AuditLog.init();
        }
    });
</script>

</body>
</html>
